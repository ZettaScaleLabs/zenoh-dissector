/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _CRT_HAS_C11: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const PRId8: &[u8; 4] = b"hhd\0";
pub const PRId16: &[u8; 3] = b"hd\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 4] = b"lld\0";
pub const PRIdLEAST8: &[u8; 4] = b"hhd\0";
pub const PRIdLEAST16: &[u8; 3] = b"hd\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 4] = b"lld\0";
pub const PRIdFAST8: &[u8; 4] = b"hhd\0";
pub const PRIdFAST16: &[u8; 2] = b"d\0";
pub const PRIdFAST32: &[u8; 2] = b"d\0";
pub const PRIdFAST64: &[u8; 4] = b"lld\0";
pub const PRIdMAX: &[u8; 4] = b"lld\0";
pub const PRIdPTR: &[u8; 4] = b"lld\0";
pub const PRIi8: &[u8; 4] = b"hhi\0";
pub const PRIi16: &[u8; 3] = b"hi\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 4] = b"lli\0";
pub const PRIiLEAST8: &[u8; 4] = b"hhi\0";
pub const PRIiLEAST16: &[u8; 3] = b"hi\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 4] = b"lli\0";
pub const PRIiFAST8: &[u8; 4] = b"hhi\0";
pub const PRIiFAST16: &[u8; 2] = b"i\0";
pub const PRIiFAST32: &[u8; 2] = b"i\0";
pub const PRIiFAST64: &[u8; 4] = b"lli\0";
pub const PRIiMAX: &[u8; 4] = b"lli\0";
pub const PRIiPTR: &[u8; 4] = b"lli\0";
pub const PRIo8: &[u8; 4] = b"hho\0";
pub const PRIo16: &[u8; 3] = b"ho\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 4] = b"llo\0";
pub const PRIoLEAST8: &[u8; 4] = b"hho\0";
pub const PRIoLEAST16: &[u8; 3] = b"ho\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 4] = b"llo\0";
pub const PRIoFAST8: &[u8; 4] = b"hho\0";
pub const PRIoFAST16: &[u8; 2] = b"o\0";
pub const PRIoFAST32: &[u8; 2] = b"o\0";
pub const PRIoFAST64: &[u8; 4] = b"llo\0";
pub const PRIoMAX: &[u8; 4] = b"llo\0";
pub const PRIoPTR: &[u8; 4] = b"llo\0";
pub const PRIu8: &[u8; 4] = b"hhu\0";
pub const PRIu16: &[u8; 3] = b"hu\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 4] = b"llu\0";
pub const PRIuLEAST8: &[u8; 4] = b"hhu\0";
pub const PRIuLEAST16: &[u8; 3] = b"hu\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 4] = b"llu\0";
pub const PRIuFAST8: &[u8; 4] = b"hhu\0";
pub const PRIuFAST16: &[u8; 2] = b"u\0";
pub const PRIuFAST32: &[u8; 2] = b"u\0";
pub const PRIuFAST64: &[u8; 4] = b"llu\0";
pub const PRIuMAX: &[u8; 4] = b"llu\0";
pub const PRIuPTR: &[u8; 4] = b"llu\0";
pub const PRIx8: &[u8; 4] = b"hhx\0";
pub const PRIx16: &[u8; 3] = b"hx\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 4] = b"llx\0";
pub const PRIxLEAST8: &[u8; 4] = b"hhx\0";
pub const PRIxLEAST16: &[u8; 3] = b"hx\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 4] = b"llx\0";
pub const PRIxFAST8: &[u8; 4] = b"hhx\0";
pub const PRIxFAST16: &[u8; 2] = b"x\0";
pub const PRIxFAST32: &[u8; 2] = b"x\0";
pub const PRIxFAST64: &[u8; 4] = b"llx\0";
pub const PRIxMAX: &[u8; 4] = b"llx\0";
pub const PRIxPTR: &[u8; 4] = b"llx\0";
pub const PRIX8: &[u8; 4] = b"hhX\0";
pub const PRIX16: &[u8; 3] = b"hX\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 4] = b"llX\0";
pub const PRIXLEAST8: &[u8; 4] = b"hhX\0";
pub const PRIXLEAST16: &[u8; 3] = b"hX\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 4] = b"llX\0";
pub const PRIXFAST8: &[u8; 4] = b"hhX\0";
pub const PRIXFAST16: &[u8; 2] = b"X\0";
pub const PRIXFAST32: &[u8; 2] = b"X\0";
pub const PRIXFAST64: &[u8; 4] = b"llX\0";
pub const PRIXMAX: &[u8; 4] = b"llX\0";
pub const PRIXPTR: &[u8; 4] = b"llX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 4] = b"lld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 4] = b"lld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 2] = b"d\0";
pub const SCNdFAST32: &[u8; 2] = b"d\0";
pub const SCNdFAST64: &[u8; 4] = b"lld\0";
pub const SCNdMAX: &[u8; 4] = b"lld\0";
pub const SCNdPTR: &[u8; 4] = b"lld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 4] = b"lli\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 4] = b"lli\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 2] = b"i\0";
pub const SCNiFAST32: &[u8; 2] = b"i\0";
pub const SCNiFAST64: &[u8; 4] = b"lli\0";
pub const SCNiMAX: &[u8; 4] = b"lli\0";
pub const SCNiPTR: &[u8; 4] = b"lli\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 4] = b"llo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 4] = b"llo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 2] = b"o\0";
pub const SCNoFAST32: &[u8; 2] = b"o\0";
pub const SCNoFAST64: &[u8; 4] = b"llo\0";
pub const SCNoMAX: &[u8; 4] = b"llo\0";
pub const SCNoPTR: &[u8; 4] = b"llo\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 4] = b"llu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 4] = b"llu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 2] = b"u\0";
pub const SCNuFAST32: &[u8; 2] = b"u\0";
pub const SCNuFAST64: &[u8; 4] = b"llu\0";
pub const SCNuMAX: &[u8; 4] = b"llu\0";
pub const SCNuPTR: &[u8; 4] = b"llu\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 4] = b"llx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 4] = b"llx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 2] = b"x\0";
pub const SCNxFAST32: &[u8; 2] = b"x\0";
pub const SCNxFAST64: &[u8; 4] = b"llx\0";
pub const SCNxMAX: &[u8; 4] = b"llx\0";
pub const SCNxPTR: &[u8; 4] = b"llx\0";
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const EDEADLK: u32 = 36;
pub const ENAMETOOLONG: u32 = 38;
pub const ENOLCK: u32 = 39;
pub const ENOSYS: u32 = 40;
pub const ENOTEMPTY: u32 = 41;
pub const EINVAL: u32 = 22;
pub const ERANGE: u32 = 34;
pub const EILSEQ: u32 = 42;
pub const STRUNCATE: u32 = 80;
pub const EDEADLOCK: u32 = 36;
pub const EADDRINUSE: u32 = 100;
pub const EADDRNOTAVAIL: u32 = 101;
pub const EAFNOSUPPORT: u32 = 102;
pub const EALREADY: u32 = 103;
pub const EBADMSG: u32 = 104;
pub const ECANCELED: u32 = 105;
pub const ECONNABORTED: u32 = 106;
pub const ECONNREFUSED: u32 = 107;
pub const ECONNRESET: u32 = 108;
pub const EDESTADDRREQ: u32 = 109;
pub const EHOSTUNREACH: u32 = 110;
pub const EIDRM: u32 = 111;
pub const EINPROGRESS: u32 = 112;
pub const EISCONN: u32 = 113;
pub const ELOOP: u32 = 114;
pub const EMSGSIZE: u32 = 115;
pub const ENETDOWN: u32 = 116;
pub const ENETRESET: u32 = 117;
pub const ENETUNREACH: u32 = 118;
pub const ENOBUFS: u32 = 119;
pub const ENODATA: u32 = 120;
pub const ENOLINK: u32 = 121;
pub const ENOMSG: u32 = 122;
pub const ENOPROTOOPT: u32 = 123;
pub const ENOSR: u32 = 124;
pub const ENOSTR: u32 = 125;
pub const ENOTCONN: u32 = 126;
pub const ENOTRECOVERABLE: u32 = 127;
pub const ENOTSOCK: u32 = 128;
pub const ENOTSUP: u32 = 129;
pub const EOPNOTSUPP: u32 = 130;
pub const EOTHER: u32 = 131;
pub const EOVERFLOW: u32 = 132;
pub const EOWNERDEAD: u32 = 133;
pub const EPROTO: u32 = 134;
pub const EPROTONOSUPPORT: u32 = 135;
pub const EPROTOTYPE: u32 = 136;
pub const ETIME: u32 = 137;
pub const ETIMEDOUT: u32 = 138;
pub const ETXTBSY: u32 = 139;
pub const EWOULDBLOCK: u32 = 140;
pub const _NLSCMPERROR: u32 = 2147483647;
pub const G_ANALYZER_ANALYZING: u32 = 0;
pub const FALSE: u32 = 0;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const MB_LEN_MAX: u32 = 5;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MIN: i32 = -2147483648;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const FLT_EVAL_METHOD: u32 = 0;
pub const DBL_DECIMAL_DIG: u32 = 17;
pub const DBL_DIG: u32 = 15;
pub const DBL_HAS_SUBNORM: u32 = 1;
pub const DBL_MANT_DIG: u32 = 53;
pub const DBL_MAX_10_EXP: u32 = 308;
pub const DBL_MAX_EXP: u32 = 1024;
pub const DBL_MIN_10_EXP: i32 = -307;
pub const DBL_MIN_EXP: i32 = -1021;
pub const _DBL_RADIX: u32 = 2;
pub const FLT_DECIMAL_DIG: u32 = 9;
pub const FLT_DIG: u32 = 6;
pub const FLT_HAS_SUBNORM: u32 = 1;
pub const FLT_GUARD: u32 = 0;
pub const FLT_MANT_DIG: u32 = 24;
pub const FLT_MAX_10_EXP: u32 = 38;
pub const FLT_MAX_EXP: u32 = 128;
pub const FLT_MIN_10_EXP: i32 = -37;
pub const FLT_MIN_EXP: i32 = -125;
pub const FLT_NORMALIZE: u32 = 0;
pub const FLT_RADIX: u32 = 2;
pub const LDBL_DIG: u32 = 15;
pub const LDBL_HAS_SUBNORM: u32 = 1;
pub const LDBL_MANT_DIG: u32 = 53;
pub const LDBL_MAX_10_EXP: u32 = 308;
pub const LDBL_MAX_EXP: u32 = 1024;
pub const LDBL_MIN_10_EXP: i32 = -307;
pub const LDBL_MIN_EXP: i32 = -1021;
pub const _LDBL_RADIX: u32 = 2;
pub const DECIMAL_DIG: u32 = 17;
pub const _SW_INEXACT: u32 = 1;
pub const _SW_UNDERFLOW: u32 = 2;
pub const _SW_OVERFLOW: u32 = 4;
pub const _SW_ZERODIVIDE: u32 = 8;
pub const _SW_INVALID: u32 = 16;
pub const _SW_DENORMAL: u32 = 524288;
pub const _EM_AMBIGUIOUS: u32 = 2147483648;
pub const _EM_AMBIGUOUS: u32 = 2147483648;
pub const _MCW_EM: u32 = 524319;
pub const _EM_INEXACT: u32 = 1;
pub const _EM_UNDERFLOW: u32 = 2;
pub const _EM_OVERFLOW: u32 = 4;
pub const _EM_ZERODIVIDE: u32 = 8;
pub const _EM_INVALID: u32 = 16;
pub const _EM_DENORMAL: u32 = 524288;
pub const _MCW_RC: u32 = 768;
pub const _RC_NEAR: u32 = 0;
pub const _RC_DOWN: u32 = 256;
pub const _RC_UP: u32 = 512;
pub const _RC_CHOP: u32 = 768;
pub const _MCW_PC: u32 = 196608;
pub const _PC_64: u32 = 0;
pub const _PC_53: u32 = 65536;
pub const _PC_24: u32 = 131072;
pub const _MCW_IC: u32 = 262144;
pub const _IC_AFFINE: u32 = 262144;
pub const _IC_PROJECTIVE: u32 = 0;
pub const _MCW_DN: u32 = 50331648;
pub const _DN_SAVE: u32 = 0;
pub const _DN_FLUSH: u32 = 16777216;
pub const _DN_FLUSH_OPERANDS_SAVE_RESULTS: u32 = 33554432;
pub const _DN_SAVE_OPERANDS_FLUSH_RESULTS: u32 = 50331648;
pub const _SW_UNEMULATED: u32 = 64;
pub const _SW_SQRTNEG: u32 = 128;
pub const _SW_STACKOVERFLOW: u32 = 512;
pub const _SW_STACKUNDERFLOW: u32 = 1024;
pub const _FPE_INVALID: u32 = 129;
pub const _FPE_DENORMAL: u32 = 130;
pub const _FPE_ZERODIVIDE: u32 = 131;
pub const _FPE_OVERFLOW: u32 = 132;
pub const _FPE_UNDERFLOW: u32 = 133;
pub const _FPE_INEXACT: u32 = 134;
pub const _FPE_UNEMULATED: u32 = 135;
pub const _FPE_SQRTNEG: u32 = 136;
pub const _FPE_STACKOVERFLOW: u32 = 138;
pub const _FPE_STACKUNDERFLOW: u32 = 139;
pub const _FPE_EXPLICITGEN: u32 = 140;
pub const _FPE_MULTIPLE_TRAPS: u32 = 141;
pub const _FPE_MULTIPLE_FAULTS: u32 = 142;
pub const _FPCLASS_SNAN: u32 = 1;
pub const _FPCLASS_QNAN: u32 = 2;
pub const _FPCLASS_NINF: u32 = 4;
pub const _FPCLASS_NN: u32 = 8;
pub const _FPCLASS_ND: u32 = 16;
pub const _FPCLASS_NZ: u32 = 32;
pub const _FPCLASS_PZ: u32 = 64;
pub const _FPCLASS_PD: u32 = 128;
pub const _FPCLASS_PN: u32 = 256;
pub const _FPCLASS_PINF: u32 = 512;
pub const _CW_DEFAULT: u32 = 524319;
pub const DBL_RADIX: u32 = 2;
pub const LDBL_RADIX: u32 = 2;
pub const EM_AMBIGUIOUS: u32 = 2147483648;
pub const EM_AMBIGUOUS: u32 = 2147483648;
pub const MCW_EM: u32 = 524319;
pub const EM_INVALID: u32 = 16;
pub const EM_DENORMAL: u32 = 524288;
pub const EM_ZERODIVIDE: u32 = 8;
pub const EM_OVERFLOW: u32 = 4;
pub const EM_UNDERFLOW: u32 = 2;
pub const EM_INEXACT: u32 = 1;
pub const MCW_IC: u32 = 262144;
pub const IC_AFFINE: u32 = 262144;
pub const IC_PROJECTIVE: u32 = 0;
pub const MCW_RC: u32 = 768;
pub const RC_CHOP: u32 = 768;
pub const RC_UP: u32 = 512;
pub const RC_DOWN: u32 = 256;
pub const RC_NEAR: u32 = 0;
pub const MCW_PC: u32 = 196608;
pub const PC_24: u32 = 131072;
pub const PC_53: u32 = 65536;
pub const PC_64: u32 = 0;
pub const CW_DEFAULT: u32 = 524319;
pub const SW_INVALID: u32 = 16;
pub const SW_DENORMAL: u32 = 524288;
pub const SW_ZERODIVIDE: u32 = 8;
pub const SW_OVERFLOW: u32 = 4;
pub const SW_UNDERFLOW: u32 = 2;
pub const SW_INEXACT: u32 = 1;
pub const SW_UNEMULATED: u32 = 64;
pub const SW_SQRTNEG: u32 = 128;
pub const SW_STACKOVERFLOW: u32 = 512;
pub const SW_STACKUNDERFLOW: u32 = 1024;
pub const FPE_INVALID: u32 = 129;
pub const FPE_DENORMAL: u32 = 130;
pub const FPE_ZERODIVIDE: u32 = 131;
pub const FPE_OVERFLOW: u32 = 132;
pub const FPE_UNDERFLOW: u32 = 133;
pub const FPE_INEXACT: u32 = 134;
pub const FPE_UNEMULATED: u32 = 135;
pub const FPE_SQRTNEG: u32 = 136;
pub const FPE_STACKOVERFLOW: u32 = 138;
pub const FPE_STACKUNDERFLOW: u32 = 139;
pub const FPE_EXPLICITGEN: u32 = 140;
pub const G_MINSHORT: i32 = -32768;
pub const G_MAXSHORT: u32 = 32767;
pub const G_MAXUSHORT: u32 = 65535;
pub const G_MININT: i32 = -2147483648;
pub const G_MAXINT: u32 = 2147483647;
pub const G_MAXUINT: u32 = 4294967295;
pub const G_MINLONG: i32 = -2147483648;
pub const G_MAXLONG: u32 = 2147483647;
pub const G_MAXULONG: u32 = 4294967295;
pub const G_GINT16_MODIFIER: &[u8; 2] = b"h\0";
pub const G_GINT16_FORMAT: &[u8; 3] = b"hi\0";
pub const G_GUINT16_FORMAT: &[u8; 3] = b"hu\0";
pub const G_GINT32_MODIFIER: &[u8; 1] = b"\0";
pub const G_GINT32_FORMAT: &[u8; 2] = b"i\0";
pub const G_GUINT32_FORMAT: &[u8; 2] = b"u\0";
pub const G_HAVE_GINT64: u32 = 1;
pub const G_GINT64_MODIFIER: &[u8; 3] = b"ll\0";
pub const G_GINT64_FORMAT: &[u8; 4] = b"lli\0";
pub const G_GUINT64_FORMAT: &[u8; 4] = b"llu\0";
pub const GLIB_SIZEOF_VOID_P: u32 = 8;
pub const GLIB_SIZEOF_LONG: u32 = 4;
pub const GLIB_SIZEOF_SIZE_T: u32 = 8;
pub const GLIB_SIZEOF_SSIZE_T: u32 = 8;
pub const G_GSIZE_MODIFIER: &[u8; 3] = b"ll\0";
pub const G_GSSIZE_MODIFIER: &[u8; 3] = b"ll\0";
pub const G_GSIZE_FORMAT: &[u8; 4] = b"llu\0";
pub const G_GSSIZE_FORMAT: &[u8; 4] = b"lli\0";
pub const G_GOFFSET_MODIFIER: &[u8; 3] = b"ll\0";
pub const G_GOFFSET_FORMAT: &[u8; 4] = b"lli\0";
pub const G_POLLFD_FORMAT: &[u8; 6] = b"%#llx\0";
pub const G_GINTPTR_MODIFIER: &[u8; 3] = b"ll\0";
pub const G_GINTPTR_FORMAT: &[u8; 4] = b"lli\0";
pub const G_GUINTPTR_FORMAT: &[u8; 4] = b"llu\0";
pub const GLIB_MAJOR_VERSION: u32 = 2;
pub const GLIB_MINOR_VERSION: u32 = 78;
pub const GLIB_MICRO_VERSION: u32 = 0;
pub const G_HAVE_ISO_VARARGS: u32 = 1;
pub const G_HAVE_GROWING_STACK: u32 = 0;
pub const G_PID_FORMAT: &[u8; 2] = b"p\0";
pub const GLIB_SYSDEF_AF_UNIX: u32 = 1;
pub const GLIB_SYSDEF_AF_INET: u32 = 2;
pub const GLIB_SYSDEF_AF_INET6: u32 = 23;
pub const GLIB_SYSDEF_MSG_OOB: u32 = 1;
pub const GLIB_SYSDEF_MSG_PEEK: u32 = 2;
pub const GLIB_SYSDEF_MSG_DONTROUTE: u32 = 4;
pub const G_DIR_SEPARATOR: u8 = 92u8;
pub const G_DIR_SEPARATOR_S: &[u8; 2] = b"\\\0";
pub const G_SEARCHPATH_SEPARATOR: u8 = 59u8;
pub const G_SEARCHPATH_SEPARATOR_S: &[u8; 2] = b";\0";
pub const _CRT_USE_CONFORMING_ANNEX_K_TIME: u32 = 0;
pub const TIME_UTC: u32 = 1;
pub const G_E: f64 = 2.718281828459045;
pub const G_LN2: f64 = 0.6931471805599453;
pub const G_LN10: f64 = 2.302585092994046;
pub const G_PI: f64 = 3.141592653589793;
pub const G_PI_2: f64 = 1.5707963267948966;
pub const G_PI_4: f64 = 0.7853981633974483;
pub const G_SQRT2: f64 = 1.4142135623730951;
pub const G_LITTLE_ENDIAN: u32 = 1234;
pub const G_BIG_ENDIAN: u32 = 4321;
pub const G_PDP_ENDIAN: u32 = 3412;
pub const G_IEEE754_FLOAT_BIAS: u32 = 127;
pub const G_IEEE754_DOUBLE_BIAS: u32 = 1023;
pub const G_LOG_2_BASE_10: f64 = 0.3010299956639812;
pub const _HEAP_MAXREQ: i32 = -32;
pub const _HEAPEMPTY: i32 = -1;
pub const _HEAPOK: i32 = -2;
pub const _HEAPBADBEGIN: i32 = -3;
pub const _HEAPBADNODE: i32 = -4;
pub const _HEAPEND: i32 = -5;
pub const _HEAPBADPTR: i32 = -6;
pub const _FREEENTRY: u32 = 0;
pub const _USEDENTRY: u32 = 1;
pub const _ALLOCA_S_THRESHOLD: u32 = 1024;
pub const _ALLOCA_S_STACK_MARKER: u32 = 52428;
pub const _ALLOCA_S_HEAP_MARKER: u32 = 56797;
pub const _ALLOCA_S_MARKER_SIZE: u32 = 16;
pub const NSIG: u32 = 23;
pub const SIGINT: u32 = 2;
pub const SIGILL: u32 = 4;
pub const SIGFPE: u32 = 8;
pub const SIGSEGV: u32 = 11;
pub const SIGTERM: u32 = 15;
pub const SIGBREAK: u32 = 21;
pub const SIGABRT: u32 = 22;
pub const SIGABRT_COMPAT: u32 = 6;
pub const G_DATALIST_FLAGS_MASK: u32 = 3;
pub const G_DATE_BAD_JULIAN: u32 = 0;
pub const G_DATE_BAD_DAY: u32 = 0;
pub const G_DATE_BAD_YEAR: u32 = 0;
pub const G_MEM_ALIGN: u32 = 8;
pub const G_HOOK_FLAG_USER_SHIFT: u32 = 4;
pub const G_PRIORITY_HIGH: i32 = -100;
pub const G_PRIORITY_DEFAULT: u32 = 0;
pub const G_PRIORITY_HIGH_IDLE: u32 = 100;
pub const G_PRIORITY_DEFAULT_IDLE: u32 = 200;
pub const G_PRIORITY_LOW: u32 = 300;
pub const G_SOURCE_REMOVE: u32 = 0;
pub const G_UNICHAR_MAX_DECOMPOSITION_LENGTH: u32 = 18;
pub const G_STR_DELIMITERS: &[u8; 8] = b"_-|> <.\0";
pub const G_ASCII_DTOSTR_BUF_SIZE: u32 = 39;
pub const G_WIN32_MSG_HANDLE: u32 = 19981206;
pub const G_KEY_FILE_DESKTOP_GROUP: &[u8; 14] = b"Desktop Entry\0";
pub const G_KEY_FILE_DESKTOP_KEY_TYPE: &[u8; 5] = b"Type\0";
pub const G_KEY_FILE_DESKTOP_KEY_VERSION: &[u8; 8] = b"Version\0";
pub const G_KEY_FILE_DESKTOP_KEY_NAME: &[u8; 5] = b"Name\0";
pub const G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME: &[u8; 12] = b"GenericName\0";
pub const G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY: &[u8; 10] = b"NoDisplay\0";
pub const G_KEY_FILE_DESKTOP_KEY_COMMENT: &[u8; 8] = b"Comment\0";
pub const G_KEY_FILE_DESKTOP_KEY_ICON: &[u8; 5] = b"Icon\0";
pub const G_KEY_FILE_DESKTOP_KEY_HIDDEN: &[u8; 7] = b"Hidden\0";
pub const G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN: &[u8; 11] = b"OnlyShowIn\0";
pub const G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN: &[u8; 10] = b"NotShowIn\0";
pub const G_KEY_FILE_DESKTOP_KEY_TRY_EXEC: &[u8; 8] = b"TryExec\0";
pub const G_KEY_FILE_DESKTOP_KEY_EXEC: &[u8; 5] = b"Exec\0";
pub const G_KEY_FILE_DESKTOP_KEY_PATH: &[u8; 5] = b"Path\0";
pub const G_KEY_FILE_DESKTOP_KEY_TERMINAL: &[u8; 9] = b"Terminal\0";
pub const G_KEY_FILE_DESKTOP_KEY_MIME_TYPE: &[u8; 9] = b"MimeType\0";
pub const G_KEY_FILE_DESKTOP_KEY_CATEGORIES: &[u8; 11] = b"Categories\0";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY: &[u8; 14] = b"StartupNotify\0";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS: &[u8; 15] = b"StartupWMClass\0";
pub const G_KEY_FILE_DESKTOP_KEY_URL: &[u8; 4] = b"URL\0";
pub const G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE: &[u8; 16] = b"DBusActivatable\0";
pub const G_KEY_FILE_DESKTOP_KEY_ACTIONS: &[u8; 8] = b"Actions\0";
pub const G_KEY_FILE_DESKTOP_TYPE_APPLICATION: &[u8; 12] = b"Application\0";
pub const G_KEY_FILE_DESKTOP_TYPE_LINK: &[u8; 5] = b"Link\0";
pub const G_KEY_FILE_DESKTOP_TYPE_DIRECTORY: &[u8; 10] = b"Directory\0";
pub const G_LOG_LEVEL_USER_SHIFT: u32 = 8;
pub const G_OPTION_REMAINING: &[u8; 1] = b"\0";
pub const G_CSET_A_2_Z: &[u8; 27] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ\0";
pub const G_CSET_a_2_z: &[u8; 27] = b"abcdefghijklmnopqrstuvwxyz\0";
pub const G_CSET_DIGITS: &[u8; 11] = b"0123456789\0";
pub const G_CSET_LATINC : & [u8 ; 31] = b"\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD8\xD9\xDA\xDB\xDC\xDD\xDE\0" ;
pub const G_CSET_LATINS : & [u8 ; 33] = b"\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF\0" ;
pub const _MAX_ITOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ITOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_LTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_LTOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_ULTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ULTOSTR_BASE10_COUNT: u32 = 11;
pub const _MAX_ULTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ULTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_I64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_I64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_I64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_I64TOSTR_BASE2_COUNT: u32 = 65;
pub const _MAX_U64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_U64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_U64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_U64TOSTR_BASE2_COUNT: u32 = 65;
pub const EXIT_SUCCESS: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const _WRITE_ABORT_MSG: u32 = 1;
pub const _CALL_REPORTFAULT: u32 = 2;
pub const _OUT_TO_DEFAULT: u32 = 0;
pub const _OUT_TO_STDERR: u32 = 1;
pub const _OUT_TO_MSGBOX: u32 = 2;
pub const _REPORT_ERRMODE: u32 = 3;
pub const RAND_MAX: u32 = 32767;
pub const _CVTBUFSIZE: u32 = 349;
pub const _MAX_PATH: u32 = 260;
pub const _MAX_DRIVE: u32 = 3;
pub const _MAX_DIR: u32 = 256;
pub const _MAX_FNAME: u32 = 256;
pub const _MAX_EXT: u32 = 256;
pub const _MAX_ENV: u32 = 32767;
pub const G_TEST_OPTION_ISOLATE_DIRS: &[u8; 13] = b"isolate_dirs\0";
pub const G_USEC_PER_SEC: u32 = 1000000;
pub const G_URI_RESERVED_CHARS_GENERIC_DELIMITERS: &[u8; 8] = b":/?#[]@\0";
pub const G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS: &[u8; 12] = b"!$&'()*+,;=\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH_ELEMENT: &[u8; 14] = b"!$&'()*+,;=:@\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH: &[u8; 15] = b"!$&'()*+,;=:@/\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_USERINFO: &[u8; 13] = b"!$&'()*+,;=:\0";
pub const MAXPATHLEN: u32 = 1024;
pub const G_ALLOC_ONLY: u32 = 1;
pub const G_ALLOC_AND_FREE: u32 = 2;
pub const G_ALLOCATOR_LIST: u32 = 1;
pub const G_ALLOCATOR_SLIST: u32 = 2;
pub const G_ALLOCATOR_NODE: u32 = 3;
pub const WIRESHARK_VERSION_MAJOR: u32 = 4;
pub const WIRESHARK_VERSION_MINOR: u32 = 2;
pub const WIRESHARK_VERSION_MICRO: u32 = 3;
pub const _CRT_INTERNAL_STDIO_SYMBOL_PREFIX: &[u8; 1] = b"\0";
pub const _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION: u32 = 1;
pub const _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR: u32 = 2;
pub const _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS: u32 = 4;
pub const _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 8;
pub const _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS: u32 = 16;
pub const _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING: u32 = 32;
pub const _CRT_INTERNAL_SCANF_SECURECRT: u32 = 1;
pub const _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS: u32 = 2;
pub const _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 4;
pub const BUFSIZ: u32 = 512;
pub const _NSTREAM_: u32 = 512;
pub const _IOB_ENTRIES: u32 = 3;
pub const EOF: i32 = -1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 64;
pub const _IONBF: u32 = 4;
pub const L_tmpnam: u32 = 260;
pub const L_tmpnam_s: u32 = 260;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_SET: u32 = 0;
pub const FILENAME_MAX: u32 = 260;
pub const FOPEN_MAX: u32 = 20;
pub const _SYS_OPEN: u32 = 20;
pub const TMP_MAX: u32 = 2147483647;
pub const TMP_MAX_S: u32 = 2147483647;
pub const _TMP_MAX_S: u32 = 2147483647;
pub const SYS_OPEN: u32 = 20;
pub const LOG_DOMAIN_MAIN: &[u8; 5] = b"Main\0";
pub const LOG_DOMAIN_CAPTURE: &[u8; 8] = b"Capture\0";
pub const LOG_DOMAIN_CAPCHILD: &[u8; 9] = b"Capchild\0";
pub const LOG_DOMAIN_WIRETAP: &[u8; 8] = b"Wiretap\0";
pub const LOG_DOMAIN_EPAN: &[u8; 5] = b"Epan\0";
pub const LOG_DOMAIN_DFILTER: &[u8; 8] = b"DFilter\0";
pub const LOG_DOMAIN_WSUTIL: &[u8; 7] = b"WSUtil\0";
pub const LOG_DOMAIN_QTUI: &[u8; 4] = b"GUI\0";
pub const LOG_DOMAIN_UAT: &[u8; 4] = b"UAT\0";
pub const LOG_DOMAIN_EXTCAP: &[u8; 7] = b"Extcap\0";
pub const LOG_DOMAIN_UTF_8: &[u8; 6] = b"UTF-8\0";
pub const LOG_DOMAIN_MMDB: &[u8; 10] = b"MaxMindDB\0";
pub const LOG_DOMAIN_EINVAL: &[u8; 11] = b"InvalidArg\0";
pub const LOG_DOMAIN_PLUGINS: &[u8; 8] = b"Plugins\0";
pub const LOG_DOMAIN_WSLUA: &[u8; 4] = b"Lua\0";
pub const _LOG_DOMAIN: &[u8; 1] = b"\0";
pub const _LOG_DEBUG_ENABLED: u32 = 0;
pub const LOG_HKCU_CONSOLE_OPEN: &[u8; 12] = b"ConsoleOpen\0";
pub const LOG_ARGS_NOEXIT: i32 = -1;
pub const UNICODE_REPLACEMENT_CHARACTER: u32 = 65533;
pub const WMEM_TREE_STRING_NOCASE: u32 = 1;
pub const WS_ASSERT_ENABLED: u32 = 1;
pub const NSTIME_UNIX_BUFSIZE: u32 = 31;
pub const WS_TSPREC_MAX: u32 = 9;
pub const NUM_WS_TSPREC_VALS: u32 = 10;
pub const IPv6_ADDR_SIZE: u32 = 16;
pub const IPv6_HDR_SIZE: u32 = 40;
pub const IPv6_FRAGMENT_HDR_SIZE: u32 = 8;
pub const IP6F_OFF_MASK: u32 = 65528;
pub const IP6F_RESERVED_MASK: u32 = 6;
pub const IP6F_MORE_FRAG: u32 = 1;
pub const WS_INET_ADDRSTRLEN: u32 = 16;
pub const WS_INET6_ADDRSTRLEN: u32 = 46;
pub const OPT_EOFOPT: u32 = 0;
pub const OPT_COMMENT: u32 = 1;
pub const OPT_CUSTOM_STR_COPY: u32 = 2988;
pub const OPT_CUSTOM_BIN_COPY: u32 = 2989;
pub const OPT_CUSTOM_STR_NO_COPY: u32 = 19372;
pub const OPT_CUSTOM_BIN_NO_COPY: u32 = 19373;
pub const OPT_SHB_HARDWARE: u32 = 2;
pub const OPT_SHB_OS: u32 = 3;
pub const OPT_SHB_USERAPPL: u32 = 4;
pub const OPT_IDB_NAME: u32 = 2;
pub const OPT_IDB_DESCRIPTION: u32 = 3;
pub const OPT_IDB_IP4ADDR: u32 = 4;
pub const OPT_IDB_IP6ADDR: u32 = 5;
pub const OPT_IDB_MACADDR: u32 = 6;
pub const OPT_IDB_EUIADDR: u32 = 7;
pub const OPT_IDB_SPEED: u32 = 8;
pub const OPT_IDB_TSRESOL: u32 = 9;
pub const OPT_IDB_TZONE: u32 = 10;
pub const OPT_IDB_FILTER: u32 = 11;
pub const OPT_IDB_OS: u32 = 12;
pub const OPT_IDB_FCSLEN: u32 = 13;
pub const OPT_IDB_TSOFFSET: u32 = 14;
pub const OPT_IDB_HARDWARE: u32 = 15;
pub const OPT_PKT_FLAGS: u32 = 2;
pub const OPT_PKT_HASH: u32 = 3;
pub const OPT_PKT_DROPCOUNT: u32 = 4;
pub const OPT_PKT_PACKETID: u32 = 5;
pub const OPT_PKT_QUEUE: u32 = 6;
pub const OPT_PKT_VERDICT: u32 = 7;
pub const OPT_NS_DNSNAME: u32 = 2;
pub const OPT_NS_DNSIP4ADDR: u32 = 3;
pub const OPT_NS_DNSIP6ADDR: u32 = 4;
pub const OPT_ISB_STARTTIME: u32 = 2;
pub const OPT_ISB_ENDTIME: u32 = 3;
pub const OPT_ISB_IFRECV: u32 = 4;
pub const OPT_ISB_IFDROP: u32 = 5;
pub const OPT_ISB_FILTERACCEPT: u32 = 6;
pub const OPT_ISB_OSDROP: u32 = 7;
pub const OPT_ISB_USRDELIV: u32 = 8;
pub const PEN_NFLX: u32 = 10949;
pub const PEN_VCTR: u32 = 46254;
pub const NFLX_OPT_TYPE_VERSION: u32 = 1;
pub const NFLX_OPT_TYPE_TCPINFO: u32 = 2;
pub const NFLX_OPT_TYPE_DUMPINFO: u32 = 4;
pub const NFLX_OPT_TYPE_DUMPTIME: u32 = 5;
pub const NFLX_OPT_TYPE_STACKNAME: u32 = 6;
pub const NFLX_TLB_FLAG_RXBUF: u32 = 1;
pub const NFLX_TLB_FLAG_TXBUF: u32 = 2;
pub const NFLX_TLB_FLAG_HDR: u32 = 4;
pub const NFLX_TLB_FLAG_VERBOSE: u32 = 8;
pub const NFLX_TLB_FLAG_STACKINFO: u32 = 16;
pub const NFLX_TLB_TF_REQ_SCALE: u32 = 32;
pub const NFLX_TLB_TF_RCVD_SCALE: u32 = 64;
pub const NFLX_TLB_TCPS_ESTABLISHED: u32 = 4;
pub const WTAP_ENCAP_NONE: i32 = -2;
pub const WTAP_ENCAP_PER_PACKET: i32 = -1;
pub const WTAP_ENCAP_UNKNOWN: u32 = 0;
pub const WTAP_ENCAP_ETHERNET: u32 = 1;
pub const WTAP_ENCAP_TOKEN_RING: u32 = 2;
pub const WTAP_ENCAP_SLIP: u32 = 3;
pub const WTAP_ENCAP_PPP: u32 = 4;
pub const WTAP_ENCAP_FDDI: u32 = 5;
pub const WTAP_ENCAP_FDDI_BITSWAPPED: u32 = 6;
pub const WTAP_ENCAP_RAW_IP: u32 = 7;
pub const WTAP_ENCAP_ARCNET: u32 = 8;
pub const WTAP_ENCAP_ARCNET_LINUX: u32 = 9;
pub const WTAP_ENCAP_ATM_RFC1483: u32 = 10;
pub const WTAP_ENCAP_LINUX_ATM_CLIP: u32 = 11;
pub const WTAP_ENCAP_LAPB: u32 = 12;
pub const WTAP_ENCAP_ATM_PDUS: u32 = 13;
pub const WTAP_ENCAP_ATM_PDUS_UNTRUNCATED: u32 = 14;
pub const WTAP_ENCAP_NULL: u32 = 15;
pub const WTAP_ENCAP_ASCEND: u32 = 16;
pub const WTAP_ENCAP_ISDN: u32 = 17;
pub const WTAP_ENCAP_IP_OVER_FC: u32 = 18;
pub const WTAP_ENCAP_PPP_WITH_PHDR: u32 = 19;
pub const WTAP_ENCAP_IEEE_802_11: u32 = 20;
pub const WTAP_ENCAP_IEEE_802_11_PRISM: u32 = 21;
pub const WTAP_ENCAP_IEEE_802_11_WITH_RADIO: u32 = 22;
pub const WTAP_ENCAP_IEEE_802_11_RADIOTAP: u32 = 23;
pub const WTAP_ENCAP_IEEE_802_11_AVS: u32 = 24;
pub const WTAP_ENCAP_SLL: u32 = 25;
pub const WTAP_ENCAP_FRELAY: u32 = 26;
pub const WTAP_ENCAP_FRELAY_WITH_PHDR: u32 = 27;
pub const WTAP_ENCAP_CHDLC: u32 = 28;
pub const WTAP_ENCAP_CISCO_IOS: u32 = 29;
pub const WTAP_ENCAP_LOCALTALK: u32 = 30;
pub const WTAP_ENCAP_OLD_PFLOG: u32 = 31;
pub const WTAP_ENCAP_HHDLC: u32 = 32;
pub const WTAP_ENCAP_DOCSIS: u32 = 33;
pub const WTAP_ENCAP_COSINE: u32 = 34;
pub const WTAP_ENCAP_WFLEET_HDLC: u32 = 35;
pub const WTAP_ENCAP_SDLC: u32 = 36;
pub const WTAP_ENCAP_TZSP: u32 = 37;
pub const WTAP_ENCAP_ENC: u32 = 38;
pub const WTAP_ENCAP_PFLOG: u32 = 39;
pub const WTAP_ENCAP_CHDLC_WITH_PHDR: u32 = 40;
pub const WTAP_ENCAP_BLUETOOTH_H4: u32 = 41;
pub const WTAP_ENCAP_MTP2: u32 = 42;
pub const WTAP_ENCAP_MTP3: u32 = 43;
pub const WTAP_ENCAP_IRDA: u32 = 44;
pub const WTAP_ENCAP_USER0: u32 = 45;
pub const WTAP_ENCAP_USER1: u32 = 46;
pub const WTAP_ENCAP_USER2: u32 = 47;
pub const WTAP_ENCAP_USER3: u32 = 48;
pub const WTAP_ENCAP_USER4: u32 = 49;
pub const WTAP_ENCAP_USER5: u32 = 50;
pub const WTAP_ENCAP_USER6: u32 = 51;
pub const WTAP_ENCAP_USER7: u32 = 52;
pub const WTAP_ENCAP_USER8: u32 = 53;
pub const WTAP_ENCAP_USER9: u32 = 54;
pub const WTAP_ENCAP_USER10: u32 = 55;
pub const WTAP_ENCAP_USER11: u32 = 56;
pub const WTAP_ENCAP_USER12: u32 = 57;
pub const WTAP_ENCAP_USER13: u32 = 58;
pub const WTAP_ENCAP_USER14: u32 = 59;
pub const WTAP_ENCAP_USER15: u32 = 60;
pub const WTAP_ENCAP_SYMANTEC: u32 = 61;
pub const WTAP_ENCAP_APPLE_IP_OVER_IEEE1394: u32 = 62;
pub const WTAP_ENCAP_BACNET_MS_TP: u32 = 63;
pub const WTAP_ENCAP_NETTL_RAW_ICMP: u32 = 64;
pub const WTAP_ENCAP_NETTL_RAW_ICMPV6: u32 = 65;
pub const WTAP_ENCAP_GPRS_LLC: u32 = 66;
pub const WTAP_ENCAP_JUNIPER_ATM1: u32 = 67;
pub const WTAP_ENCAP_JUNIPER_ATM2: u32 = 68;
pub const WTAP_ENCAP_REDBACK: u32 = 69;
pub const WTAP_ENCAP_NETTL_RAW_IP: u32 = 70;
pub const WTAP_ENCAP_NETTL_ETHERNET: u32 = 71;
pub const WTAP_ENCAP_NETTL_TOKEN_RING: u32 = 72;
pub const WTAP_ENCAP_NETTL_FDDI: u32 = 73;
pub const WTAP_ENCAP_NETTL_UNKNOWN: u32 = 74;
pub const WTAP_ENCAP_MTP2_WITH_PHDR: u32 = 75;
pub const WTAP_ENCAP_JUNIPER_PPPOE: u32 = 76;
pub const WTAP_ENCAP_GCOM_TIE1: u32 = 77;
pub const WTAP_ENCAP_GCOM_SERIAL: u32 = 78;
pub const WTAP_ENCAP_NETTL_X25: u32 = 79;
pub const WTAP_ENCAP_K12: u32 = 80;
pub const WTAP_ENCAP_JUNIPER_MLPPP: u32 = 81;
pub const WTAP_ENCAP_JUNIPER_MLFR: u32 = 82;
pub const WTAP_ENCAP_JUNIPER_ETHER: u32 = 83;
pub const WTAP_ENCAP_JUNIPER_PPP: u32 = 84;
pub const WTAP_ENCAP_JUNIPER_FRELAY: u32 = 85;
pub const WTAP_ENCAP_JUNIPER_CHDLC: u32 = 86;
pub const WTAP_ENCAP_JUNIPER_GGSN: u32 = 87;
pub const WTAP_ENCAP_LINUX_LAPD: u32 = 88;
pub const WTAP_ENCAP_CATAPULT_DCT2000: u32 = 89;
pub const WTAP_ENCAP_BER: u32 = 90;
pub const WTAP_ENCAP_JUNIPER_VP: u32 = 91;
pub const WTAP_ENCAP_USB_FREEBSD: u32 = 92;
pub const WTAP_ENCAP_IEEE802_16_MAC_CPS: u32 = 93;
pub const WTAP_ENCAP_NETTL_RAW_TELNET: u32 = 94;
pub const WTAP_ENCAP_USB_LINUX: u32 = 95;
pub const WTAP_ENCAP_MPEG: u32 = 96;
pub const WTAP_ENCAP_PPI: u32 = 97;
pub const WTAP_ENCAP_ERF: u32 = 98;
pub const WTAP_ENCAP_BLUETOOTH_H4_WITH_PHDR: u32 = 99;
pub const WTAP_ENCAP_SITA: u32 = 100;
pub const WTAP_ENCAP_SCCP: u32 = 101;
pub const WTAP_ENCAP_BLUETOOTH_HCI: u32 = 102;
pub const WTAP_ENCAP_IPMB_KONTRON: u32 = 103;
pub const WTAP_ENCAP_IEEE802_15_4: u32 = 104;
pub const WTAP_ENCAP_X2E_XORAYA: u32 = 105;
pub const WTAP_ENCAP_FLEXRAY: u32 = 106;
pub const WTAP_ENCAP_LIN: u32 = 107;
pub const WTAP_ENCAP_MOST: u32 = 108;
pub const WTAP_ENCAP_CAN20B: u32 = 109;
pub const WTAP_ENCAP_LAYER1_EVENT: u32 = 110;
pub const WTAP_ENCAP_X2E_SERIAL: u32 = 111;
pub const WTAP_ENCAP_I2C_LINUX: u32 = 112;
pub const WTAP_ENCAP_IEEE802_15_4_NONASK_PHY: u32 = 113;
pub const WTAP_ENCAP_TNEF: u32 = 114;
pub const WTAP_ENCAP_USB_LINUX_MMAPPED: u32 = 115;
pub const WTAP_ENCAP_GSM_UM: u32 = 116;
pub const WTAP_ENCAP_DPNSS: u32 = 117;
pub const WTAP_ENCAP_PACKETLOGGER: u32 = 118;
pub const WTAP_ENCAP_NSTRACE_1_0: u32 = 119;
pub const WTAP_ENCAP_NSTRACE_2_0: u32 = 120;
pub const WTAP_ENCAP_FIBRE_CHANNEL_FC2: u32 = 121;
pub const WTAP_ENCAP_FIBRE_CHANNEL_FC2_WITH_FRAME_DELIMS: u32 = 122;
pub const WTAP_ENCAP_JPEG_JFIF: u32 = 123;
pub const WTAP_ENCAP_IPNET: u32 = 124;
pub const WTAP_ENCAP_SOCKETCAN: u32 = 125;
pub const WTAP_ENCAP_IEEE_802_11_NETMON: u32 = 126;
pub const WTAP_ENCAP_IEEE802_15_4_NOFCS: u32 = 127;
pub const WTAP_ENCAP_RAW_IPFIX: u32 = 128;
pub const WTAP_ENCAP_RAW_IP4: u32 = 129;
pub const WTAP_ENCAP_RAW_IP6: u32 = 130;
pub const WTAP_ENCAP_LAPD: u32 = 131;
pub const WTAP_ENCAP_DVBCI: u32 = 132;
pub const WTAP_ENCAP_MUX27010: u32 = 133;
pub const WTAP_ENCAP_MIME: u32 = 134;
pub const WTAP_ENCAP_NETANALYZER: u32 = 135;
pub const WTAP_ENCAP_NETANALYZER_TRANSPARENT: u32 = 136;
pub const WTAP_ENCAP_IP_OVER_IB_SNOOP: u32 = 137;
pub const WTAP_ENCAP_MPEG_2_TS: u32 = 138;
pub const WTAP_ENCAP_PPP_ETHER: u32 = 139;
pub const WTAP_ENCAP_NFC_LLCP: u32 = 140;
pub const WTAP_ENCAP_NFLOG: u32 = 141;
pub const WTAP_ENCAP_V5_EF: u32 = 142;
pub const WTAP_ENCAP_BACNET_MS_TP_WITH_PHDR: u32 = 143;
pub const WTAP_ENCAP_IXVERIWAVE: u32 = 144;
pub const WTAP_ENCAP_SDH: u32 = 145;
pub const WTAP_ENCAP_DBUS: u32 = 146;
pub const WTAP_ENCAP_AX25_KISS: u32 = 147;
pub const WTAP_ENCAP_AX25: u32 = 148;
pub const WTAP_ENCAP_SCTP: u32 = 149;
pub const WTAP_ENCAP_INFINIBAND: u32 = 150;
pub const WTAP_ENCAP_JUNIPER_SVCS: u32 = 151;
pub const WTAP_ENCAP_USBPCAP: u32 = 152;
pub const WTAP_ENCAP_RTAC_SERIAL: u32 = 153;
pub const WTAP_ENCAP_BLUETOOTH_LE_LL: u32 = 154;
pub const WTAP_ENCAP_WIRESHARK_UPPER_PDU: u32 = 155;
pub const WTAP_ENCAP_STANAG_4607: u32 = 156;
pub const WTAP_ENCAP_STANAG_5066_D_PDU: u32 = 157;
pub const WTAP_ENCAP_NETLINK: u32 = 158;
pub const WTAP_ENCAP_BLUETOOTH_LINUX_MONITOR: u32 = 159;
pub const WTAP_ENCAP_BLUETOOTH_BREDR_BB: u32 = 160;
pub const WTAP_ENCAP_BLUETOOTH_LE_LL_WITH_PHDR: u32 = 161;
pub const WTAP_ENCAP_NSTRACE_3_0: u32 = 162;
pub const WTAP_ENCAP_LOGCAT: u32 = 163;
pub const WTAP_ENCAP_LOGCAT_BRIEF: u32 = 164;
pub const WTAP_ENCAP_LOGCAT_PROCESS: u32 = 165;
pub const WTAP_ENCAP_LOGCAT_TAG: u32 = 166;
pub const WTAP_ENCAP_LOGCAT_THREAD: u32 = 167;
pub const WTAP_ENCAP_LOGCAT_TIME: u32 = 168;
pub const WTAP_ENCAP_LOGCAT_THREADTIME: u32 = 169;
pub const WTAP_ENCAP_LOGCAT_LONG: u32 = 170;
pub const WTAP_ENCAP_PKTAP: u32 = 171;
pub const WTAP_ENCAP_EPON: u32 = 172;
pub const WTAP_ENCAP_IPMI_TRACE: u32 = 173;
pub const WTAP_ENCAP_LOOP: u32 = 174;
pub const WTAP_ENCAP_JSON: u32 = 175;
pub const WTAP_ENCAP_NSTRACE_3_5: u32 = 176;
pub const WTAP_ENCAP_ISO14443: u32 = 177;
pub const WTAP_ENCAP_GFP_T: u32 = 178;
pub const WTAP_ENCAP_GFP_F: u32 = 179;
pub const WTAP_ENCAP_IP_OVER_IB_PCAP: u32 = 180;
pub const WTAP_ENCAP_JUNIPER_VN: u32 = 181;
pub const WTAP_ENCAP_USB_DARWIN: u32 = 182;
pub const WTAP_ENCAP_LORATAP: u32 = 183;
pub const WTAP_ENCAP_3MB_ETHERNET: u32 = 184;
pub const WTAP_ENCAP_VSOCK: u32 = 185;
pub const WTAP_ENCAP_NORDIC_BLE: u32 = 186;
pub const WTAP_ENCAP_NETMON_NET_NETEVENT: u32 = 187;
pub const WTAP_ENCAP_NETMON_HEADER: u32 = 188;
pub const WTAP_ENCAP_NETMON_NET_FILTER: u32 = 189;
pub const WTAP_ENCAP_NETMON_NETWORK_INFO_EX: u32 = 190;
pub const WTAP_ENCAP_MA_WFP_CAPTURE_V4: u32 = 191;
pub const WTAP_ENCAP_MA_WFP_CAPTURE_V6: u32 = 192;
pub const WTAP_ENCAP_MA_WFP_CAPTURE_2V4: u32 = 193;
pub const WTAP_ENCAP_MA_WFP_CAPTURE_2V6: u32 = 194;
pub const WTAP_ENCAP_MA_WFP_CAPTURE_AUTH_V4: u32 = 195;
pub const WTAP_ENCAP_MA_WFP_CAPTURE_AUTH_V6: u32 = 196;
pub const WTAP_ENCAP_JUNIPER_ST: u32 = 197;
pub const WTAP_ENCAP_ETHERNET_MPACKET: u32 = 198;
pub const WTAP_ENCAP_DOCSIS31_XRA31: u32 = 199;
pub const WTAP_ENCAP_DPAUXMON: u32 = 200;
pub const WTAP_ENCAP_RUBY_MARSHAL: u32 = 201;
pub const WTAP_ENCAP_RFC7468: u32 = 202;
pub const WTAP_ENCAP_SYSTEMD_JOURNAL: u32 = 203;
pub const WTAP_ENCAP_EBHSCR: u32 = 204;
pub const WTAP_ENCAP_VPP: u32 = 205;
pub const WTAP_ENCAP_IEEE802_15_4_TAP: u32 = 206;
pub const WTAP_ENCAP_LOG_3GPP: u32 = 207;
pub const WTAP_ENCAP_USB_2_0: u32 = 208;
pub const WTAP_ENCAP_MP4: u32 = 209;
pub const WTAP_ENCAP_SLL2: u32 = 210;
pub const WTAP_ENCAP_ZWAVE_SERIAL: u32 = 211;
pub const WTAP_ENCAP_ETW: u32 = 212;
pub const WTAP_ENCAP_ERI_ENB_LOG: u32 = 213;
pub const WTAP_ENCAP_ZBNCP: u32 = 214;
pub const WTAP_ENCAP_USB_2_0_LOW_SPEED: u32 = 215;
pub const WTAP_ENCAP_USB_2_0_FULL_SPEED: u32 = 216;
pub const WTAP_ENCAP_USB_2_0_HIGH_SPEED: u32 = 217;
pub const WTAP_ENCAP_AUTOSAR_DLT: u32 = 218;
pub const WTAP_ENCAP_AUERSWALD_LOG: u32 = 219;
pub const WTAP_ENCAP_ATSC_ALP: u32 = 220;
pub const WTAP_ENCAP_FIRA_UCI: u32 = 221;
pub const WTAP_ENCAP_SILABS_DEBUG_CHANNEL: u32 = 222;
pub const WTAP_ENCAP_MDB: u32 = 223;
pub const WTAP_FILE_TYPE_SUBTYPE_UNKNOWN: i32 = -1;
pub const WTAP_TSPREC_UNKNOWN: i32 = -2;
pub const WTAP_TSPREC_PER_PACKET: i32 = -1;
pub const WTAP_TSPREC_SEC: u32 = 0;
pub const WTAP_TSPREC_100_MSEC: u32 = 1;
pub const WTAP_TSPREC_DSEC: u32 = 1;
pub const WTAP_TSPREC_10_MSEC: u32 = 2;
pub const WTAP_TSPREC_CSEC: u32 = 2;
pub const WTAP_TSPREC_MSEC: u32 = 3;
pub const WTAP_TSPREC_100_USEC: u32 = 4;
pub const WTAP_TSPREC_10_USEC: u32 = 5;
pub const WTAP_TSPREC_USEC: u32 = 6;
pub const WTAP_TSPREC_100_NSEC: u32 = 7;
pub const WTAP_TSPREC_10_NSEC: u32 = 8;
pub const WTAP_TSPREC_NSEC: u32 = 9;
pub const WTAP_MAX_PACKET_SIZE_STANDARD: u32 = 262144;
pub const WTAP_MAX_PACKET_SIZE_USBPCAP: u32 = 134217728;
pub const WTAP_MAX_PACKET_SIZE_EBHSCR: u32 = 33554432;
pub const WTAP_MAX_PACKET_SIZE_DBUS: u32 = 134217728;
pub const FROM_DCE: u32 = 128;
pub const ATM_RAW_CELL: u32 = 1;
pub const ATM_NO_HEC: u32 = 2;
pub const ATM_AAL2_NOPHDR: u32 = 4;
pub const ATM_REASSEMBLY_ERROR: u32 = 8;
pub const AAL_UNKNOWN: u32 = 0;
pub const AAL_1: u32 = 1;
pub const AAL_2: u32 = 2;
pub const AAL_3_4: u32 = 3;
pub const AAL_5: u32 = 4;
pub const AAL_USER: u32 = 5;
pub const AAL_SIGNALLING: u32 = 6;
pub const AAL_OAMCELL: u32 = 7;
pub const TRAF_UNKNOWN: u32 = 0;
pub const TRAF_LLCMX: u32 = 1;
pub const TRAF_VCMX: u32 = 2;
pub const TRAF_LANE: u32 = 3;
pub const TRAF_ILMI: u32 = 4;
pub const TRAF_FR: u32 = 5;
pub const TRAF_SPANS: u32 = 6;
pub const TRAF_IPSILON: u32 = 7;
pub const TRAF_UMTS_FP: u32 = 8;
pub const TRAF_GPRS_NS: u32 = 9;
pub const TRAF_SSCOP: u32 = 10;
pub const TRAF_ST_UNKNOWN: u32 = 0;
pub const TRAF_ST_VCMX_802_3_FCS: u32 = 1;
pub const TRAF_ST_VCMX_802_4_FCS: u32 = 2;
pub const TRAF_ST_VCMX_802_5_FCS: u32 = 3;
pub const TRAF_ST_VCMX_FDDI_FCS: u32 = 4;
pub const TRAF_ST_VCMX_802_6_FCS: u32 = 5;
pub const TRAF_ST_VCMX_802_3: u32 = 7;
pub const TRAF_ST_VCMX_802_4: u32 = 8;
pub const TRAF_ST_VCMX_802_5: u32 = 9;
pub const TRAF_ST_VCMX_FDDI: u32 = 10;
pub const TRAF_ST_VCMX_802_6: u32 = 11;
pub const TRAF_ST_VCMX_FRAGMENTS: u32 = 12;
pub const TRAF_ST_VCMX_BPDU: u32 = 13;
pub const TRAF_ST_LANE_LE_CTRL: u32 = 1;
pub const TRAF_ST_LANE_802_3: u32 = 2;
pub const TRAF_ST_LANE_802_5: u32 = 3;
pub const TRAF_ST_LANE_802_3_MC: u32 = 4;
pub const TRAF_ST_LANE_802_5_MC: u32 = 5;
pub const TRAF_ST_IPSILON_FT0: u32 = 1;
pub const TRAF_ST_IPSILON_FT1: u32 = 2;
pub const TRAF_ST_IPSILON_FT2: u32 = 3;
pub const ASCEND_MAX_STR_LEN: u32 = 64;
pub const ASCEND_PFX_WDS_X: u32 = 1;
pub const ASCEND_PFX_WDS_R: u32 = 2;
pub const ASCEND_PFX_WDD: u32 = 3;
pub const ASCEND_PFX_ISDN_X: u32 = 4;
pub const ASCEND_PFX_ISDN_R: u32 = 5;
pub const ASCEND_PFX_ETHER: u32 = 6;
pub const PHDR_802_11_PHY_UNKNOWN: u32 = 0;
pub const PHDR_802_11_PHY_11_FHSS: u32 = 1;
pub const PHDR_802_11_PHY_11_IR: u32 = 2;
pub const PHDR_802_11_PHY_11_DSSS: u32 = 3;
pub const PHDR_802_11_PHY_11B: u32 = 4;
pub const PHDR_802_11_PHY_11A: u32 = 5;
pub const PHDR_802_11_PHY_11G: u32 = 6;
pub const PHDR_802_11_PHY_11N: u32 = 7;
pub const PHDR_802_11_PHY_11AC: u32 = 8;
pub const PHDR_802_11_PHY_11AD: u32 = 9;
pub const PHDR_802_11_PHY_11AH: u32 = 10;
pub const PHDR_802_11_PHY_11AX: u32 = 11;
pub const PHDR_802_11_PHY_11BE: u32 = 12;
pub const PHDR_802_11A_CHANNEL_TYPE_NORMAL: u32 = 0;
pub const PHDR_802_11A_CHANNEL_TYPE_HALF_CLOCKED: u32 = 1;
pub const PHDR_802_11A_CHANNEL_TYPE_QUARTER_CLOCKED: u32 = 2;
pub const PHDR_802_11A_TURBO_TYPE_NORMAL: u32 = 0;
pub const PHDR_802_11A_TURBO_TYPE_TURBO: u32 = 1;
pub const PHDR_802_11A_TURBO_TYPE_DYNAMIC_TURBO: u32 = 2;
pub const PHDR_802_11A_TURBO_TYPE_STATIC_TURBO: u32 = 3;
pub const PHDR_802_11G_MODE_NORMAL: u32 = 0;
pub const PHDR_802_11G_MODE_SUPER_G: u32 = 1;
pub const PHDR_802_11_BANDWIDTH_20_MHZ: u32 = 0;
pub const PHDR_802_11_BANDWIDTH_40_MHZ: u32 = 1;
pub const PHDR_802_11_BANDWIDTH_20_20L: u32 = 2;
pub const PHDR_802_11_BANDWIDTH_20_20U: u32 = 3;
pub const PHDR_802_11_BANDWIDTH_80_MHZ: u32 = 4;
pub const PHDR_802_11_BANDWIDTH_40_40L: u32 = 5;
pub const PHDR_802_11_BANDWIDTH_40_40U: u32 = 6;
pub const PHDR_802_11_BANDWIDTH_20LL: u32 = 7;
pub const PHDR_802_11_BANDWIDTH_20LU: u32 = 8;
pub const PHDR_802_11_BANDWIDTH_20UL: u32 = 9;
pub const PHDR_802_11_BANDWIDTH_20UU: u32 = 10;
pub const PHDR_802_11_BANDWIDTH_160_MHZ: u32 = 11;
pub const PHDR_802_11_BANDWIDTH_80_80L: u32 = 12;
pub const PHDR_802_11_BANDWIDTH_80_80U: u32 = 13;
pub const PHDR_802_11_BANDWIDTH_40LL: u32 = 14;
pub const PHDR_802_11_BANDWIDTH_40LU: u32 = 15;
pub const PHDR_802_11_BANDWIDTH_40UL: u32 = 16;
pub const PHDR_802_11_BANDWIDTH_40UU: u32 = 17;
pub const PHDR_802_11_BANDWIDTH_20LLL: u32 = 18;
pub const PHDR_802_11_BANDWIDTH_20LLU: u32 = 19;
pub const PHDR_802_11_BANDWIDTH_20LUL: u32 = 20;
pub const PHDR_802_11_BANDWIDTH_20LUU: u32 = 21;
pub const PHDR_802_11_BANDWIDTH_20ULL: u32 = 22;
pub const PHDR_802_11_BANDWIDTH_20ULU: u32 = 23;
pub const PHDR_802_11_BANDWIDTH_20UUL: u32 = 24;
pub const PHDR_802_11_BANDWIDTH_20UUU: u32 = 25;
pub const PHDR_802_11AD_MIN_FREQUENCY: u32 = 57000;
pub const PHDR_802_11AD_MAX_FREQUENCY: u32 = 71000;
pub const PHDR_802_11_LAST_PART_OF_A_MPDU: u32 = 1;
pub const PHDR_802_11_A_MPDU_DELIM_CRC_ERROR: u32 = 2;
pub const PHDR_802_11_SOUNDING_PSDU: u32 = 0;
pub const PHDR_802_11_DATA_NOT_CAPTURED: u32 = 1;
pub const PHDR_802_11_0_LENGTH_PSDU_S1G_NDP: u32 = 2;
pub const PHDR_802_11_0_LENGTH_PSDU_VENDOR_SPECIFIC: u32 = 255;
pub const COSINE_MAX_IF_NAME_LEN: u32 = 128;
pub const COSINE_ENCAP_TEST: u32 = 1;
pub const COSINE_ENCAP_PPoATM: u32 = 2;
pub const COSINE_ENCAP_PPoFR: u32 = 3;
pub const COSINE_ENCAP_ATM: u32 = 4;
pub const COSINE_ENCAP_FR: u32 = 5;
pub const COSINE_ENCAP_HDLC: u32 = 6;
pub const COSINE_ENCAP_PPP: u32 = 7;
pub const COSINE_ENCAP_ETH: u32 = 8;
pub const COSINE_ENCAP_UNKNOWN: u32 = 99;
pub const COSINE_DIR_TX: u32 = 1;
pub const COSINE_DIR_RX: u32 = 2;
pub const IRDA_INCOMING: u32 = 0;
pub const IRDA_OUTGOING: u32 = 4;
pub const IRDA_LOG_MESSAGE: u32 = 256;
pub const IRDA_MISSED_MSG: u32 = 257;
pub const IRDA_CLASS_FRAME: u32 = 0;
pub const IRDA_CLASS_LOG: u32 = 256;
pub const IRDA_CLASS_MASK: u32 = 65280;
pub const MTP2_ANNEX_A_NOT_USED: u32 = 0;
pub const MTP2_ANNEX_A_USED: u32 = 1;
pub const MTP2_ANNEX_A_USED_UNKNOWN: u32 = 2;
pub const K12_PORT_DS0S: u32 = 65544;
pub const K12_PORT_DS1: u32 = 1048584;
pub const K12_PORT_ATMPVC: u32 = 16908288;
pub const MAX_ERF_EHDR: u32 = 16;
pub const SITA_FRAME_DIR_TXED: u32 = 0;
pub const SITA_FRAME_DIR_RXED: u32 = 1;
pub const SITA_FRAME_DIR: u32 = 1;
pub const SITA_ERROR_NO_BUFFER: u32 = 128;
pub const SITA_SIG_DSR: u32 = 1;
pub const SITA_SIG_DTR: u32 = 2;
pub const SITA_SIG_CTS: u32 = 4;
pub const SITA_SIG_RTS: u32 = 8;
pub const SITA_SIG_DCD: u32 = 16;
pub const SITA_SIG_UNDEF1: u32 = 32;
pub const SITA_SIG_UNDEF2: u32 = 64;
pub const SITA_SIG_UNDEF3: u32 = 128;
pub const SITA_ERROR_TX_UNDERRUN: u32 = 1;
pub const SITA_ERROR_TX_CTS_LOST: u32 = 2;
pub const SITA_ERROR_TX_UART_ERROR: u32 = 4;
pub const SITA_ERROR_TX_RETX_LIMIT: u32 = 8;
pub const SITA_ERROR_TX_UNDEF1: u32 = 16;
pub const SITA_ERROR_TX_UNDEF2: u32 = 32;
pub const SITA_ERROR_TX_UNDEF3: u32 = 64;
pub const SITA_ERROR_TX_UNDEF4: u32 = 128;
pub const SITA_ERROR_RX_FRAMING: u32 = 1;
pub const SITA_ERROR_RX_PARITY: u32 = 2;
pub const SITA_ERROR_RX_COLLISION: u32 = 4;
pub const SITA_ERROR_RX_FRAME_LONG: u32 = 8;
pub const SITA_ERROR_RX_FRAME_SHORT: u32 = 16;
pub const SITA_ERROR_RX_UNDEF1: u32 = 32;
pub const SITA_ERROR_RX_UNDEF2: u32 = 64;
pub const SITA_ERROR_RX_UNDEF3: u32 = 128;
pub const SITA_ERROR_RX_NONOCTET_ALIGNED: u32 = 1;
pub const SITA_ERROR_RX_ABORT: u32 = 2;
pub const SITA_ERROR_RX_CD_LOST: u32 = 4;
pub const SITA_ERROR_RX_DPLL: u32 = 8;
pub const SITA_ERROR_RX_OVERRUN: u32 = 16;
pub const SITA_ERROR_RX_FRAME_LEN_VIOL: u32 = 32;
pub const SITA_ERROR_RX_CRC: u32 = 64;
pub const SITA_ERROR_RX_BREAK: u32 = 128;
pub const SITA_PROTO_UNUSED: u32 = 0;
pub const SITA_PROTO_BOP_LAPB: u32 = 1;
pub const SITA_PROTO_ETHERNET: u32 = 2;
pub const SITA_PROTO_ASYNC_INTIO: u32 = 3;
pub const SITA_PROTO_ASYNC_BLKIO: u32 = 4;
pub const SITA_PROTO_ALC: u32 = 5;
pub const SITA_PROTO_UTS: u32 = 6;
pub const SITA_PROTO_PPP_HDLC: u32 = 7;
pub const SITA_PROTO_SDLC: u32 = 8;
pub const SITA_PROTO_TOKENRING: u32 = 9;
pub const SITA_PROTO_I2C: u32 = 16;
pub const SITA_PROTO_DPM_LINK: u32 = 17;
pub const SITA_PROTO_BOP_FRL: u32 = 18;
pub const BTHCI_CHANNEL_COMMAND: u32 = 1;
pub const BTHCI_CHANNEL_ACL: u32 = 2;
pub const BTHCI_CHANNEL_SCO: u32 = 3;
pub const BTHCI_CHANNEL_EVENT: u32 = 4;
pub const BTHCI_CHANNEL_ISO: u32 = 5;
pub const GSM_UM_CHANNEL_UNKNOWN: u32 = 0;
pub const GSM_UM_CHANNEL_BCCH: u32 = 1;
pub const GSM_UM_CHANNEL_SDCCH: u32 = 2;
pub const GSM_UM_CHANNEL_SACCH: u32 = 3;
pub const GSM_UM_CHANNEL_FACCH: u32 = 4;
pub const GSM_UM_CHANNEL_CCCH: u32 = 5;
pub const GSM_UM_CHANNEL_RACH: u32 = 6;
pub const GSM_UM_CHANNEL_AGCH: u32 = 7;
pub const GSM_UM_CHANNEL_PCH: u32 = 8;
pub const LLCP_PHDR_FLAG_SENT: u32 = 0;
pub const REC_TYPE_PACKET: u32 = 0;
pub const REC_TYPE_FT_SPECIFIC_EVENT: u32 = 1;
pub const REC_TYPE_FT_SPECIFIC_REPORT: u32 = 2;
pub const REC_TYPE_SYSCALL: u32 = 3;
pub const REC_TYPE_SYSTEMD_JOURNAL_EXPORT: u32 = 4;
pub const REC_TYPE_CUSTOM_BLOCK: u32 = 5;
pub const PACK_FLAGS_DIRECTION_MASK: u32 = 3;
pub const PACK_FLAGS_DIRECTION_SHIFT: u32 = 0;
pub const PACK_FLAGS_DIRECTION_UNKNOWN: u32 = 0;
pub const PACK_FLAGS_DIRECTION_INBOUND: u32 = 1;
pub const PACK_FLAGS_DIRECTION_OUTBOUND: u32 = 2;
pub const PACK_FLAGS_RECEPTION_TYPE_MASK: u32 = 28;
pub const PACK_FLAGS_RECEPTION_TYPE_SHIFT: u32 = 2;
pub const PACK_FLAGS_RECEPTION_TYPE_UNSPECIFIED: u32 = 0;
pub const PACK_FLAGS_RECEPTION_TYPE_UNICAST: u32 = 1;
pub const PACK_FLAGS_RECEPTION_TYPE_MULTICAST: u32 = 2;
pub const PACK_FLAGS_RECEPTION_TYPE_BROADCAST: u32 = 3;
pub const PACK_FLAGS_RECEPTION_TYPE_PROMISCUOUS: u32 = 4;
pub const PACK_FLAGS_FCS_LENGTH_MASK: u32 = 480;
pub const PACK_FLAGS_FCS_LENGTH_SHIFT: u32 = 5;
pub const PACK_FLAGS_RESERVED_MASK: u32 = 65024;
pub const PACK_FLAGS_CRC_ERROR: u32 = 16777216;
pub const PACK_FLAGS_PACKET_TOO_LONG: u32 = 33554432;
pub const PACK_FLAGS_PACKET_TOO_SHORT: u32 = 67108864;
pub const PACK_FLAGS_WRONG_INTER_FRAME_GAP: u32 = 134217728;
pub const PACK_FLAGS_UNALIGNED_FRAME: u32 = 268435456;
pub const PACK_FLAGS_START_FRAME_DELIMITER_ERROR: u32 = 536870912;
pub const PACK_FLAGS_PREAMBLE_ERROR: u32 = 1073741824;
pub const PACK_FLAGS_SYMBOL_ERROR: u32 = 2147483648;
pub const BBLOG_TYPE_EVENT_BLOCK: u32 = 1;
pub const BBLOG_TYPE_SKIPPED_BLOCK: u32 = 2;
pub const WTAP_HAS_TS: u32 = 1;
pub const WTAP_HAS_CAP_LEN: u32 = 2;
pub const WTAP_HAS_INTERFACE_ID: u32 = 4;
pub const WTAP_HAS_SECTION_NUMBER: u32 = 8;
pub const MAXNAMELEN: u32 = 64;
pub const WTAP_COMMENT_PER_SECTION: u32 = 1;
pub const WTAP_COMMENT_PER_INTERFACE: u32 = 2;
pub const WTAP_COMMENT_PER_PACKET: u32 = 4;
pub const WTAP_TYPE_AUTO: u32 = 0;
pub const WTAP_ERR_NOT_REGULAR_FILE: i32 = -1;
pub const WTAP_ERR_RANDOM_OPEN_PIPE: i32 = -2;
pub const WTAP_ERR_FILE_UNKNOWN_FORMAT: i32 = -3;
pub const WTAP_ERR_UNSUPPORTED: i32 = -4;
pub const WTAP_ERR_CANT_WRITE_TO_PIPE: i32 = -5;
pub const WTAP_ERR_CANT_OPEN: i32 = -6;
pub const WTAP_ERR_UNWRITABLE_FILE_TYPE: i32 = -7;
pub const WTAP_ERR_UNWRITABLE_ENCAP: i32 = -8;
pub const WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED: i32 = -9;
pub const WTAP_ERR_CANT_WRITE: i32 = -10;
pub const WTAP_ERR_CANT_CLOSE: i32 = -11;
pub const WTAP_ERR_SHORT_READ: i32 = -12;
pub const WTAP_ERR_BAD_FILE: i32 = -13;
pub const WTAP_ERR_SHORT_WRITE: i32 = -14;
pub const WTAP_ERR_UNC_OVERFLOW: i32 = -15;
pub const WTAP_ERR_RANDOM_OPEN_STDIN: i32 = -16;
pub const WTAP_ERR_COMPRESSION_NOT_SUPPORTED: i32 = -17;
pub const WTAP_ERR_CANT_SEEK: i32 = -18;
pub const WTAP_ERR_CANT_SEEK_COMPRESSED: i32 = -19;
pub const WTAP_ERR_DECOMPRESS: i32 = -20;
pub const WTAP_ERR_INTERNAL: i32 = -21;
pub const WTAP_ERR_PACKET_TOO_LARGE: i32 = -22;
pub const WTAP_ERR_CHECK_WSLUA: i32 = -23;
pub const WTAP_ERR_UNWRITABLE_REC_TYPE: i32 = -24;
pub const WTAP_ERR_UNWRITABLE_REC_DATA: i32 = -25;
pub const WTAP_ERR_DECOMPRESSION_NOT_SUPPORTED: i32 = -26;
pub const WTAP_ERR_TIME_STAMP_NOT_SUPPORTED: i32 = -27;
pub const GUID_LEN: u32 = 16;
pub const P2P_DIR_UNKNOWN: i32 = -1;
pub const P2P_DIR_SENT: u32 = 0;
pub const P2P_DIR_RECV: u32 = 1;
pub const LINK_DIR_UNKNOWN: i32 = -1;
pub const P2P_DIR_UL: u32 = 0;
pub const P2P_DIR_DL: u32 = 1;
pub const PINFO_HAS_TS: u32 = 1;
pub const DESEGMENT_ONE_MORE_SEGMENT: u32 = 268435455;
pub const DESEGMENT_UNTIL_FIN: u32 = 268435454;
pub const WS_REGEX_CASELESS: u32 = 1;
pub const WS_REGEX_NEVER_UTF: u32 = 2;
pub const FT_ETHER_LEN: u32 = 6;
pub const FT_GUID_LEN: u32 = 16;
pub const FT_IPv4_LEN: u32 = 4;
pub const FT_IPv6_LEN: u32 = 16;
pub const FT_IPXNET_LEN: u32 = 4;
pub const FT_EUI64_LEN: u32 = 8;
pub const FT_AX25_ADDR_LEN: u32 = 7;
pub const FT_VINES_ADDR_LEN: u32 = 6;
pub const FT_FCWWN_LEN: u32 = 8;
pub const FT_VARINT_MAX_LEN: u32 = 10;
pub const FT_TRUE: u32 = 1;
pub const FT_FALSE: u32 = 0;
pub const ITEM_LABEL_LENGTH: u32 = 240;
pub const ITEM_LABEL_UNKNOWN_STR: &[u8; 8] = b"Unknown\0";
pub const ENC_BIG_ENDIAN: u32 = 0;
pub const ENC_LITTLE_ENDIAN: u32 = 2147483648;
pub const ENC_HOST_ENDIAN: u32 = 2147483648;
pub const ENC_ANTI_HOST_ENDIAN: u32 = 0;
pub const ENC_NA: u32 = 0;
pub const ENC_CHARENCODING_MASK: u32 = 65534;
pub const ENC_ASCII: u32 = 0;
pub const ENC_ISO_646_IRV: u32 = 0;
pub const ENC_UTF_8: u32 = 2;
pub const ENC_UTF_16: u32 = 4;
pub const ENC_UCS_2: u32 = 6;
pub const ENC_UCS_4: u32 = 8;
pub const ENC_ISO_8859_1: u32 = 10;
pub const ENC_ISO_8859_2: u32 = 12;
pub const ENC_ISO_8859_3: u32 = 14;
pub const ENC_ISO_8859_4: u32 = 16;
pub const ENC_ISO_8859_5: u32 = 18;
pub const ENC_ISO_8859_6: u32 = 20;
pub const ENC_ISO_8859_7: u32 = 22;
pub const ENC_ISO_8859_8: u32 = 24;
pub const ENC_ISO_8859_9: u32 = 26;
pub const ENC_ISO_8859_10: u32 = 28;
pub const ENC_ISO_8859_11: u32 = 30;
pub const ENC_ISO_8859_13: u32 = 34;
pub const ENC_ISO_8859_14: u32 = 36;
pub const ENC_ISO_8859_15: u32 = 38;
pub const ENC_ISO_8859_16: u32 = 40;
pub const ENC_WINDOWS_1250: u32 = 42;
pub const ENC_3GPP_TS_23_038_7BITS_PACKED: u32 = 44;
pub const ENC_3GPP_TS_23_038_7BITS: u32 = 44;
pub const ENC_EBCDIC: u32 = 46;
pub const ENC_MAC_ROMAN: u32 = 48;
pub const ENC_CP437: u32 = 50;
pub const ENC_ASCII_7BITS: u32 = 52;
pub const ENC_T61: u32 = 54;
pub const ENC_EBCDIC_CP037: u32 = 56;
pub const ENC_WINDOWS_1252: u32 = 58;
pub const ENC_WINDOWS_1251: u32 = 60;
pub const ENC_CP855: u32 = 62;
pub const ENC_CP866: u32 = 64;
pub const ENC_ISO_646_BASIC: u32 = 66;
pub const ENC_BCD_DIGITS_0_9: u32 = 68;
pub const ENC_KEYPAD_ABC_TBCD: u32 = 70;
pub const ENC_KEYPAD_BC_TBCD: u32 = 72;
pub const ENC_3GPP_TS_23_038_7BITS_UNPACKED: u32 = 76;
pub const ENC_ETSI_TS_102_221_ANNEX_A: u32 = 78;
pub const ENC_GB18030: u32 = 80;
pub const ENC_EUC_KR: u32 = 82;
pub const ENC_APN_STR: u32 = 84;
pub const ENC_DECT_STANDARD_8BITS: u32 = 86;
pub const ENC_DECT_STANDARD_4BITS_TBCD: u32 = 88;
pub const ENC_EBCDIC_CP500: u32 = 96;
pub const ENC_ZIGBEE: u32 = 1073741824;
pub const ENC_BOM: u32 = 536870912;
pub const ENC_STR_NUM: u32 = 16777216;
pub const ENC_STR_HEX: u32 = 33554432;
pub const ENC_STRING: u32 = 50331648;
pub const ENC_STR_MASK: u32 = 65534;
pub const ENC_NUM_PREF: u32 = 2097152;
pub const ENC_SEP_NONE: u32 = 65536;
pub const ENC_SEP_COLON: u32 = 131072;
pub const ENC_SEP_DASH: u32 = 262144;
pub const ENC_SEP_DOT: u32 = 524288;
pub const ENC_SEP_SPACE: u32 = 1048576;
pub const ENC_SEP_MASK: u32 = 2031616;
pub const ENC_BCD_ODD_NUM_DIG: u32 = 65536;
pub const ENC_BCD_SKIP_FIRST: u32 = 131072;
pub const ENC_TIME_SECS_NSECS: u32 = 0;
pub const ENC_TIME_TIMESPEC: u32 = 0;
pub const ENC_TIME_NTP: u32 = 2;
pub const ENC_TIME_TOD: u32 = 4;
pub const ENC_TIME_RTPS: u32 = 8;
pub const ENC_TIME_NTP_BASE_ZERO: u32 = 8;
pub const ENC_TIME_SECS_USECS: u32 = 16;
pub const ENC_TIME_TIMEVAL: u32 = 16;
pub const ENC_TIME_SECS: u32 = 18;
pub const ENC_TIME_MSECS: u32 = 20;
pub const ENC_TIME_SECS_NTP: u32 = 24;
pub const ENC_TIME_RFC_3971: u32 = 32;
pub const ENC_TIME_MSEC_NTP: u32 = 34;
pub const ENC_TIME_MIP6: u32 = 36;
pub const ENC_TIME_CLASSIC_MAC_OS_SECS: u32 = 38;
pub const ENC_TIME_NSECS: u32 = 40;
pub const ENC_TIME_USECS: u32 = 48;
pub const ENC_ISO_8601_DATE: u32 = 65536;
pub const ENC_ISO_8601_TIME: u32 = 131072;
pub const ENC_ISO_8601_DATE_TIME: u32 = 196608;
pub const ENC_IMF_DATE_TIME: u32 = 262144;
pub const ENC_RFC_822: u32 = 262144;
pub const ENC_RFC_1123: u32 = 262144;
pub const ENC_ISO_8601_DATE_TIME_BASIC: u32 = 1048576;
pub const ENC_STR_TIME_MASK: u32 = 2031616;
pub const ENC_VARINT_PROTOBUF: u32 = 2;
pub const ENC_VARINT_QUIC: u32 = 4;
pub const ENC_VARINT_ZIGZAG: u32 = 8;
pub const ENC_VARINT_SDNV: u32 = 16;
pub const ENC_VARINT_MASK: u32 = 30;
pub const FIELD_DISPLAY_E_MASK: u32 = 255;
pub const BASE_RANGE_STRING: u32 = 256;
pub const BASE_EXT_STRING: u32 = 512;
pub const BASE_VAL64_STRING: u32 = 1024;
pub const BASE_ALLOW_ZERO: u32 = 2048;
pub const BASE_UNIT_STRING: u32 = 4096;
pub const BASE_NO_DISPLAY_VALUE: u32 = 8192;
pub const BASE_PROTOCOL_INFO: u32 = 16384;
pub const BASE_SPECIAL_VALS: u32 = 32768;
pub const BASE_SHOW_ASCII_PRINTABLE: u32 = 65536;
pub const BASE_SHOW_UTF_8_PRINTABLE: u32 = 131072;
pub const FI_HIDDEN: u32 = 1;
pub const FI_GENERATED: u32 = 2;
pub const FI_URL: u32 = 4;
pub const FI_LITTLE_ENDIAN: u32 = 8;
pub const FI_BIG_ENDIAN: u32 = 16;
pub const FI_VARINT: u32 = 16384;
pub const PI_SEVERITY_MASK: u32 = 15728640;
pub const PI_COMMENT: u32 = 1048576;
pub const PI_CHAT: u32 = 2097152;
pub const PI_NOTE: u32 = 4194304;
pub const PI_WARN: u32 = 6291456;
pub const PI_ERROR: u32 = 8388608;
pub const PI_GROUP_MASK: u32 = 4278190080;
pub const PI_CHECKSUM: u32 = 16777216;
pub const PI_SEQUENCE: u32 = 33554432;
pub const PI_RESPONSE_CODE: u32 = 50331648;
pub const PI_REQUEST_CODE: u32 = 67108864;
pub const PI_UNDECODED: u32 = 83886080;
pub const PI_REASSEMBLE: u32 = 100663296;
pub const PI_MALFORMED: u32 = 117440512;
pub const PI_DEBUG: u32 = 134217728;
pub const PI_PROTOCOL: u32 = 150994944;
pub const PI_SECURITY: u32 = 167772160;
pub const PI_COMMENTS_GROUP: u32 = 184549376;
pub const PI_DECRYPTION: u32 = 201326592;
pub const PI_ASSUMPTION: u32 = 218103808;
pub const PI_DEPRECATED: u32 = 234881024;
pub const BMT_NO_FLAGS: u32 = 0;
pub const BMT_NO_APPEND: u32 = 1;
pub const BMT_NO_INT: u32 = 2;
pub const BMT_NO_FALSE: u32 = 4;
pub const BMT_NO_TFS: u32 = 8;
pub const PROTO_CHECKSUM_NO_FLAGS: u32 = 0;
pub const PROTO_CHECKSUM_VERIFY: u32 = 1;
pub const PROTO_CHECKSUM_GENERATED: u32 = 2;
pub const PROTO_CHECKSUM_IN_CKSUM: u32 = 4;
pub const PROTO_CHECKSUM_ZERO: u32 = 8;
pub const PROTO_CHECKSUM_NOT_PRESENT: u32 = 16;
pub const MAX_SCTP_PORT: u32 = 65535;
pub const MAX_TCP_PORT: u32 = 65535;
pub const MAX_UDP_PORT: u32 = 65535;
pub const MAX_DCCP_PORT: u32 = 65535;
pub const DEF_WIDTH: u32 = 750;
pub const DEF_HEIGHT: u32 = 550;
pub const MAX_VAL_LEN: u32 = 1024;
pub const TAP_UPDATE_DEFAULT_INTERVAL: u32 = 3000;
pub const ST_DEF_BURSTRES: u32 = 5;
pub const ST_DEF_BURSTLEN: u32 = 100;
pub const ST_MAX_BURSTRES: u32 = 600000;
pub const ST_MAX_BURSTBUCKETS: u32 = 100;
pub const DEF_GUI_DECIMAL_PLACES1: u32 = 2;
pub const DEF_GUI_DECIMAL_PLACES2: u32 = 4;
pub const DEF_GUI_DECIMAL_PLACES3: u32 = 6;
pub const FO_STYLE_LAST_OPENED: u32 = 0;
pub const FO_STYLE_SPECIFIED: u32 = 1;
pub const TB_STYLE_ICONS: u32 = 0;
pub const TB_STYLE_TEXT: u32 = 1;
pub const TB_STYLE_BOTH: u32 = 2;
pub const COLOR_STYLE_DEFAULT: u32 = 0;
pub const COLOR_STYLE_FLAT: u32 = 1;
pub const COLOR_STYLE_GRADIENT: u32 = 2;
pub const COLOR_STYLE_ALPHA: f64 = 0.25;
pub const COL_MAX_LEN: u32 = 2048;
pub const COL_MAX_INFO_LEN: u32 = 4096;
pub const COL_CUSTOM_PRIME_REGEX: &[u8; 40] = b" *([^ \\|]+) *(?:(?:\\|\\|)|(?:or)| *$){1}\0";
pub const STRING_CASE_SENSITIVE: u32 = 0;
pub const STRING_CASE_INSENSITIVE: u32 = 1;
pub const MAX_DECODE_AS_PROMPT_LEN: u32 = 200;
pub const DECODE_AS_ENTRY: &[u8; 16] = b"decode_as_entry\0";
pub const DECODE_AS_NONE: &[u8; 7] = b"(none)\0";
pub const DECODE_AS_ENTRIES_FILE_NAME: &[u8; 18] = b"decode_as_entries\0";
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn() -> !;
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    ) -> !;
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___crt_locale_data_public() {
    const UNINIT: ::std::mem::MaybeUninit<__crt_locale_data_public> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_data_public>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_data_public>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_pctype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_pctype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_mb_cur_max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_mb_cur_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_lc_codepage) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_lc_codepage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
#[test]
fn bindgen_test_layout___crt_locale_pointers() {
    const UNINIT: ::std::mem::MaybeUninit<__crt_locale_pointers> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_pointers>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_pointers>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).locinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(locinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mbcinfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(mbcinfo)
        )
    );
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__Mbstatet() {
    const UNINIT: ::std::mem::MaybeUninit<_Mbstatet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Mbstatet>(),
        8usize,
        concat!("Size of: ", stringify!(_Mbstatet))
    );
    assert_eq!(
        ::std::mem::align_of::<_Mbstatet>(),
        4usize,
        concat!("Alignment of ", stringify!(_Mbstatet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Wchar) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Wchar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Byte) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Byte)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._State) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_State)
        )
    );
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Lldiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout__Lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<_Lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(_Lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_Lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_Lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type imaxdiv_t = _Lldiv_t;
extern "C" {
    pub fn imaxabs(_Number: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(_Numerator: intmax_t, _Denominator: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn _strtoimax_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn _strtoumax_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn _wcstoimax_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn _wcstoumax_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> uintmax_t;
}
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __doserrno() -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _set_doserrno(_Value: ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn _get_doserrno(_Value: *mut ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn memchr(
        _Buf: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        _Dst: *mut ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strchr(
        _Str: *const ::std::os::raw::c_char,
        _Val: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        _Str: *const ::std::os::raw::c_char,
        _Ch: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        _Str: *const ::std::os::raw::c_char,
        _SubStr: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn wcschr(
        _Str: *const ::std::os::raw::c_ushort,
        _Ch: ::std::os::raw::c_ushort,
    ) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn wcsrchr(_Str: *const wchar_t, _Ch: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsstr(_Str: *const wchar_t, _SubStr: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _memicmp_l(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcscpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstok_s(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscat(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscmp(
        _String1: *const ::std::os::raw::c_ushort,
        _String2: *const ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscpy(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscspn(_String: *const wchar_t, _Control: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcslen(_String: *const ::std::os::raw::c_ushort) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcsnlen(_Source: *const wchar_t, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn wcsncat(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncmp(
        _String1: *const ::std::os::raw::c_ushort,
        _String2: *const ::std::os::raw::c_ushort,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncpy(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcspbrk(_String: *const wchar_t, _Control: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsspn(_String: *const wchar_t, _Control: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcstok(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror(_ErrorNumber: ::std::os::raw::c_int) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _ErrorNumber: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn __wcserror(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn __wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _ErrorMessage: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnset_s(
        _Destination: *mut wchar_t,
        _SizeInWords: usize,
        _Value: wchar_t,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsset_s(_Destination: *mut wchar_t, _SizeInWords: usize, _Value: wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s(_String: *mut wchar_t, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s_l(_String: *mut wchar_t, _SizeInWords: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcslwr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s(_String: *mut wchar_t, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s_l(_String: *mut wchar_t, _Size: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcsupr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsxfrm(_Destination: *mut wchar_t, _Source: *const wchar_t, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _wcsxfrm_l(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wcscoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcscoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strcat_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _ErrorNumber: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn strncat_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strncpy_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strtok_s(
        _String: *mut ::std::os::raw::c_char,
        _Delimiter: *const ::std::os::raw::c_char,
        _Context: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcmpi(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strdup(_Source: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strerror(_ErrorMessage: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strerror_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _ErrorMessage: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror(_ErrorMessage: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _stricmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricmp_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlen(_Str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strlwr_s(_String: *mut ::std::os::raw::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strlwr_s_l(
        _String: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strlwr_l(
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __strncnt(_String: *const ::std::os::raw::c_char, _Count: usize) -> usize;
}
extern "C" {
    pub fn strncpy(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(_String: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _strnset_s(
        _String: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Value: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _strnset(
        _Destination: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
        _Count: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strrev(_Str: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strset_s(
        _Destination: *mut ::std::os::raw::c_char,
        _DestinationSize: usize,
        _Value: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _strset(
        _Destination: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtok(
        _String: *mut ::std::os::raw::c_char,
        _Delimiter: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_s(_String: *mut ::std::os::raw::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_s_l(
        _String: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strupr_l(
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strxfrm_l(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(_String: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmpi(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stricmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnicmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strnset(
        _String: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrev(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strset(
        _String: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
pub type max_align_t = f64;
extern "C" {
    pub fn _clearfp() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _controlfp(
        _NewValue: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _set_controlfp(_NewValue: ::std::os::raw::c_uint, _Mask: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _controlfp_s(
        _CurrentState: *mut ::std::os::raw::c_uint,
        _NewValue: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> errno_t;
}
extern "C" {
    pub fn _statusfp() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _fpreset();
}
extern "C" {
    pub fn _control87(
        _NewValue: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __fpecode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpe_flt_rounds() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _copysign(_Number: f64, _Sign: f64) -> f64;
}
extern "C" {
    pub fn _chgsign(_X: f64) -> f64;
}
extern "C" {
    pub fn _scalb(_X: f64, _Y: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn _logb(_X: f64) -> f64;
}
extern "C" {
    pub fn _nextafter(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn _finite(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isnan(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fpclass(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scalbf(_X: f32, _Y: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn fpreset();
}
pub type gint8 = ::std::os::raw::c_schar;
pub type guint8 = ::std::os::raw::c_uchar;
pub type gint16 = ::std::os::raw::c_short;
pub type guint16 = ::std::os::raw::c_ushort;
pub type gint32 = ::std::os::raw::c_int;
pub type guint32 = ::std::os::raw::c_uint;
pub type gint64 = ::std::os::raw::c_longlong;
pub type guint64 = ::std::os::raw::c_ulonglong;
pub type gssize = ::std::os::raw::c_longlong;
pub type gsize = ::std::os::raw::c_ulonglong;
pub type goffset = gint64;
pub type gintptr = ::std::os::raw::c_longlong;
pub type guintptr = ::std::os::raw::c_ulonglong;
pub type GPid = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        36usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        4usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
}
extern "C" {
    pub fn _wasctime(_Tm: *const tm) -> *mut wchar_t;
}
extern "C" {
    pub fn _wasctime_s(_Buffer: *mut wchar_t, _SizeInWords: usize, _Tm: *const tm) -> errno_t;
}
extern "C" {
    pub fn wcsftime(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _Format: *const wchar_t,
        _Tm: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn _wcsftime_l(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _Format: *const wchar_t,
        _Tm: *const tm,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn _wctime32(_Time: *const __time32_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wctime32_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _Time: *const __time32_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wctime64(_Time: *const __time64_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wctime64_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _Time: *const __time64_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wstrdate_s(_Buffer: *mut wchar_t, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wstrdate(_Buffer: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wstrtime_s(_Buffer: *mut wchar_t, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wstrtime(_Buffer: *mut wchar_t) -> *mut wchar_t;
}
pub type clock_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _timespec32 {
    pub tv_sec: __time32_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__timespec32() {
    const UNINIT: ::std::mem::MaybeUninit<_timespec32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_timespec32>(),
        8usize,
        concat!("Size of: ", stringify!(_timespec32))
    );
    assert_eq!(
        ::std::mem::align_of::<_timespec32>(),
        4usize,
        concat!("Alignment of ", stringify!(_timespec32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_timespec32),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_timespec32),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _timespec64 {
    pub tv_sec: __time64_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__timespec64() {
    const UNINIT: ::std::mem::MaybeUninit<_timespec64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_timespec64>(),
        16usize,
        concat!("Size of: ", stringify!(_timespec64))
    );
    assert_eq!(
        ::std::mem::align_of::<_timespec64>(),
        8usize,
        concat!("Alignment of ", stringify!(_timespec64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_timespec64),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_timespec64),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
extern "C" {
    pub fn __daylight() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __dstbias() -> *mut ::std::os::raw::c_long;
}
extern "C" {
    pub fn __timezone() -> *mut ::std::os::raw::c_long;
}
extern "C" {
    pub fn __tzname() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _get_daylight(_Daylight: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_dstbias(_DaylightSavingsBias: *mut ::std::os::raw::c_long) -> errno_t;
}
extern "C" {
    pub fn _get_timezone(_TimeZone: *mut ::std::os::raw::c_long) -> errno_t;
}
extern "C" {
    pub fn _get_tzname(
        _ReturnValue: *mut usize,
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Index: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn asctime(_Tm: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Tm: *const tm,
    ) -> errno_t;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn _ctime32(_Time: *const __time32_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ctime32_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Time: *const __time32_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _ctime64(_Time: *const __time64_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ctime64_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Time: *const __time64_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _difftime32(_Time1: __time32_t, _Time2: __time32_t) -> f64;
}
extern "C" {
    pub fn _difftime64(_Time1: __time64_t, _Time2: __time64_t) -> f64;
}
extern "C" {
    pub fn _gmtime32(_Time: *const __time32_t) -> *mut tm;
}
extern "C" {
    pub fn _gmtime32_s(_Tm: *mut tm, _Time: *const __time32_t) -> errno_t;
}
extern "C" {
    pub fn _gmtime64(_Time: *const __time64_t) -> *mut tm;
}
extern "C" {
    pub fn _gmtime64_s(_Tm: *mut tm, _Time: *const __time64_t) -> errno_t;
}
extern "C" {
    pub fn _localtime32(_Time: *const __time32_t) -> *mut tm;
}
extern "C" {
    pub fn _localtime32_s(_Tm: *mut tm, _Time: *const __time32_t) -> errno_t;
}
extern "C" {
    pub fn _localtime64(_Time: *const __time64_t) -> *mut tm;
}
extern "C" {
    pub fn _localtime64_s(_Tm: *mut tm, _Time: *const __time64_t) -> errno_t;
}
extern "C" {
    pub fn _mkgmtime32(_Tm: *mut tm) -> __time32_t;
}
extern "C" {
    pub fn _mkgmtime64(_Tm: *mut tm) -> __time64_t;
}
extern "C" {
    pub fn _mktime32(_Tm: *mut tm) -> __time32_t;
}
extern "C" {
    pub fn _mktime64(_Tm: *mut tm) -> __time64_t;
}
extern "C" {
    pub fn strftime(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Format: *const ::std::os::raw::c_char,
        _Tm: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn _strftime_l(
        _Buffer: *mut ::std::os::raw::c_char,
        _MaxSize: usize,
        _Format: *const ::std::os::raw::c_char,
        _Tm: *const tm,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn _strdate_s(_Buffer: *mut ::std::os::raw::c_char, _SizeInBytes: usize) -> errno_t;
}
extern "C" {
    pub fn _strdate(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strtime_s(_Buffer: *mut ::std::os::raw::c_char, _SizeInBytes: usize) -> errno_t;
}
extern "C" {
    pub fn _strtime(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _time32(_Time: *mut __time32_t) -> __time32_t;
}
extern "C" {
    pub fn _time64(_Time: *mut __time64_t) -> __time64_t;
}
extern "C" {
    pub fn _timespec32_get(
        _Ts: *mut _timespec32,
        _Base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _timespec64_get(
        _Ts: *mut _timespec64,
        _Base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tzset();
}
extern "C" {
    pub fn _getsystime(_Tm: *mut tm) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _setsystime(
        _Tm: *mut tm,
        _Milliseconds: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn tzset();
}
pub type gchar = ::std::os::raw::c_char;
pub type gshort = ::std::os::raw::c_short;
pub type glong = ::std::os::raw::c_long;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type guchar = ::std::os::raw::c_uchar;
pub type gushort = ::std::os::raw::c_ushort;
pub type gulong = ::std::os::raw::c_ulong;
pub type guint = ::std::os::raw::c_uint;
pub type gfloat = f32;
pub type gdouble = f64;
pub type gpointer = *mut ::std::os::raw::c_void;
pub type gconstpointer = *const ::std::os::raw::c_void;
pub type GCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer) -> gint>;
pub type GCompareDataFunc = ::std::option::Option<
    unsafe extern "C" fn(a: gconstpointer, b: gconstpointer, user_data: gpointer) -> gint,
>;
pub type GEqualFunc =
    ::std::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer) -> gboolean>;
#[doc = " GEqualFuncFull:\n @a: a value\n @b: a value to compare with\n @user_data: user data provided by the caller\n\n Specifies the type of a function used to test two values for\n equality. The function should return %TRUE if both values are equal\n and %FALSE otherwise.\n\n This is a version of #GEqualFunc which provides a @user_data closure from\n the caller.\n\n Returns: %TRUE if @a = @b; %FALSE otherwise\n Since: 2.74"]
pub type GEqualFuncFull = ::std::option::Option<
    unsafe extern "C" fn(a: gconstpointer, b: gconstpointer, user_data: gpointer) -> gboolean,
>;
pub type GDestroyNotify = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub type GFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer)>;
pub type GHashFunc = ::std::option::Option<unsafe extern "C" fn(key: gconstpointer) -> guint>;
pub type GHFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, user_data: gpointer),
>;
#[doc = " GCopyFunc:\n @src: (not nullable): A pointer to the data which should be copied\n @data: Additional data\n\n A function of this signature is used to copy the node data\n when doing a deep-copy of a tree.\n\n Returns: (not nullable): A pointer to the copy\n\n Since: 2.4"]
pub type GCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(src: gconstpointer, data: gpointer) -> gpointer>;
#[doc = " GFreeFunc:\n @data: a data pointer\n\n Declares a type of function which takes an arbitrary\n data pointer argument and has no return value. It is\n not currently used in GLib or GTK."]
pub type GFreeFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
#[doc = " GTranslateFunc:\n @str: the untranslated string\n @data: user data specified when installing the function, e.g.\n  in g_option_group_set_translate_func()\n\n The type of functions which are used to translate user-visible\n strings, for <option>--help</option> output.\n\n Returns: a translation of the string for the current locale.\n  The returned string is owned by GLib and must not be freed."]
pub type GTranslateFunc =
    ::std::option::Option<unsafe extern "C" fn(str_: *const gchar, data: gpointer) -> *const gchar>;
pub type GDoubleIEEE754 = _GDoubleIEEE754;
pub type GFloatIEEE754 = _GFloatIEEE754;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GFloatIEEE754 {
    pub v_float: gfloat,
    pub mpn: _GFloatIEEE754__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFloatIEEE754__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__GFloatIEEE754__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GFloatIEEE754__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_GFloatIEEE754__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFloatIEEE754__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_GFloatIEEE754__bindgen_ty_1))
    );
}
impl _GFloatIEEE754__bindgen_ty_1 {
    #[inline]
    pub fn mantissa(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn biased_exponent(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sign(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mantissa: guint,
        biased_exponent: guint,
        sign: guint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 23u8, {
            let mantissa: u32 = unsafe { ::std::mem::transmute(mantissa) };
            mantissa as u64
        });
        __bindgen_bitfield_unit.set(23usize, 8u8, {
            let biased_exponent: u32 = unsafe { ::std::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sign: u32 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__GFloatIEEE754() {
    const UNINIT: ::std::mem::MaybeUninit<_GFloatIEEE754> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFloatIEEE754>(),
        4usize,
        concat!("Size of: ", stringify!(_GFloatIEEE754))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFloatIEEE754>(),
        4usize,
        concat!("Alignment of ", stringify!(_GFloatIEEE754))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_float) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFloatIEEE754),
            "::",
            stringify!(v_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFloatIEEE754),
            "::",
            stringify!(mpn)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GDoubleIEEE754 {
    pub v_double: gdouble,
    pub mpn: _GDoubleIEEE754__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDoubleIEEE754__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout__GDoubleIEEE754__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GDoubleIEEE754__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_GDoubleIEEE754__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDoubleIEEE754__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_GDoubleIEEE754__bindgen_ty_1))
    );
}
impl _GDoubleIEEE754__bindgen_ty_1 {
    #[inline]
    pub fn mantissa_low(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa_low(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn mantissa_high(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa_high(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn biased_exponent(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn sign(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mantissa_low: guint,
        mantissa_high: guint,
        biased_exponent: guint,
        sign: guint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let mantissa_low: u32 = unsafe { ::std::mem::transmute(mantissa_low) };
            mantissa_low as u64
        });
        __bindgen_bitfield_unit.set(32usize, 20u8, {
            let mantissa_high: u32 = unsafe { ::std::mem::transmute(mantissa_high) };
            mantissa_high as u64
        });
        __bindgen_bitfield_unit.set(52usize, 11u8, {
            let biased_exponent: u32 = unsafe { ::std::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let sign: u32 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__GDoubleIEEE754() {
    const UNINIT: ::std::mem::MaybeUninit<_GDoubleIEEE754> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDoubleIEEE754>(),
        8usize,
        concat!("Size of: ", stringify!(_GDoubleIEEE754))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDoubleIEEE754>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDoubleIEEE754))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_double) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDoubleIEEE754),
            "::",
            stringify!(v_double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDoubleIEEE754),
            "::",
            stringify!(mpn)
        )
    );
}
pub type GTimeVal = _GTimeVal;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimeVal {
    pub tv_sec: glong,
    pub tv_usec: glong,
}
#[test]
fn bindgen_test_layout__GTimeVal() {
    const UNINIT: ::std::mem::MaybeUninit<_GTimeVal> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTimeVal>(),
        8usize,
        concat!("Size of: ", stringify!(_GTimeVal))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTimeVal>(),
        4usize,
        concat!("Alignment of ", stringify!(_GTimeVal))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTimeVal),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTimeVal),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type grefcount = gint;
pub type gatomicrefcount = gint;
extern "C" {
    pub fn _calloc_base(_Count: usize, _Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        _Count: ::std::os::raw::c_ulonglong,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _callnewh(_Size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _expand(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _free_base(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _malloc_base(_Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc(_Size: ::std::os::raw::c_ulonglong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _msize_base(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _msize(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _realloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _aligned_malloc(_Size: usize, _Alignment: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_malloc(
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_msize(
        _Block: *mut ::std::os::raw::c_void,
        _Alignment: usize,
        _Offset: usize,
    ) -> usize;
}
extern "C" {
    pub fn _aligned_offset_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _heapinfo {
    pub _pentry: *mut ::std::os::raw::c_int,
    pub _size: usize,
    pub _useflag: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__heapinfo() {
    const UNINIT: ::std::mem::MaybeUninit<_heapinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_heapinfo>(),
        24usize,
        concat!("Size of: ", stringify!(_heapinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_heapinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_heapinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._pentry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_heapinfo),
            "::",
            stringify!(_pentry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_heapinfo),
            "::",
            stringify!(_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._useflag) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_heapinfo),
            "::",
            stringify!(_useflag)
        )
    );
}
pub type _HEAPINFO = _heapinfo;
extern "C" {
    pub fn _alloca(_Size: ::std::os::raw::c_ulonglong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _get_heap_handle() -> isize;
}
extern "C" {
    pub fn _heapmin() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapwalk(_EntryInfo: *mut _HEAPINFO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapchk() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _resetstkoflw() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBytes {
    _unused: [u8; 0],
}
pub type GBytes = _GBytes;
pub type GArray = _GArray;
pub type GByteArray = _GByteArray;
pub type GPtrArray = _GPtrArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GArray {
    pub data: *mut gchar,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GArray() {
    const UNINIT: ::std::mem::MaybeUninit<_GArray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GArray>(),
        16usize,
        concat!("Size of: ", stringify!(_GArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GArray),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GArray),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GByteArray {
    pub data: *mut guint8,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GByteArray() {
    const UNINIT: ::std::mem::MaybeUninit<_GByteArray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GByteArray>(),
        16usize,
        concat!("Size of: ", stringify!(_GByteArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GByteArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GByteArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GByteArray),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GByteArray),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPtrArray {
    pub pdata: *mut gpointer,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GPtrArray() {
    const UNINIT: ::std::mem::MaybeUninit<_GPtrArray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GPtrArray>(),
        16usize,
        concat!("Size of: ", stringify!(_GPtrArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPtrArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPtrArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdata) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPtrArray),
            "::",
            stringify!(pdata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPtrArray),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    pub fn g_array_new(
        zero_terminated: gboolean,
        clear_: gboolean,
        element_size: guint,
    ) -> *mut GArray;
}
extern "C" {
    pub fn g_array_new_take(
        data: gpointer,
        len: gsize,
        clear: gboolean,
        element_size: gsize,
    ) -> *mut GArray;
}
extern "C" {
    pub fn g_array_new_take_zero_terminated(
        data: gpointer,
        clear: gboolean,
        element_size: gsize,
    ) -> *mut GArray;
}
extern "C" {
    pub fn g_array_steal(array: *mut GArray, len: *mut gsize) -> gpointer;
}
extern "C" {
    pub fn g_array_sized_new(
        zero_terminated: gboolean,
        clear_: gboolean,
        element_size: guint,
        reserved_size: guint,
    ) -> *mut GArray;
}
extern "C" {
    pub fn g_array_copy(array: *mut GArray) -> *mut GArray;
}
extern "C" {
    pub fn g_array_free(array: *mut GArray, free_segment: gboolean) -> *mut gchar;
}
extern "C" {
    pub fn g_array_ref(array: *mut GArray) -> *mut GArray;
}
extern "C" {
    pub fn g_array_unref(array: *mut GArray);
}
extern "C" {
    pub fn g_array_get_element_size(array: *mut GArray) -> guint;
}
extern "C" {
    pub fn g_array_append_vals(array: *mut GArray, data: gconstpointer, len: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_prepend_vals(array: *mut GArray, data: gconstpointer, len: guint)
        -> *mut GArray;
}
extern "C" {
    pub fn g_array_insert_vals(
        array: *mut GArray,
        index_: guint,
        data: gconstpointer,
        len: guint,
    ) -> *mut GArray;
}
extern "C" {
    pub fn g_array_set_size(array: *mut GArray, length: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_remove_index(array: *mut GArray, index_: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_remove_index_fast(array: *mut GArray, index_: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_remove_range(array: *mut GArray, index_: guint, length: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_sort(array: *mut GArray, compare_func: GCompareFunc);
}
extern "C" {
    pub fn g_array_sort_with_data(
        array: *mut GArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_array_binary_search(
        array: *mut GArray,
        target: gconstpointer,
        compare_func: GCompareFunc,
        out_match_index: *mut guint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_array_set_clear_func(array: *mut GArray, clear_func: GDestroyNotify);
}
extern "C" {
    pub fn g_ptr_array_new() -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_with_free_func(element_free_func: GDestroyNotify) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_take(
        data: *mut gpointer,
        len: gsize,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_from_array(
        data: *mut gpointer,
        len: gsize,
        copy_func: GCopyFunc,
        copy_func_user_data: gpointer,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_steal(array: *mut GPtrArray, len: *mut gsize) -> *mut gpointer;
}
extern "C" {
    pub fn g_ptr_array_copy(
        array: *mut GPtrArray,
        func: GCopyFunc,
        user_data: gpointer,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_sized_new(reserved_size: guint) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_full(
        reserved_size: guint,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_null_terminated(
        reserved_size: guint,
        element_free_func: GDestroyNotify,
        null_terminated: gboolean,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_take_null_terminated(
        data: *mut gpointer,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_from_null_terminated_array(
        data: *mut gpointer,
        copy_func: GCopyFunc,
        copy_func_user_data: gpointer,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_free(array: *mut GPtrArray, free_seg: gboolean) -> *mut gpointer;
}
extern "C" {
    pub fn g_ptr_array_ref(array: *mut GPtrArray) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_unref(array: *mut GPtrArray);
}
extern "C" {
    pub fn g_ptr_array_set_free_func(array: *mut GPtrArray, element_free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_ptr_array_set_size(array: *mut GPtrArray, length: gint);
}
extern "C" {
    pub fn g_ptr_array_remove_index(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    pub fn g_ptr_array_remove_index_fast(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    pub fn g_ptr_array_steal_index(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    pub fn g_ptr_array_steal_index_fast(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    pub fn g_ptr_array_remove(array: *mut GPtrArray, data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_ptr_array_remove_fast(array: *mut GPtrArray, data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_ptr_array_remove_range(
        array: *mut GPtrArray,
        index_: guint,
        length: guint,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_add(array: *mut GPtrArray, data: gpointer);
}
extern "C" {
    pub fn g_ptr_array_extend(
        array_to_extend: *mut GPtrArray,
        array: *mut GPtrArray,
        func: GCopyFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_ptr_array_extend_and_steal(array_to_extend: *mut GPtrArray, array: *mut GPtrArray);
}
extern "C" {
    pub fn g_ptr_array_insert(array: *mut GPtrArray, index_: gint, data: gpointer);
}
extern "C" {
    pub fn g_ptr_array_sort(array: *mut GPtrArray, compare_func: GCompareFunc);
}
extern "C" {
    pub fn g_ptr_array_sort_with_data(
        array: *mut GPtrArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_ptr_array_sort_values(array: *mut GPtrArray, compare_func: GCompareFunc);
}
extern "C" {
    pub fn g_ptr_array_sort_values_with_data(
        array: *mut GPtrArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_ptr_array_foreach(array: *mut GPtrArray, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_ptr_array_find(
        haystack: *mut GPtrArray,
        needle: gconstpointer,
        index_: *mut guint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_ptr_array_find_with_equal_func(
        haystack: *mut GPtrArray,
        needle: gconstpointer,
        equal_func: GEqualFunc,
        index_: *mut guint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_ptr_array_is_null_terminated(array: *mut GPtrArray) -> gboolean;
}
extern "C" {
    pub fn g_byte_array_new() -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_new_take(data: *mut guint8, len: gsize) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_steal(array: *mut GByteArray, len: *mut gsize) -> *mut guint8;
}
extern "C" {
    pub fn g_byte_array_sized_new(reserved_size: guint) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_free(array: *mut GByteArray, free_segment: gboolean) -> *mut guint8;
}
extern "C" {
    pub fn g_byte_array_free_to_bytes(array: *mut GByteArray) -> *mut GBytes;
}
extern "C" {
    pub fn g_byte_array_ref(array: *mut GByteArray) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_unref(array: *mut GByteArray);
}
extern "C" {
    pub fn g_byte_array_append(
        array: *mut GByteArray,
        data: *const guint8,
        len: guint,
    ) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_prepend(
        array: *mut GByteArray,
        data: *const guint8,
        len: guint,
    ) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_set_size(array: *mut GByteArray, length: guint) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_remove_index(array: *mut GByteArray, index_: guint) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_remove_index_fast(array: *mut GByteArray, index_: guint)
        -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_remove_range(
        array: *mut GByteArray,
        index_: guint,
        length: guint,
    ) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_sort(array: *mut GByteArray, compare_func: GCompareFunc);
}
extern "C" {
    pub fn g_byte_array_sort_with_data(
        array: *mut GByteArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_atomic_int_get(atomic: *const gint) -> gint;
}
extern "C" {
    pub fn g_atomic_int_set(atomic: *mut gint, newval: gint);
}
extern "C" {
    pub fn g_atomic_int_inc(atomic: *mut gint);
}
extern "C" {
    pub fn g_atomic_int_dec_and_test(atomic: *mut gint) -> gboolean;
}
extern "C" {
    pub fn g_atomic_int_compare_and_exchange(
        atomic: *mut gint,
        oldval: gint,
        newval: gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_atomic_int_compare_and_exchange_full(
        atomic: *mut gint,
        oldval: gint,
        newval: gint,
        preval: *mut gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_atomic_int_exchange(atomic: *mut gint, newval: gint) -> gint;
}
extern "C" {
    pub fn g_atomic_int_add(atomic: *mut gint, val: gint) -> gint;
}
extern "C" {
    pub fn g_atomic_int_and(atomic: *mut guint, val: guint) -> guint;
}
extern "C" {
    pub fn g_atomic_int_or(atomic: *mut guint, val: guint) -> guint;
}
extern "C" {
    pub fn g_atomic_int_xor(atomic: *mut guint, val: guint) -> guint;
}
extern "C" {
    pub fn g_atomic_pointer_get(atomic: *const ::std::os::raw::c_void) -> gpointer;
}
extern "C" {
    pub fn g_atomic_pointer_set(atomic: *mut ::std::os::raw::c_void, newval: gpointer);
}
extern "C" {
    pub fn g_atomic_pointer_compare_and_exchange(
        atomic: *mut ::std::os::raw::c_void,
        oldval: gpointer,
        newval: gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_atomic_pointer_compare_and_exchange_full(
        atomic: *mut ::std::os::raw::c_void,
        oldval: gpointer,
        newval: gpointer,
        preval: *mut ::std::os::raw::c_void,
    ) -> gboolean;
}
extern "C" {
    pub fn g_atomic_pointer_exchange(
        atomic: *mut ::std::os::raw::c_void,
        newval: gpointer,
    ) -> gpointer;
}
extern "C" {
    pub fn g_atomic_pointer_add(atomic: *mut ::std::os::raw::c_void, val: gssize) -> gssize;
}
extern "C" {
    pub fn g_atomic_pointer_and(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
extern "C" {
    pub fn g_atomic_pointer_or(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
extern "C" {
    pub fn g_atomic_pointer_xor(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
extern "C" {
    pub fn g_atomic_int_exchange_and_add(atomic: *mut gint, val: gint) -> gint;
}
pub type __gnuc_va_list = __builtin_va_list;
pub type GQuark = guint32;
extern "C" {
    pub fn g_quark_try_string(string: *const gchar) -> GQuark;
}
extern "C" {
    pub fn g_quark_from_static_string(string: *const gchar) -> GQuark;
}
extern "C" {
    pub fn g_quark_from_string(string: *const gchar) -> GQuark;
}
extern "C" {
    pub fn g_quark_to_string(quark: GQuark) -> *const gchar;
}
extern "C" {
    pub fn g_intern_string(string: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_intern_static_string(string: *const gchar) -> *const gchar;
}
#[doc = " GError:\n @domain: error domain, e.g. %G_FILE_ERROR\n @code: error code, e.g. %G_FILE_ERROR_NOENT\n @message: human-readable informative error message\n\n The `GError` structure contains information about\n an error that has occurred."]
pub type GError = _GError;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GError {
    pub domain: GQuark,
    pub code: gint,
    pub message: *mut gchar,
}
#[test]
fn bindgen_test_layout__GError() {
    const UNINIT: ::std::mem::MaybeUninit<_GError> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GError>(),
        16usize,
        concat!("Size of: ", stringify!(_GError))
    );
    assert_eq!(
        ::std::mem::align_of::<_GError>(),
        8usize,
        concat!("Alignment of ", stringify!(_GError))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).domain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(message)
        )
    );
}
#[doc = " GErrorInitFunc:\n @error: extended error\n\n Specifies the type of function which is called just after an\n extended error instance is created and its fields filled. It should\n only initialize the fields in the private data, which can be\n received with the generated `*_get_private()` function.\n\n Normally, it is better to use G_DEFINE_EXTENDED_ERROR(), as it\n already takes care of getting the private data from @error.\n\n Since: 2.68"]
pub type GErrorInitFunc = ::std::option::Option<unsafe extern "C" fn(error: *mut GError)>;
#[doc = " GErrorCopyFunc:\n @src_error: source extended error\n @dest_error: destination extended error\n\n Specifies the type of function which is called when an extended\n error instance is copied. It is passed the pointer to the\n destination error and source error, and should copy only the fields\n of the private data from @src_error to @dest_error.\n\n Normally, it is better to use G_DEFINE_EXTENDED_ERROR(), as it\n already takes care of getting the private data from @src_error and\n @dest_error.\n\n Since: 2.68"]
pub type GErrorCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(src_error: *const GError, dest_error: *mut GError)>;
#[doc = " GErrorClearFunc:\n @error: extended error to clear\n\n Specifies the type of function which is called when an extended\n error instance is freed. It is passed the error pointer about to be\n freed, and should free the error's private data fields.\n\n Normally, it is better to use G_DEFINE_EXTENDED_ERROR(), as it\n already takes care of getting the private data from @error.\n\n Since: 2.68"]
pub type GErrorClearFunc = ::std::option::Option<unsafe extern "C" fn(error: *mut GError)>;
extern "C" {
    pub fn g_error_domain_register_static(
        error_type_name: *const ::std::os::raw::c_char,
        error_type_private_size: gsize,
        error_type_init: GErrorInitFunc,
        error_type_copy: GErrorCopyFunc,
        error_type_clear: GErrorClearFunc,
    ) -> GQuark;
}
extern "C" {
    pub fn g_error_domain_register(
        error_type_name: *const ::std::os::raw::c_char,
        error_type_private_size: gsize,
        error_type_init: GErrorInitFunc,
        error_type_copy: GErrorCopyFunc,
        error_type_clear: GErrorClearFunc,
    ) -> GQuark;
}
extern "C" {
    pub fn g_error_new(domain: GQuark, code: gint, format: *const gchar, ...) -> *mut GError;
}
extern "C" {
    pub fn g_error_new_literal(domain: GQuark, code: gint, message: *const gchar) -> *mut GError;
}
extern "C" {
    pub fn g_error_new_valist(
        domain: GQuark,
        code: gint,
        format: *const gchar,
        args: va_list,
    ) -> *mut GError;
}
extern "C" {
    pub fn g_error_free(error: *mut GError);
}
extern "C" {
    pub fn g_error_copy(error: *const GError) -> *mut GError;
}
extern "C" {
    pub fn g_error_matches(error: *const GError, domain: GQuark, code: gint) -> gboolean;
}
extern "C" {
    pub fn g_set_error(
        err: *mut *mut GError,
        domain: GQuark,
        code: gint,
        format: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_set_error_literal(
        err: *mut *mut GError,
        domain: GQuark,
        code: gint,
        message: *const gchar,
    );
}
extern "C" {
    pub fn g_propagate_error(dest: *mut *mut GError, src: *mut GError);
}
extern "C" {
    pub fn g_clear_error(err: *mut *mut GError);
}
extern "C" {
    pub fn g_prefix_error(err: *mut *mut GError, format: *const gchar, ...);
}
extern "C" {
    pub fn g_prefix_error_literal(err: *mut *mut GError, prefix: *const gchar);
}
extern "C" {
    pub fn g_propagate_prefixed_error(
        dest: *mut *mut GError,
        src: *mut GError,
        format: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_get_user_name() -> *const gchar;
}
extern "C" {
    pub fn g_get_real_name() -> *const gchar;
}
extern "C" {
    pub fn g_get_home_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_tmp_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_host_name() -> *const gchar;
}
extern "C" {
    pub fn g_get_prgname() -> *const gchar;
}
extern "C" {
    pub fn g_set_prgname(prgname: *const gchar);
}
extern "C" {
    pub fn g_get_application_name() -> *const gchar;
}
extern "C" {
    pub fn g_set_application_name(application_name: *const gchar);
}
extern "C" {
    pub fn g_get_os_info(key_name: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_reload_user_special_dirs_cache();
}
extern "C" {
    pub fn g_get_user_data_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_user_config_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_user_cache_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_user_state_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_system_data_dirs() -> *const *const gchar;
}
extern "C" {
    pub fn g_win32_get_system_data_dirs_for_module(
        address_of_function: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> *const *const gchar;
}
extern "C" {
    pub fn g_get_system_config_dirs() -> *const *const gchar;
}
extern "C" {
    pub fn g_get_user_runtime_dir() -> *const gchar;
}
pub const GUserDirectory_G_USER_DIRECTORY_DESKTOP: GUserDirectory = 0;
pub const GUserDirectory_G_USER_DIRECTORY_DOCUMENTS: GUserDirectory = 1;
pub const GUserDirectory_G_USER_DIRECTORY_DOWNLOAD: GUserDirectory = 2;
pub const GUserDirectory_G_USER_DIRECTORY_MUSIC: GUserDirectory = 3;
pub const GUserDirectory_G_USER_DIRECTORY_PICTURES: GUserDirectory = 4;
pub const GUserDirectory_G_USER_DIRECTORY_PUBLIC_SHARE: GUserDirectory = 5;
pub const GUserDirectory_G_USER_DIRECTORY_TEMPLATES: GUserDirectory = 6;
pub const GUserDirectory_G_USER_DIRECTORY_VIDEOS: GUserDirectory = 7;
pub const GUserDirectory_G_USER_N_DIRECTORIES: GUserDirectory = 8;
#[doc = " GUserDirectory:\n @G_USER_DIRECTORY_DESKTOP: the user's Desktop directory\n @G_USER_DIRECTORY_DOCUMENTS: the user's Documents directory\n @G_USER_DIRECTORY_DOWNLOAD: the user's Downloads directory\n @G_USER_DIRECTORY_MUSIC: the user's Music directory\n @G_USER_DIRECTORY_PICTURES: the user's Pictures directory\n @G_USER_DIRECTORY_PUBLIC_SHARE: the user's shared directory\n @G_USER_DIRECTORY_TEMPLATES: the user's Templates directory\n @G_USER_DIRECTORY_VIDEOS: the user's Movies directory\n @G_USER_N_DIRECTORIES: the number of enum values\n\n These are logical ids for special directories which are defined\n depending on the platform used. You should use g_get_user_special_dir()\n to retrieve the full path associated to the logical id.\n\n The #GUserDirectory enumeration can be extended at later date. Not\n every platform has a directory for every logical id in this\n enumeration.\n\n Since: 2.14"]
pub type GUserDirectory = ::std::os::raw::c_int;
extern "C" {
    pub fn g_get_user_special_dir(directory: GUserDirectory) -> *const gchar;
}
#[doc = " GDebugKey:\n @key: the string\n @value: the flag\n\n Associates a string with a bit flag.\n Used in g_parse_debug_string()."]
pub type GDebugKey = _GDebugKey;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDebugKey {
    pub key: *const gchar,
    pub value: guint,
}
#[test]
fn bindgen_test_layout__GDebugKey() {
    const UNINIT: ::std::mem::MaybeUninit<_GDebugKey> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDebugKey>(),
        16usize,
        concat!("Size of: ", stringify!(_GDebugKey))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDebugKey>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDebugKey))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDebugKey),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDebugKey),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    pub fn g_parse_debug_string(
        string: *const gchar,
        keys: *const GDebugKey,
        nkeys: guint,
    ) -> guint;
}
extern "C" {
    pub fn g_snprintf(string: *mut gchar, n: gulong, format: *const gchar, ...) -> gint;
}
extern "C" {
    pub fn g_vsnprintf(string: *mut gchar, n: gulong, format: *const gchar, args: va_list) -> gint;
}
extern "C" {
    pub fn g_nullify_pointer(nullify_location: *mut gpointer);
}
pub const GFormatSizeFlags_G_FORMAT_SIZE_DEFAULT: GFormatSizeFlags = 0;
pub const GFormatSizeFlags_G_FORMAT_SIZE_LONG_FORMAT: GFormatSizeFlags = 1;
pub const GFormatSizeFlags_G_FORMAT_SIZE_IEC_UNITS: GFormatSizeFlags = 2;
pub const GFormatSizeFlags_G_FORMAT_SIZE_BITS: GFormatSizeFlags = 4;
pub const GFormatSizeFlags_G_FORMAT_SIZE_ONLY_VALUE: GFormatSizeFlags = 8;
pub const GFormatSizeFlags_G_FORMAT_SIZE_ONLY_UNIT: GFormatSizeFlags = 16;
pub type GFormatSizeFlags = ::std::os::raw::c_int;
extern "C" {
    pub fn g_format_size_full(size: guint64, flags: GFormatSizeFlags) -> *mut gchar;
}
extern "C" {
    pub fn g_format_size(size: guint64) -> *mut gchar;
}
extern "C" {
    pub fn g_format_size_for_display(size: goffset) -> *mut gchar;
}
#[doc = " GVoidFunc:\n\n Declares a type of function which takes no arguments\n and has no return value. It is used to specify the type\n function passed to g_atexit()."]
pub type GVoidFunc = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn g_atexit(func: GVoidFunc);
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_find_program_in_path(program: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_bit_nth_lsf(mask: gulong, nth_bit: gint) -> gint;
}
extern "C" {
    pub fn g_bit_nth_msf(mask: gulong, nth_bit: gint) -> gint;
}
extern "C" {
    pub fn g_bit_storage(number: gulong) -> guint;
}
extern "C" {
    pub fn g_abort() -> !;
}
extern "C" {
    pub fn g_thread_error_quark() -> GQuark;
}
pub const GThreadError_G_THREAD_ERROR_AGAIN: GThreadError = 0;
pub type GThreadError = ::std::os::raw::c_int;
pub type GThreadFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer) -> gpointer>;
pub type GThread = _GThread;
pub type GMutex = _GMutex;
pub type GRecMutex = _GRecMutex;
pub type GRWLock = _GRWLock;
pub type GCond = _GCond;
pub type GPrivate = _GPrivate;
pub type GOnce = _GOnce;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GMutex() {
    const UNINIT: ::std::mem::MaybeUninit<_GMutex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMutex>(),
        8usize,
        concat!("Size of: ", stringify!(_GMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMutex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMutex),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMutex),
            "::",
            stringify!(i)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRWLock {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GRWLock() {
    const UNINIT: ::std::mem::MaybeUninit<_GRWLock> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GRWLock>(),
        16usize,
        concat!("Size of: ", stringify!(_GRWLock))
    );
    assert_eq!(
        ::std::mem::align_of::<_GRWLock>(),
        8usize,
        concat!("Alignment of ", stringify!(_GRWLock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRWLock),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRWLock),
            "::",
            stringify!(i)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCond {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GCond() {
    const UNINIT: ::std::mem::MaybeUninit<_GCond> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GCond>(),
        16usize,
        concat!("Size of: ", stringify!(_GCond))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCond>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCond))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_GCond), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_GCond), "::", stringify!(i))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRecMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GRecMutex() {
    const UNINIT: ::std::mem::MaybeUninit<_GRecMutex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GRecMutex>(),
        16usize,
        concat!("Size of: ", stringify!(_GRecMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<_GRecMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GRecMutex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRecMutex),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRecMutex),
            "::",
            stringify!(i)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPrivate {
    pub p: gpointer,
    pub notify: GDestroyNotify,
    pub future: [gpointer; 2usize],
}
#[test]
fn bindgen_test_layout__GPrivate() {
    const UNINIT: ::std::mem::MaybeUninit<_GPrivate> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GPrivate>(),
        32usize,
        concat!("Size of: ", stringify!(_GPrivate))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPrivate>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPrivate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPrivate),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPrivate),
            "::",
            stringify!(notify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).future) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPrivate),
            "::",
            stringify!(future)
        )
    );
}
pub const GOnceStatus_G_ONCE_STATUS_NOTCALLED: GOnceStatus = 0;
pub const GOnceStatus_G_ONCE_STATUS_PROGRESS: GOnceStatus = 1;
pub const GOnceStatus_G_ONCE_STATUS_READY: GOnceStatus = 2;
pub type GOnceStatus = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOnce {
    pub status: GOnceStatus,
    pub retval: gpointer,
}
#[test]
fn bindgen_test_layout__GOnce() {
    const UNINIT: ::std::mem::MaybeUninit<_GOnce> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GOnce>(),
        16usize,
        concat!("Size of: ", stringify!(_GOnce))
    );
    assert_eq!(
        ::std::mem::align_of::<_GOnce>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOnce))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOnce),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retval) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOnce),
            "::",
            stringify!(retval)
        )
    );
}
extern "C" {
    pub fn g_thread_ref(thread: *mut GThread) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_unref(thread: *mut GThread);
}
extern "C" {
    pub fn g_thread_new(name: *const gchar, func: GThreadFunc, data: gpointer) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_try_new(
        name: *const gchar,
        func: GThreadFunc,
        data: gpointer,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_self() -> *mut GThread;
}
extern "C" {
    pub fn g_thread_exit(retval: gpointer) -> !;
}
extern "C" {
    pub fn g_thread_join(thread: *mut GThread) -> gpointer;
}
extern "C" {
    pub fn g_thread_yield();
}
extern "C" {
    pub fn g_mutex_init(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_mutex_clear(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_mutex_lock(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_mutex_trylock(mutex: *mut GMutex) -> gboolean;
}
extern "C" {
    pub fn g_mutex_unlock(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_rw_lock_init(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_clear(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_writer_lock(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_writer_trylock(rw_lock: *mut GRWLock) -> gboolean;
}
extern "C" {
    pub fn g_rw_lock_writer_unlock(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_reader_lock(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_reader_trylock(rw_lock: *mut GRWLock) -> gboolean;
}
extern "C" {
    pub fn g_rw_lock_reader_unlock(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rec_mutex_init(rec_mutex: *mut GRecMutex);
}
extern "C" {
    pub fn g_rec_mutex_clear(rec_mutex: *mut GRecMutex);
}
extern "C" {
    pub fn g_rec_mutex_lock(rec_mutex: *mut GRecMutex);
}
extern "C" {
    pub fn g_rec_mutex_trylock(rec_mutex: *mut GRecMutex) -> gboolean;
}
extern "C" {
    pub fn g_rec_mutex_unlock(rec_mutex: *mut GRecMutex);
}
extern "C" {
    pub fn g_cond_init(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_clear(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_wait(cond: *mut GCond, mutex: *mut GMutex);
}
extern "C" {
    pub fn g_cond_signal(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_broadcast(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_wait_until(cond: *mut GCond, mutex: *mut GMutex, end_time: gint64) -> gboolean;
}
extern "C" {
    pub fn g_private_get(key: *mut GPrivate) -> gpointer;
}
extern "C" {
    pub fn g_private_set(key: *mut GPrivate, value: gpointer);
}
extern "C" {
    pub fn g_private_replace(key: *mut GPrivate, value: gpointer);
}
extern "C" {
    pub fn g_once_impl(once: *mut GOnce, func: GThreadFunc, arg: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_once_init_enter(location: *mut ::std::os::raw::c_void) -> gboolean;
}
extern "C" {
    pub fn g_once_init_leave(location: *mut ::std::os::raw::c_void, result: gsize);
}
extern "C" {
    pub fn g_get_num_processors() -> guint;
}
#[doc = " GMutexLocker:\n\n Opaque type. See g_mutex_locker_new() for details.\n Since: 2.44"]
pub type GMutexLocker = ::std::os::raw::c_void;
#[doc = " GRecMutexLocker:\n\n Opaque type. See g_rec_mutex_locker_new() for details.\n Since: 2.60"]
pub type GRecMutexLocker = ::std::os::raw::c_void;
#[doc = " GRWLockWriterLocker:\n\n Opaque type. See g_rw_lock_writer_locker_new() for details.\n Since: 2.62"]
pub type GRWLockWriterLocker = ::std::os::raw::c_void;
#[doc = " GRWLockReaderLocker:\n\n Opaque type. See g_rw_lock_reader_locker_new() for details.\n Since: 2.62"]
pub type GRWLockReaderLocker = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAsyncQueue {
    _unused: [u8; 0],
}
pub type GAsyncQueue = _GAsyncQueue;
extern "C" {
    pub fn g_async_queue_new() -> *mut GAsyncQueue;
}
extern "C" {
    pub fn g_async_queue_new_full(item_free_func: GDestroyNotify) -> *mut GAsyncQueue;
}
extern "C" {
    pub fn g_async_queue_lock(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_unlock(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_ref(queue: *mut GAsyncQueue) -> *mut GAsyncQueue;
}
extern "C" {
    pub fn g_async_queue_unref(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_ref_unlocked(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_unref_and_unlock(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_push(queue: *mut GAsyncQueue, data: gpointer);
}
extern "C" {
    pub fn g_async_queue_push_unlocked(queue: *mut GAsyncQueue, data: gpointer);
}
extern "C" {
    pub fn g_async_queue_push_sorted(
        queue: *mut GAsyncQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_async_queue_push_sorted_unlocked(
        queue: *mut GAsyncQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_async_queue_pop(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_try_pop(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_try_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_timeout_pop(queue: *mut GAsyncQueue, timeout: guint64) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_timeout_pop_unlocked(
        queue: *mut GAsyncQueue,
        timeout: guint64,
    ) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_length(queue: *mut GAsyncQueue) -> gint;
}
extern "C" {
    pub fn g_async_queue_length_unlocked(queue: *mut GAsyncQueue) -> gint;
}
extern "C" {
    pub fn g_async_queue_sort(queue: *mut GAsyncQueue, func: GCompareDataFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_async_queue_sort_unlocked(
        queue: *mut GAsyncQueue,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_async_queue_remove(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_async_queue_remove_unlocked(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_async_queue_push_front(queue: *mut GAsyncQueue, item: gpointer);
}
extern "C" {
    pub fn g_async_queue_push_front_unlocked(queue: *mut GAsyncQueue, item: gpointer);
}
extern "C" {
    pub fn g_async_queue_timed_pop(queue: *mut GAsyncQueue, end_time: *mut GTimeVal) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_timed_pop_unlocked(
        queue: *mut GAsyncQueue,
        end_time: *mut GTimeVal,
    ) -> gpointer;
}
pub type sig_atomic_t = ::std::os::raw::c_int;
pub type _crt_signal_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
extern "C" {
    pub fn __pxcptinfoptrs() -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn signal(_Signal: ::std::os::raw::c_int, _Function: _crt_signal_t) -> _crt_signal_t;
}
extern "C" {
    pub fn raise(_Signal: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_on_error_query(prg_name: *const gchar);
}
extern "C" {
    pub fn g_on_error_stack_trace(prg_name: *const gchar);
}
extern "C" {
    pub fn g_base64_encode_step(
        in_: *const guchar,
        len: gsize,
        break_lines: gboolean,
        out: *mut gchar,
        state: *mut gint,
        save: *mut gint,
    ) -> gsize;
}
extern "C" {
    pub fn g_base64_encode_close(
        break_lines: gboolean,
        out: *mut gchar,
        state: *mut gint,
        save: *mut gint,
    ) -> gsize;
}
extern "C" {
    pub fn g_base64_encode(data: *const guchar, len: gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_base64_decode_step(
        in_: *const gchar,
        len: gsize,
        out: *mut guchar,
        state: *mut gint,
        save: *mut guint,
    ) -> gsize;
}
extern "C" {
    pub fn g_base64_decode(text: *const gchar, out_len: *mut gsize) -> *mut guchar;
}
extern "C" {
    pub fn g_base64_decode_inplace(text: *mut gchar, out_len: *mut gsize) -> *mut guchar;
}
extern "C" {
    pub fn g_bit_lock(address: *mut gint, lock_bit: gint);
}
extern "C" {
    pub fn g_bit_trylock(address: *mut gint, lock_bit: gint) -> gboolean;
}
extern "C" {
    pub fn g_bit_unlock(address: *mut gint, lock_bit: gint);
}
extern "C" {
    pub fn g_pointer_bit_lock(address: *mut ::std::os::raw::c_void, lock_bit: gint);
}
extern "C" {
    pub fn g_pointer_bit_trylock(address: *mut ::std::os::raw::c_void, lock_bit: gint) -> gboolean;
}
extern "C" {
    pub fn g_pointer_bit_unlock(address: *mut ::std::os::raw::c_void, lock_bit: gint);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimeZone {
    _unused: [u8; 0],
}
pub type GTimeZone = _GTimeZone;
pub const GTimeType_G_TIME_TYPE_STANDARD: GTimeType = 0;
pub const GTimeType_G_TIME_TYPE_DAYLIGHT: GTimeType = 1;
pub const GTimeType_G_TIME_TYPE_UNIVERSAL: GTimeType = 2;
#[doc = " GTimeType:\n @G_TIME_TYPE_STANDARD: the time is in local standard time\n @G_TIME_TYPE_DAYLIGHT: the time is in local daylight time\n @G_TIME_TYPE_UNIVERSAL: the time is in UTC\n\n Disambiguates a given time in two ways.\n\n First, specifies if the given time is in universal or local time.\n\n Second, if the time is in local time, specifies if it is local\n standard time or local daylight time.  This is important for the case\n where the same local time occurs twice (during daylight savings time\n transitions, for example)."]
pub type GTimeType = ::std::os::raw::c_int;
extern "C" {
    pub fn g_time_zone_new(identifier: *const gchar) -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_new_identifier(identifier: *const gchar) -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_new_utc() -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_new_local() -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_new_offset(seconds: gint32) -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_ref(tz: *mut GTimeZone) -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_unref(tz: *mut GTimeZone);
}
extern "C" {
    pub fn g_time_zone_find_interval(tz: *mut GTimeZone, type_: GTimeType, time_: gint64) -> gint;
}
extern "C" {
    pub fn g_time_zone_adjust_time(
        tz: *mut GTimeZone,
        type_: GTimeType,
        time_: *mut gint64,
    ) -> gint;
}
extern "C" {
    pub fn g_time_zone_get_abbreviation(tz: *mut GTimeZone, interval: gint) -> *const gchar;
}
extern "C" {
    pub fn g_time_zone_get_offset(tz: *mut GTimeZone, interval: gint) -> gint32;
}
extern "C" {
    pub fn g_time_zone_is_dst(tz: *mut GTimeZone, interval: gint) -> gboolean;
}
extern "C" {
    pub fn g_time_zone_get_identifier(tz: *mut GTimeZone) -> *const gchar;
}
#[doc = " GTimeSpan:\n\n A value representing an interval of time, in microseconds.\n\n Since: 2.26"]
pub type GTimeSpan = gint64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDateTime {
    _unused: [u8; 0],
}
#[doc = " GDateTime:\n\n An opaque structure that represents a date and time, including a time zone.\n\n Since: 2.26"]
pub type GDateTime = _GDateTime;
extern "C" {
    pub fn g_date_time_unref(datetime: *mut GDateTime);
}
extern "C" {
    pub fn g_date_time_ref(datetime: *mut GDateTime) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_now(tz: *mut GTimeZone) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_now_local() -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_now_utc() -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_unix_local(t: gint64) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_unix_utc(t: gint64) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_timeval_local(tv: *const GTimeVal) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_timeval_utc(tv: *const GTimeVal) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_iso8601(
        text: *const gchar,
        default_tz: *mut GTimeZone,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new(
        tz: *mut GTimeZone,
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_local(
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_utc(
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add(datetime: *mut GDateTime, timespan: GTimeSpan) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_years(datetime: *mut GDateTime, years: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_months(datetime: *mut GDateTime, months: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_weeks(datetime: *mut GDateTime, weeks: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_days(datetime: *mut GDateTime, days: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_hours(datetime: *mut GDateTime, hours: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_minutes(datetime: *mut GDateTime, minutes: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_seconds(datetime: *mut GDateTime, seconds: gdouble) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_full(
        datetime: *mut GDateTime,
        years: gint,
        months: gint,
        days: gint,
        hours: gint,
        minutes: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_compare(dt1: gconstpointer, dt2: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_date_time_difference(end: *mut GDateTime, begin: *mut GDateTime) -> GTimeSpan;
}
extern "C" {
    pub fn g_date_time_hash(datetime: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_date_time_equal(dt1: gconstpointer, dt2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_date_time_get_ymd(
        datetime: *mut GDateTime,
        year: *mut gint,
        month: *mut gint,
        day: *mut gint,
    );
}
extern "C" {
    pub fn g_date_time_get_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_month(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_day_of_month(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_week_numbering_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_week_of_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_day_of_week(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_day_of_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_hour(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_minute(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_second(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_microsecond(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_seconds(datetime: *mut GDateTime) -> gdouble;
}
extern "C" {
    pub fn g_date_time_to_unix(datetime: *mut GDateTime) -> gint64;
}
extern "C" {
    pub fn g_date_time_to_timeval(datetime: *mut GDateTime, tv: *mut GTimeVal) -> gboolean;
}
extern "C" {
    pub fn g_date_time_get_utc_offset(datetime: *mut GDateTime) -> GTimeSpan;
}
extern "C" {
    pub fn g_date_time_get_timezone(datetime: *mut GDateTime) -> *mut GTimeZone;
}
extern "C" {
    pub fn g_date_time_get_timezone_abbreviation(datetime: *mut GDateTime) -> *const gchar;
}
extern "C" {
    pub fn g_date_time_is_daylight_savings(datetime: *mut GDateTime) -> gboolean;
}
extern "C" {
    pub fn g_date_time_to_timezone(datetime: *mut GDateTime, tz: *mut GTimeZone) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_to_local(datetime: *mut GDateTime) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_to_utc(datetime: *mut GDateTime) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_format(datetime: *mut GDateTime, format: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_date_time_format_iso8601(datetime: *mut GDateTime) -> *mut gchar;
}
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_INVALID_URI: GBookmarkFileError = 0;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_INVALID_VALUE: GBookmarkFileError = 1;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: GBookmarkFileError = 2;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: GBookmarkFileError = 3;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_READ: GBookmarkFileError = 4;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: GBookmarkFileError = 5;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_WRITE: GBookmarkFileError = 6;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: GBookmarkFileError = 7;
#[doc = " GBookmarkFileError:\n @G_BOOKMARK_FILE_ERROR_INVALID_URI: URI was ill-formed\n @G_BOOKMARK_FILE_ERROR_INVALID_VALUE: a requested field was not found\n @G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: a requested application did\n     not register a bookmark\n @G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: a requested URI was not found\n @G_BOOKMARK_FILE_ERROR_READ: document was ill formed\n @G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: the text being parsed was\n     in an unknown encoding\n @G_BOOKMARK_FILE_ERROR_WRITE: an error occurred while writing\n @G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: requested file was not found\n\n Error codes returned by bookmark file parsing."]
pub type GBookmarkFileError = ::std::os::raw::c_int;
extern "C" {
    pub fn g_bookmark_file_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBookmarkFile {
    _unused: [u8; 0],
}
#[doc = " GBookmarkFile:\n\n An opaque data structure representing a set of bookmarks."]
pub type GBookmarkFile = _GBookmarkFile;
extern "C" {
    pub fn g_bookmark_file_new() -> *mut GBookmarkFile;
}
extern "C" {
    pub fn g_bookmark_file_free(bookmark: *mut GBookmarkFile);
}
extern "C" {
    pub fn g_bookmark_file_copy(bookmark: *mut GBookmarkFile) -> *mut GBookmarkFile;
}
extern "C" {
    pub fn g_bookmark_file_load_from_file(
        bookmark: *mut GBookmarkFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_load_from_data(
        bookmark: *mut GBookmarkFile,
        data: *const gchar,
        length: gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_load_from_data_dirs(
        bookmark: *mut GBookmarkFile,
        file: *const gchar,
        full_path: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_to_data(
        bookmark: *mut GBookmarkFile,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_to_file(
        bookmark: *mut GBookmarkFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_title(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        title: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_title(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_set_description(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        description: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_description(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_set_mime_type(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        mime_type: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_mime_type(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_set_groups(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        groups: *mut *const gchar,
        length: gsize,
    );
}
extern "C" {
    pub fn g_bookmark_file_add_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_has_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_groups(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_add_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_has_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_applications(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_set_app_info(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *const gchar,
        count: gint,
        stamp: time_t,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_application_info(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        exec: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_int,
        stamp: *mut GDateTime,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_app_info(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *mut *mut gchar,
        count: *mut guint,
        stamp: *mut time_t,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_application_info(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        exec: *mut *mut ::std::os::raw::c_char,
        count: *mut ::std::os::raw::c_uint,
        stamp: *mut *mut GDateTime,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_is_private(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        is_private: gboolean,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_is_private(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_icon(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        href: *const gchar,
        mime_type: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_icon(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        href: *mut *mut gchar,
        mime_type: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_added(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        added: time_t,
    );
}
extern "C" {
    pub fn g_bookmark_file_set_added_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        added: *mut GDateTime,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_added(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
extern "C" {
    pub fn g_bookmark_file_get_added_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_bookmark_file_set_modified(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        modified: time_t,
    );
}
extern "C" {
    pub fn g_bookmark_file_set_modified_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        modified: *mut GDateTime,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_modified(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
extern "C" {
    pub fn g_bookmark_file_get_modified_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_bookmark_file_set_visited(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        visited: time_t,
    );
}
extern "C" {
    pub fn g_bookmark_file_set_visited_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        visited: *mut GDateTime,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_visited(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
extern "C" {
    pub fn g_bookmark_file_get_visited_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_bookmark_file_has_item(bookmark: *mut GBookmarkFile, uri: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_size(bookmark: *mut GBookmarkFile) -> gint;
}
extern "C" {
    pub fn g_bookmark_file_get_uris(
        bookmark: *mut GBookmarkFile,
        length: *mut gsize,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_remove_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_remove_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_remove_item(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_move_item(
        bookmark: *mut GBookmarkFile,
        old_uri: *const gchar,
        new_uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bytes_new(data: gconstpointer, size: gsize) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_new_take(data: gpointer, size: gsize) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_new_static(data: gconstpointer, size: gsize) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_new_with_free_func(
        data: gconstpointer,
        size: gsize,
        free_func: GDestroyNotify,
        user_data: gpointer,
    ) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_new_from_bytes(bytes: *mut GBytes, offset: gsize, length: gsize) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_get_data(bytes: *mut GBytes, size: *mut gsize) -> gconstpointer;
}
extern "C" {
    pub fn g_bytes_get_size(bytes: *mut GBytes) -> gsize;
}
extern "C" {
    pub fn g_bytes_ref(bytes: *mut GBytes) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_unref(bytes: *mut GBytes);
}
extern "C" {
    pub fn g_bytes_unref_to_data(bytes: *mut GBytes, size: *mut gsize) -> gpointer;
}
extern "C" {
    pub fn g_bytes_unref_to_array(bytes: *mut GBytes) -> *mut GByteArray;
}
extern "C" {
    pub fn g_bytes_hash(bytes: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_bytes_equal(bytes1: gconstpointer, bytes2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_bytes_compare(bytes1: gconstpointer, bytes2: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_bytes_get_region(
        bytes: *mut GBytes,
        element_size: gsize,
        offset: gsize,
        n_elements: gsize,
    ) -> gconstpointer;
}
extern "C" {
    pub fn g_get_charset(charset: *mut *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    pub fn g_get_codeset() -> *mut gchar;
}
extern "C" {
    pub fn g_get_console_charset(charset: *mut *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    pub fn g_get_language_names() -> *const *const gchar;
}
extern "C" {
    pub fn g_get_language_names_with_category(category_name: *const gchar) -> *const *const gchar;
}
extern "C" {
    pub fn g_get_locale_variants(locale: *const gchar) -> *mut *mut gchar;
}
pub const GChecksumType_G_CHECKSUM_MD5: GChecksumType = 0;
pub const GChecksumType_G_CHECKSUM_SHA1: GChecksumType = 1;
pub const GChecksumType_G_CHECKSUM_SHA256: GChecksumType = 2;
pub const GChecksumType_G_CHECKSUM_SHA512: GChecksumType = 3;
pub const GChecksumType_G_CHECKSUM_SHA384: GChecksumType = 4;
#[doc = " GChecksumType:\n @G_CHECKSUM_MD5: Use the MD5 hashing algorithm\n @G_CHECKSUM_SHA1: Use the SHA-1 hashing algorithm\n @G_CHECKSUM_SHA256: Use the SHA-256 hashing algorithm\n @G_CHECKSUM_SHA384: Use the SHA-384 hashing algorithm (Since: 2.51)\n @G_CHECKSUM_SHA512: Use the SHA-512 hashing algorithm (Since: 2.36)\n\n The hashing algorithm to be used by #GChecksum when performing the\n digest of some data.\n\n Note that the #GChecksumType enumeration may be extended at a later\n date to include new hashing algorithm types.\n\n Since: 2.16"]
pub type GChecksumType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GChecksum {
    _unused: [u8; 0],
}
#[doc = " GChecksum:\n\n An opaque structure representing a checksumming operation.\n\n To create a new GChecksum, use g_checksum_new(). To free\n a GChecksum, use g_checksum_free().\n\n Since: 2.16"]
pub type GChecksum = _GChecksum;
extern "C" {
    pub fn g_checksum_type_get_length(checksum_type: GChecksumType) -> gssize;
}
extern "C" {
    pub fn g_checksum_new(checksum_type: GChecksumType) -> *mut GChecksum;
}
extern "C" {
    pub fn g_checksum_reset(checksum: *mut GChecksum);
}
extern "C" {
    pub fn g_checksum_copy(checksum: *const GChecksum) -> *mut GChecksum;
}
extern "C" {
    pub fn g_checksum_free(checksum: *mut GChecksum);
}
extern "C" {
    pub fn g_checksum_update(checksum: *mut GChecksum, data: *const guchar, length: gssize);
}
extern "C" {
    pub fn g_checksum_get_string(checksum: *mut GChecksum) -> *const gchar;
}
extern "C" {
    pub fn g_checksum_get_digest(
        checksum: *mut GChecksum,
        buffer: *mut guint8,
        digest_len: *mut gsize,
    );
}
extern "C" {
    pub fn g_compute_checksum_for_data(
        checksum_type: GChecksumType,
        data: *const guchar,
        length: gsize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_compute_checksum_for_string(
        checksum_type: GChecksumType,
        str_: *const gchar,
        length: gssize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_compute_checksum_for_bytes(
        checksum_type: GChecksumType,
        data: *mut GBytes,
    ) -> *mut gchar;
}
pub const GConvertError_G_CONVERT_ERROR_NO_CONVERSION: GConvertError = 0;
pub const GConvertError_G_CONVERT_ERROR_ILLEGAL_SEQUENCE: GConvertError = 1;
pub const GConvertError_G_CONVERT_ERROR_FAILED: GConvertError = 2;
pub const GConvertError_G_CONVERT_ERROR_PARTIAL_INPUT: GConvertError = 3;
pub const GConvertError_G_CONVERT_ERROR_BAD_URI: GConvertError = 4;
pub const GConvertError_G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: GConvertError = 5;
pub const GConvertError_G_CONVERT_ERROR_NO_MEMORY: GConvertError = 6;
pub const GConvertError_G_CONVERT_ERROR_EMBEDDED_NUL: GConvertError = 7;
#[doc = " GConvertError:\n @G_CONVERT_ERROR_NO_CONVERSION: Conversion between the requested character\n     sets is not supported.\n @G_CONVERT_ERROR_ILLEGAL_SEQUENCE: Invalid byte sequence in conversion input;\n    or the character sequence could not be represented in the target\n    character set.\n @G_CONVERT_ERROR_FAILED: Conversion failed for some reason.\n @G_CONVERT_ERROR_PARTIAL_INPUT: Partial character sequence at end of input.\n @G_CONVERT_ERROR_BAD_URI: URI is invalid.\n @G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: Pathname is not an absolute path.\n @G_CONVERT_ERROR_NO_MEMORY: No memory available. Since: 2.40\n @G_CONVERT_ERROR_EMBEDDED_NUL: An embedded NUL character is present in\n     conversion output where a NUL-terminated string is expected.\n     Since: 2.56\n\n Error codes returned by character set conversion routines."]
pub type GConvertError = ::std::os::raw::c_int;
extern "C" {
    pub fn g_convert_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIConv {
    _unused: [u8; 0],
}
#[doc = " GIConv: (skip)\n\n The GIConv struct wraps an iconv() conversion descriptor. It contains\n private data and should only be accessed using the following functions."]
pub type GIConv = *mut _GIConv;
extern "C" {
    pub fn g_iconv_open(to_codeset: *const gchar, from_codeset: *const gchar) -> GIConv;
}
extern "C" {
    pub fn g_iconv(
        converter: GIConv,
        inbuf: *mut *mut gchar,
        inbytes_left: *mut gsize,
        outbuf: *mut *mut gchar,
        outbytes_left: *mut gsize,
    ) -> gsize;
}
extern "C" {
    pub fn g_iconv_close(converter: GIConv) -> gint;
}
extern "C" {
    pub fn g_convert(
        str_: *const gchar,
        len: gssize,
        to_codeset: *const gchar,
        from_codeset: *const gchar,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_convert_with_iconv(
        str_: *const gchar,
        len: gssize,
        converter: GIConv,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_convert_with_fallback(
        str_: *const gchar,
        len: gssize,
        to_codeset: *const gchar,
        from_codeset: *const gchar,
        fallback: *const gchar,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_locale_to_utf8(
        opsysstring: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_locale_from_utf8(
        utf8string: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_to_utf8(
        opsysstring: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_from_utf8(
        utf8string: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_from_uri(
        uri: *const gchar,
        hostname: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_to_uri(
        filename: *const gchar,
        hostname: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_display_name(filename: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_get_filename_charsets(filename_charsets: *mut *mut *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_filename_display_basename(filename: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_uri_list_extract_uris(uri_list: *const gchar) -> *mut *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GData {
    _unused: [u8; 0],
}
pub type GData = _GData;
pub type GDataForeachFunc = ::std::option::Option<
    unsafe extern "C" fn(key_id: GQuark, data: gpointer, user_data: gpointer),
>;
extern "C" {
    pub fn g_datalist_init(datalist: *mut *mut GData);
}
extern "C" {
    pub fn g_datalist_clear(datalist: *mut *mut GData);
}
extern "C" {
    pub fn g_datalist_id_get_data(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_datalist_id_set_data_full(
        datalist: *mut *mut GData,
        key_id: GQuark,
        data: gpointer,
        destroy_func: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_datalist_id_remove_multiple(
        datalist: *mut *mut GData,
        keys: *mut GQuark,
        n_keys: gsize,
    );
}
pub type GDuplicateFunc =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer) -> gpointer>;
extern "C" {
    pub fn g_datalist_id_dup_data(
        datalist: *mut *mut GData,
        key_id: GQuark,
        dup_func: GDuplicateFunc,
        user_data: gpointer,
    ) -> gpointer;
}
extern "C" {
    pub fn g_datalist_id_replace_data(
        datalist: *mut *mut GData,
        key_id: GQuark,
        oldval: gpointer,
        newval: gpointer,
        destroy: GDestroyNotify,
        old_destroy: *mut GDestroyNotify,
    ) -> gboolean;
}
extern "C" {
    pub fn g_datalist_id_remove_no_notify(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_datalist_foreach(
        datalist: *mut *mut GData,
        func: GDataForeachFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_datalist_set_flags(datalist: *mut *mut GData, flags: guint);
}
extern "C" {
    pub fn g_datalist_unset_flags(datalist: *mut *mut GData, flags: guint);
}
extern "C" {
    pub fn g_datalist_get_flags(datalist: *mut *mut GData) -> guint;
}
extern "C" {
    pub fn g_dataset_destroy(dataset_location: gconstpointer);
}
extern "C" {
    pub fn g_dataset_id_get_data(dataset_location: gconstpointer, key_id: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_datalist_get_data(datalist: *mut *mut GData, key: *const gchar) -> gpointer;
}
extern "C" {
    pub fn g_dataset_id_set_data_full(
        dataset_location: gconstpointer,
        key_id: GQuark,
        data: gpointer,
        destroy_func: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_dataset_id_remove_no_notify(
        dataset_location: gconstpointer,
        key_id: GQuark,
    ) -> gpointer;
}
extern "C" {
    pub fn g_dataset_foreach(
        dataset_location: gconstpointer,
        func: GDataForeachFunc,
        user_data: gpointer,
    );
}
pub type GTime = gint32;
pub type GDateYear = guint16;
pub type GDateDay = guint8;
pub type GDate = _GDate;
pub const GDateDMY_G_DATE_DAY: GDateDMY = 0;
pub const GDateDMY_G_DATE_MONTH: GDateDMY = 1;
pub const GDateDMY_G_DATE_YEAR: GDateDMY = 2;
pub type GDateDMY = ::std::os::raw::c_int;
pub const GDateWeekday_G_DATE_BAD_WEEKDAY: GDateWeekday = 0;
pub const GDateWeekday_G_DATE_MONDAY: GDateWeekday = 1;
pub const GDateWeekday_G_DATE_TUESDAY: GDateWeekday = 2;
pub const GDateWeekday_G_DATE_WEDNESDAY: GDateWeekday = 3;
pub const GDateWeekday_G_DATE_THURSDAY: GDateWeekday = 4;
pub const GDateWeekday_G_DATE_FRIDAY: GDateWeekday = 5;
pub const GDateWeekday_G_DATE_SATURDAY: GDateWeekday = 6;
pub const GDateWeekday_G_DATE_SUNDAY: GDateWeekday = 7;
pub type GDateWeekday = ::std::os::raw::c_int;
pub const GDateMonth_G_DATE_BAD_MONTH: GDateMonth = 0;
pub const GDateMonth_G_DATE_JANUARY: GDateMonth = 1;
pub const GDateMonth_G_DATE_FEBRUARY: GDateMonth = 2;
pub const GDateMonth_G_DATE_MARCH: GDateMonth = 3;
pub const GDateMonth_G_DATE_APRIL: GDateMonth = 4;
pub const GDateMonth_G_DATE_MAY: GDateMonth = 5;
pub const GDateMonth_G_DATE_JUNE: GDateMonth = 6;
pub const GDateMonth_G_DATE_JULY: GDateMonth = 7;
pub const GDateMonth_G_DATE_AUGUST: GDateMonth = 8;
pub const GDateMonth_G_DATE_SEPTEMBER: GDateMonth = 9;
pub const GDateMonth_G_DATE_OCTOBER: GDateMonth = 10;
pub const GDateMonth_G_DATE_NOVEMBER: GDateMonth = 11;
pub const GDateMonth_G_DATE_DECEMBER: GDateMonth = 12;
pub type GDateMonth = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDate {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout__GDate() {
    assert_eq!(
        ::std::mem::size_of::<_GDate>(),
        8usize,
        concat!("Size of: ", stringify!(_GDate))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDate>(),
        4usize,
        concat!("Alignment of ", stringify!(_GDate))
    );
}
impl _GDate {
    #[inline]
    pub fn julian_days(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_julian_days(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn julian(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_julian(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dmy(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dmy(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn day(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_day(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn month(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_month(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn year(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_year(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        julian_days: guint,
        julian: guint,
        dmy: guint,
        day: guint,
        month: guint,
        year: guint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let julian_days: u32 = unsafe { ::std::mem::transmute(julian_days) };
            julian_days as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let julian: u32 = unsafe { ::std::mem::transmute(julian) };
            julian as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let dmy: u32 = unsafe { ::std::mem::transmute(dmy) };
            dmy as u64
        });
        __bindgen_bitfield_unit.set(34usize, 6u8, {
            let day: u32 = unsafe { ::std::mem::transmute(day) };
            day as u64
        });
        __bindgen_bitfield_unit.set(40usize, 4u8, {
            let month: u32 = unsafe { ::std::mem::transmute(month) };
            month as u64
        });
        __bindgen_bitfield_unit.set(44usize, 16u8, {
            let year: u32 = unsafe { ::std::mem::transmute(year) };
            year as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn g_date_new() -> *mut GDate;
}
extern "C" {
    pub fn g_date_new_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> *mut GDate;
}
extern "C" {
    pub fn g_date_new_julian(julian_day: guint32) -> *mut GDate;
}
extern "C" {
    pub fn g_date_free(date: *mut GDate);
}
extern "C" {
    pub fn g_date_copy(date: *const GDate) -> *mut GDate;
}
extern "C" {
    pub fn g_date_valid(date: *const GDate) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_day(day: GDateDay) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_month(month: GDateMonth) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_year(year: GDateYear) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_weekday(weekday: GDateWeekday) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_julian(julian_date: guint32) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> gboolean;
}
extern "C" {
    pub fn g_date_get_weekday(date: *const GDate) -> GDateWeekday;
}
extern "C" {
    pub fn g_date_get_month(date: *const GDate) -> GDateMonth;
}
extern "C" {
    pub fn g_date_get_year(date: *const GDate) -> GDateYear;
}
extern "C" {
    pub fn g_date_get_day(date: *const GDate) -> GDateDay;
}
extern "C" {
    pub fn g_date_get_julian(date: *const GDate) -> guint32;
}
extern "C" {
    pub fn g_date_get_day_of_year(date: *const GDate) -> guint;
}
extern "C" {
    pub fn g_date_get_monday_week_of_year(date: *const GDate) -> guint;
}
extern "C" {
    pub fn g_date_get_sunday_week_of_year(date: *const GDate) -> guint;
}
extern "C" {
    pub fn g_date_get_iso8601_week_of_year(date: *const GDate) -> guint;
}
extern "C" {
    pub fn g_date_clear(date: *mut GDate, n_dates: guint);
}
extern "C" {
    pub fn g_date_set_parse(date: *mut GDate, str_: *const gchar);
}
extern "C" {
    pub fn g_date_set_time_t(date: *mut GDate, timet: time_t);
}
extern "C" {
    pub fn g_date_set_time_val(date: *mut GDate, timeval: *mut GTimeVal);
}
extern "C" {
    pub fn g_date_set_time(date: *mut GDate, time_: GTime);
}
extern "C" {
    pub fn g_date_set_month(date: *mut GDate, month: GDateMonth);
}
extern "C" {
    pub fn g_date_set_day(date: *mut GDate, day: GDateDay);
}
extern "C" {
    pub fn g_date_set_year(date: *mut GDate, year: GDateYear);
}
extern "C" {
    pub fn g_date_set_dmy(date: *mut GDate, day: GDateDay, month: GDateMonth, y: GDateYear);
}
extern "C" {
    pub fn g_date_set_julian(date: *mut GDate, julian_date: guint32);
}
extern "C" {
    pub fn g_date_is_first_of_month(date: *const GDate) -> gboolean;
}
extern "C" {
    pub fn g_date_is_last_of_month(date: *const GDate) -> gboolean;
}
extern "C" {
    pub fn g_date_add_days(date: *mut GDate, n_days: guint);
}
extern "C" {
    pub fn g_date_subtract_days(date: *mut GDate, n_days: guint);
}
extern "C" {
    pub fn g_date_add_months(date: *mut GDate, n_months: guint);
}
extern "C" {
    pub fn g_date_subtract_months(date: *mut GDate, n_months: guint);
}
extern "C" {
    pub fn g_date_add_years(date: *mut GDate, n_years: guint);
}
extern "C" {
    pub fn g_date_subtract_years(date: *mut GDate, n_years: guint);
}
extern "C" {
    pub fn g_date_is_leap_year(year: GDateYear) -> gboolean;
}
extern "C" {
    pub fn g_date_get_days_in_month(month: GDateMonth, year: GDateYear) -> guint8;
}
extern "C" {
    pub fn g_date_get_monday_weeks_in_year(year: GDateYear) -> guint8;
}
extern "C" {
    pub fn g_date_get_sunday_weeks_in_year(year: GDateYear) -> guint8;
}
extern "C" {
    pub fn g_date_days_between(date1: *const GDate, date2: *const GDate) -> gint;
}
extern "C" {
    pub fn g_date_compare(lhs: *const GDate, rhs: *const GDate) -> gint;
}
extern "C" {
    pub fn g_date_to_struct_tm(date: *const GDate, tm: *mut tm);
}
extern "C" {
    pub fn g_date_clamp(date: *mut GDate, min_date: *const GDate, max_date: *const GDate);
}
extern "C" {
    pub fn g_date_order(date1: *mut GDate, date2: *mut GDate);
}
extern "C" {
    pub fn g_date_strftime(
        s: *mut gchar,
        slen: gsize,
        format: *const gchar,
        date: *const GDate,
    ) -> gsize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDir {
    _unused: [u8; 0],
}
pub type GDir = _GDir;
extern "C" {
    pub fn g_dir_open(path: *const gchar, flags: guint, error: *mut *mut GError) -> *mut GDir;
}
extern "C" {
    pub fn g_dir_read_name(dir: *mut GDir) -> *const gchar;
}
extern "C" {
    pub fn g_dir_rewind(dir: *mut GDir);
}
extern "C" {
    pub fn g_dir_close(dir: *mut GDir);
}
extern "C" {
    pub fn g_getenv(variable: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_setenv(variable: *const gchar, value: *const gchar, overwrite: gboolean) -> gboolean;
}
extern "C" {
    pub fn g_unsetenv(variable: *const gchar);
}
extern "C" {
    pub fn g_listenv() -> *mut *mut gchar;
}
extern "C" {
    pub fn g_get_environ() -> *mut *mut gchar;
}
extern "C" {
    pub fn g_environ_getenv(envp: *mut *mut gchar, variable: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_environ_setenv(
        envp: *mut *mut gchar,
        variable: *const gchar,
        value: *const gchar,
        overwrite: gboolean,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_environ_unsetenv(envp: *mut *mut gchar, variable: *const gchar) -> *mut *mut gchar;
}
pub const GFileError_G_FILE_ERROR_EXIST: GFileError = 0;
pub const GFileError_G_FILE_ERROR_ISDIR: GFileError = 1;
pub const GFileError_G_FILE_ERROR_ACCES: GFileError = 2;
pub const GFileError_G_FILE_ERROR_NAMETOOLONG: GFileError = 3;
pub const GFileError_G_FILE_ERROR_NOENT: GFileError = 4;
pub const GFileError_G_FILE_ERROR_NOTDIR: GFileError = 5;
pub const GFileError_G_FILE_ERROR_NXIO: GFileError = 6;
pub const GFileError_G_FILE_ERROR_NODEV: GFileError = 7;
pub const GFileError_G_FILE_ERROR_ROFS: GFileError = 8;
pub const GFileError_G_FILE_ERROR_TXTBSY: GFileError = 9;
pub const GFileError_G_FILE_ERROR_FAULT: GFileError = 10;
pub const GFileError_G_FILE_ERROR_LOOP: GFileError = 11;
pub const GFileError_G_FILE_ERROR_NOSPC: GFileError = 12;
pub const GFileError_G_FILE_ERROR_NOMEM: GFileError = 13;
pub const GFileError_G_FILE_ERROR_MFILE: GFileError = 14;
pub const GFileError_G_FILE_ERROR_NFILE: GFileError = 15;
pub const GFileError_G_FILE_ERROR_BADF: GFileError = 16;
pub const GFileError_G_FILE_ERROR_INVAL: GFileError = 17;
pub const GFileError_G_FILE_ERROR_PIPE: GFileError = 18;
pub const GFileError_G_FILE_ERROR_AGAIN: GFileError = 19;
pub const GFileError_G_FILE_ERROR_INTR: GFileError = 20;
pub const GFileError_G_FILE_ERROR_IO: GFileError = 21;
pub const GFileError_G_FILE_ERROR_PERM: GFileError = 22;
pub const GFileError_G_FILE_ERROR_NOSYS: GFileError = 23;
pub const GFileError_G_FILE_ERROR_FAILED: GFileError = 24;
pub type GFileError = ::std::os::raw::c_int;
pub const GFileTest_G_FILE_TEST_IS_REGULAR: GFileTest = 1;
pub const GFileTest_G_FILE_TEST_IS_SYMLINK: GFileTest = 2;
pub const GFileTest_G_FILE_TEST_IS_DIR: GFileTest = 4;
pub const GFileTest_G_FILE_TEST_IS_EXECUTABLE: GFileTest = 8;
pub const GFileTest_G_FILE_TEST_EXISTS: GFileTest = 16;
pub type GFileTest = ::std::os::raw::c_int;
pub const GFileSetContentsFlags_G_FILE_SET_CONTENTS_NONE: GFileSetContentsFlags = 0;
pub const GFileSetContentsFlags_G_FILE_SET_CONTENTS_CONSISTENT: GFileSetContentsFlags = 1;
pub const GFileSetContentsFlags_G_FILE_SET_CONTENTS_DURABLE: GFileSetContentsFlags = 2;
pub const GFileSetContentsFlags_G_FILE_SET_CONTENTS_ONLY_EXISTING: GFileSetContentsFlags = 4;
#[doc = " GFileSetContentsFlags:\n @G_FILE_SET_CONTENTS_NONE: No guarantees about file consistency or durability.\n   The most dangerous setting, which is slightly faster than other settings.\n @G_FILE_SET_CONTENTS_CONSISTENT: Guarantee file consistency: after a crash,\n   either the old version of the file or the new version of the file will be\n   available, but not a mixture. On Unix systems this equates to an `fsync()`\n   on the file and use of an atomic `rename()` of the new version of the file\n   over the old.\n @G_FILE_SET_CONTENTS_DURABLE: Guarantee file durability: after a crash, the\n   new version of the file will be available. On Unix systems this equates to\n   an `fsync()` on the file (if %G_FILE_SET_CONTENTS_CONSISTENT is unset), or\n   the effects of %G_FILE_SET_CONTENTS_CONSISTENT plus an `fsync()` on the\n   directory containing the file after calling `rename()`.\n @G_FILE_SET_CONTENTS_ONLY_EXISTING: Only apply consistency and durability\n   guarantees if the file already exists. This may speed up file operations\n   if the file doesnt currently exist, but may result in a corrupted version\n   of the new file if the system crashes while writing it.\n\n Flags to pass to g_file_set_contents_full() to affect its safety and\n performance.\n\n Since: 2.66"]
pub type GFileSetContentsFlags = ::std::os::raw::c_int;
extern "C" {
    pub fn g_file_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_file_error_from_errno(err_no: gint) -> GFileError;
}
extern "C" {
    pub fn g_file_test(filename: *const gchar, test: GFileTest) -> gboolean;
}
extern "C" {
    pub fn g_file_get_contents(
        filename: *const gchar,
        contents: *mut *mut gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_set_contents(
        filename: *const gchar,
        contents: *const gchar,
        length: gssize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_set_contents_full(
        filename: *const gchar,
        contents: *const gchar,
        length: gssize,
        flags: GFileSetContentsFlags,
        mode: ::std::os::raw::c_int,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_read_link(filename: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    pub fn g_mkdtemp(tmpl: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_mkdtemp_full(tmpl: *mut gchar, mode: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_mkstemp(tmpl: *mut gchar) -> gint;
}
extern "C" {
    pub fn g_mkstemp_full(tmpl: *mut gchar, flags: gint, mode: gint) -> gint;
}
extern "C" {
    pub fn g_file_open_tmp(
        tmpl: *const gchar,
        name_used: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    pub fn g_dir_make_tmp(tmpl: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    pub fn g_build_path(separator: *const gchar, first_element: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_build_pathv(separator: *const gchar, args: *mut *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_build_filename(first_element: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_build_filenamev(args: *mut *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_build_filename_valist(first_element: *const gchar, args: *mut va_list) -> *mut gchar;
}
extern "C" {
    pub fn g_mkdir_with_parents(pathname: *const gchar, mode: gint) -> gint;
}
extern "C" {
    pub fn g_path_is_absolute(file_name: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_path_skip_root(file_name: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_basename(file_name: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_get_current_dir() -> *mut gchar;
}
extern "C" {
    pub fn g_path_get_basename(file_name: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_path_get_dirname(file_name: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_canonicalize_filename(filename: *const gchar, relative_to: *const gchar)
        -> *mut gchar;
}
extern "C" {
    pub fn g_strip_context(msgid: *const gchar, msgval: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_dgettext(domain: *const gchar, msgid: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_dcgettext(domain: *const gchar, msgid: *const gchar, category: gint) -> *const gchar;
}
extern "C" {
    pub fn g_dngettext(
        domain: *const gchar,
        msgid: *const gchar,
        msgid_plural: *const gchar,
        n: gulong,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_dpgettext(
        domain: *const gchar,
        msgctxtid: *const gchar,
        msgidoffset: gsize,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_dpgettext2(
        domain: *const gchar,
        context: *const gchar,
        msgid: *const gchar,
    ) -> *const gchar;
}
#[doc = " GMemVTable:\n @malloc: function to use for allocating memory.\n @realloc: function to use for reallocating memory.\n @free: function to use to free memory.\n @calloc: function to use for allocating zero-filled memory.\n @try_malloc: function to use for allocating memory without a default error handler.\n @try_realloc: function to use for reallocating memory without a default error handler.\n\n A set of functions used to perform memory allocation. The same #GMemVTable must\n be used for all allocations in the same program; a call to g_mem_set_vtable(),\n if it exists, should be prior to any use of GLib.\n\n This functions related to this has been deprecated in 2.46, and no longer work."]
pub type GMemVTable = _GMemVTable;
extern "C" {
    pub fn g_free(mem: gpointer);
}
extern "C" {
    pub fn g_free_sized(mem: gpointer, size: usize);
}
extern "C" {
    pub fn g_clear_pointer(pp: *mut gpointer, destroy: GDestroyNotify);
}
extern "C" {
    pub fn g_malloc(n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_malloc0(n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_malloc(n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_malloc0(n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_aligned_alloc(n_blocks: gsize, n_block_bytes: gsize, alignment: gsize) -> gpointer;
}
extern "C" {
    pub fn g_aligned_alloc0(n_blocks: gsize, n_block_bytes: gsize, alignment: gsize) -> gpointer;
}
extern "C" {
    pub fn g_aligned_free(mem: gpointer);
}
extern "C" {
    pub fn g_aligned_free_sized(mem: gpointer, alignment: usize, size: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemVTable {
    pub malloc: ::std::option::Option<unsafe extern "C" fn(n_bytes: gsize) -> gpointer>,
    pub realloc:
        ::std::option::Option<unsafe extern "C" fn(mem: gpointer, n_bytes: gsize) -> gpointer>,
    pub free: ::std::option::Option<unsafe extern "C" fn(mem: gpointer)>,
    pub calloc: ::std::option::Option<
        unsafe extern "C" fn(n_blocks: gsize, n_block_bytes: gsize) -> gpointer,
    >,
    pub try_malloc: ::std::option::Option<unsafe extern "C" fn(n_bytes: gsize) -> gpointer>,
    pub try_realloc:
        ::std::option::Option<unsafe extern "C" fn(mem: gpointer, n_bytes: gsize) -> gpointer>,
}
#[test]
fn bindgen_test_layout__GMemVTable() {
    const UNINIT: ::std::mem::MaybeUninit<_GMemVTable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMemVTable>(),
        48usize,
        concat!("Size of: ", stringify!(_GMemVTable))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMemVTable>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMemVTable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).malloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(malloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).realloc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(realloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).calloc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(calloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).try_malloc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(try_malloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).try_realloc) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(try_realloc)
        )
    );
}
extern "C" {
    pub fn g_mem_set_vtable(vtable: *mut GMemVTable);
}
extern "C" {
    pub fn g_mem_is_system_malloc() -> gboolean;
}
extern "C" {
    pub static mut g_mem_gc_friendly: gboolean;
}
extern "C" {
    pub static mut glib_mem_profiler_table: *mut GMemVTable;
}
extern "C" {
    pub fn g_mem_profile();
}
pub type GNode = _GNode;
pub const GTraverseFlags_G_TRAVERSE_LEAVES: GTraverseFlags = 1;
pub const GTraverseFlags_G_TRAVERSE_NON_LEAVES: GTraverseFlags = 2;
pub const GTraverseFlags_G_TRAVERSE_ALL: GTraverseFlags = 3;
pub const GTraverseFlags_G_TRAVERSE_MASK: GTraverseFlags = 3;
pub const GTraverseFlags_G_TRAVERSE_LEAFS: GTraverseFlags = 1;
pub const GTraverseFlags_G_TRAVERSE_NON_LEAFS: GTraverseFlags = 2;
pub type GTraverseFlags = ::std::os::raw::c_int;
pub const GTraverseType_G_IN_ORDER: GTraverseType = 0;
pub const GTraverseType_G_PRE_ORDER: GTraverseType = 1;
pub const GTraverseType_G_POST_ORDER: GTraverseType = 2;
pub const GTraverseType_G_LEVEL_ORDER: GTraverseType = 3;
pub type GTraverseType = ::std::os::raw::c_int;
pub type GNodeTraverseFunc =
    ::std::option::Option<unsafe extern "C" fn(node: *mut GNode, data: gpointer) -> gboolean>;
pub type GNodeForeachFunc =
    ::std::option::Option<unsafe extern "C" fn(node: *mut GNode, data: gpointer)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNode {
    pub data: gpointer,
    pub next: *mut GNode,
    pub prev: *mut GNode,
    pub parent: *mut GNode,
    pub children: *mut GNode,
}
#[test]
fn bindgen_test_layout__GNode() {
    const UNINIT: ::std::mem::MaybeUninit<_GNode> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GNode>(),
        40usize,
        concat!("Size of: ", stringify!(_GNode))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNode>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).children) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(children)
        )
    );
}
extern "C" {
    pub fn g_node_new(data: gpointer) -> *mut GNode;
}
extern "C" {
    pub fn g_node_destroy(root: *mut GNode);
}
extern "C" {
    pub fn g_node_unlink(node: *mut GNode);
}
extern "C" {
    pub fn g_node_copy_deep(node: *mut GNode, copy_func: GCopyFunc, data: gpointer) -> *mut GNode;
}
extern "C" {
    pub fn g_node_copy(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_insert(parent: *mut GNode, position: gint, node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_insert_before(
        parent: *mut GNode,
        sibling: *mut GNode,
        node: *mut GNode,
    ) -> *mut GNode;
}
extern "C" {
    pub fn g_node_insert_after(
        parent: *mut GNode,
        sibling: *mut GNode,
        node: *mut GNode,
    ) -> *mut GNode;
}
extern "C" {
    pub fn g_node_prepend(parent: *mut GNode, node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_n_nodes(root: *mut GNode, flags: GTraverseFlags) -> guint;
}
extern "C" {
    pub fn g_node_get_root(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_is_ancestor(node: *mut GNode, descendant: *mut GNode) -> gboolean;
}
extern "C" {
    pub fn g_node_depth(node: *mut GNode) -> guint;
}
extern "C" {
    pub fn g_node_find(
        root: *mut GNode,
        order: GTraverseType,
        flags: GTraverseFlags,
        data: gpointer,
    ) -> *mut GNode;
}
extern "C" {
    pub fn g_node_traverse(
        root: *mut GNode,
        order: GTraverseType,
        flags: GTraverseFlags,
        max_depth: gint,
        func: GNodeTraverseFunc,
        data: gpointer,
    );
}
extern "C" {
    pub fn g_node_max_height(root: *mut GNode) -> guint;
}
extern "C" {
    pub fn g_node_children_foreach(
        node: *mut GNode,
        flags: GTraverseFlags,
        func: GNodeForeachFunc,
        data: gpointer,
    );
}
extern "C" {
    pub fn g_node_reverse_children(node: *mut GNode);
}
extern "C" {
    pub fn g_node_n_children(node: *mut GNode) -> guint;
}
extern "C" {
    pub fn g_node_nth_child(node: *mut GNode, n: guint) -> *mut GNode;
}
extern "C" {
    pub fn g_node_last_child(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_find_child(node: *mut GNode, flags: GTraverseFlags, data: gpointer)
        -> *mut GNode;
}
extern "C" {
    pub fn g_node_child_position(node: *mut GNode, child: *mut GNode) -> gint;
}
extern "C" {
    pub fn g_node_child_index(node: *mut GNode, data: gpointer) -> gint;
}
extern "C" {
    pub fn g_node_first_sibling(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_last_sibling(node: *mut GNode) -> *mut GNode;
}
pub type GList = _GList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GList {
    pub data: gpointer,
    pub next: *mut GList,
    pub prev: *mut GList,
}
#[test]
fn bindgen_test_layout__GList() {
    const UNINIT: ::std::mem::MaybeUninit<_GList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GList>(),
        24usize,
        concat!("Size of: ", stringify!(_GList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(prev)
        )
    );
}
extern "C" {
    pub fn g_list_alloc() -> *mut GList;
}
extern "C" {
    pub fn g_list_free(list: *mut GList);
}
extern "C" {
    pub fn g_list_free_1(list: *mut GList);
}
extern "C" {
    pub fn g_list_free_full(list: *mut GList, free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_list_append(list: *mut GList, data: gpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_prepend(list: *mut GList, data: gpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_insert(list: *mut GList, data: gpointer, position: gint) -> *mut GList;
}
extern "C" {
    pub fn g_list_insert_sorted(list: *mut GList, data: gpointer, func: GCompareFunc)
        -> *mut GList;
}
extern "C" {
    pub fn g_list_insert_sorted_with_data(
        list: *mut GList,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_insert_before(
        list: *mut GList,
        sibling: *mut GList,
        data: gpointer,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_insert_before_link(
        list: *mut GList,
        sibling: *mut GList,
        link_: *mut GList,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_concat(list1: *mut GList, list2: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_remove(list: *mut GList, data: gconstpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_remove_all(list: *mut GList, data: gconstpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_remove_link(list: *mut GList, llink: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_delete_link(list: *mut GList, link_: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_reverse(list: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_copy(list: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_copy_deep(list: *mut GList, func: GCopyFunc, user_data: gpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_nth(list: *mut GList, n: guint) -> *mut GList;
}
extern "C" {
    pub fn g_list_nth_prev(list: *mut GList, n: guint) -> *mut GList;
}
extern "C" {
    pub fn g_list_find(list: *mut GList, data: gconstpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_find_custom(
        list: *mut GList,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_position(list: *mut GList, llink: *mut GList) -> gint;
}
extern "C" {
    pub fn g_list_index(list: *mut GList, data: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_list_last(list: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_first(list: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_length(list: *mut GList) -> guint;
}
extern "C" {
    pub fn g_list_foreach(list: *mut GList, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_list_sort(list: *mut GList, compare_func: GCompareFunc) -> *mut GList;
}
extern "C" {
    pub fn g_list_sort_with_data(
        list: *mut GList,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_nth_data(list: *mut GList, n: guint) -> gpointer;
}
extern "C" {
    pub fn g_clear_list(list_ptr: *mut *mut GList, destroy: GDestroyNotify);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHashTable {
    _unused: [u8; 0],
}
pub type GHashTable = _GHashTable;
pub type GHRFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, user_data: gpointer) -> gboolean,
>;
pub type GHashTableIter = _GHashTableIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHashTableIter {
    pub dummy1: gpointer,
    pub dummy2: gpointer,
    pub dummy3: gpointer,
    pub dummy4: ::std::os::raw::c_int,
    pub dummy5: gboolean,
    pub dummy6: gpointer,
}
#[test]
fn bindgen_test_layout__GHashTableIter() {
    const UNINIT: ::std::mem::MaybeUninit<_GHashTableIter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GHashTableIter>(),
        40usize,
        concat!("Size of: ", stringify!(_GHashTableIter))
    );
    assert_eq!(
        ::std::mem::align_of::<_GHashTableIter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GHashTableIter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy4) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy5) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy6) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy6)
        )
    );
}
extern "C" {
    pub fn g_hash_table_new(hash_func: GHashFunc, key_equal_func: GEqualFunc) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_new_full(
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
        key_destroy_func: GDestroyNotify,
        value_destroy_func: GDestroyNotify,
    ) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_new_similar(other_hash_table: *mut GHashTable) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_destroy(hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_hash_table_insert(
        hash_table: *mut GHashTable,
        key: gpointer,
        value: gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_replace(
        hash_table: *mut GHashTable,
        key: gpointer,
        value: gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_add(hash_table: *mut GHashTable, key: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_remove(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_remove_all(hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_hash_table_steal(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_steal_extended(
        hash_table: *mut GHashTable,
        lookup_key: gconstpointer,
        stolen_key: *mut gpointer,
        stolen_value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_steal_all(hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_hash_table_steal_all_keys(hash_table: *mut GHashTable) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_hash_table_steal_all_values(hash_table: *mut GHashTable) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_hash_table_lookup(hash_table: *mut GHashTable, key: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_hash_table_contains(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_lookup_extended(
        hash_table: *mut GHashTable,
        lookup_key: gconstpointer,
        orig_key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_foreach(hash_table: *mut GHashTable, func: GHFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_hash_table_find(
        hash_table: *mut GHashTable,
        predicate: GHRFunc,
        user_data: gpointer,
    ) -> gpointer;
}
extern "C" {
    pub fn g_hash_table_foreach_remove(
        hash_table: *mut GHashTable,
        func: GHRFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_hash_table_foreach_steal(
        hash_table: *mut GHashTable,
        func: GHRFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_hash_table_size(hash_table: *mut GHashTable) -> guint;
}
extern "C" {
    pub fn g_hash_table_get_keys(hash_table: *mut GHashTable) -> *mut GList;
}
extern "C" {
    pub fn g_hash_table_get_values(hash_table: *mut GHashTable) -> *mut GList;
}
extern "C" {
    pub fn g_hash_table_get_keys_as_array(
        hash_table: *mut GHashTable,
        length: *mut guint,
    ) -> *mut gpointer;
}
extern "C" {
    pub fn g_hash_table_get_keys_as_ptr_array(hash_table: *mut GHashTable) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_hash_table_get_values_as_ptr_array(hash_table: *mut GHashTable) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_hash_table_iter_init(iter: *mut GHashTableIter, hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_hash_table_iter_next(
        iter: *mut GHashTableIter,
        key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_iter_get_hash_table(iter: *mut GHashTableIter) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_iter_remove(iter: *mut GHashTableIter);
}
extern "C" {
    pub fn g_hash_table_iter_replace(iter: *mut GHashTableIter, value: gpointer);
}
extern "C" {
    pub fn g_hash_table_iter_steal(iter: *mut GHashTableIter);
}
extern "C" {
    pub fn g_hash_table_ref(hash_table: *mut GHashTable) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_unref(hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_str_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_str_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_int_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_int_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_int64_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_int64_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_double_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_double_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_direct_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_direct_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHmac {
    _unused: [u8; 0],
}
#[doc = " GHmac:\n\n An opaque structure representing a HMAC operation.\n To create a new GHmac, use g_hmac_new(). To free\n a GHmac, use g_hmac_unref().\n\n Since: 2.30"]
pub type GHmac = _GHmac;
extern "C" {
    pub fn g_hmac_new(digest_type: GChecksumType, key: *const guchar, key_len: gsize)
        -> *mut GHmac;
}
extern "C" {
    pub fn g_hmac_copy(hmac: *const GHmac) -> *mut GHmac;
}
extern "C" {
    pub fn g_hmac_ref(hmac: *mut GHmac) -> *mut GHmac;
}
extern "C" {
    pub fn g_hmac_unref(hmac: *mut GHmac);
}
extern "C" {
    pub fn g_hmac_update(hmac: *mut GHmac, data: *const guchar, length: gssize);
}
extern "C" {
    pub fn g_hmac_get_string(hmac: *mut GHmac) -> *const gchar;
}
extern "C" {
    pub fn g_hmac_get_digest(hmac: *mut GHmac, buffer: *mut guint8, digest_len: *mut gsize);
}
extern "C" {
    pub fn g_compute_hmac_for_data(
        digest_type: GChecksumType,
        key: *const guchar,
        key_len: gsize,
        data: *const guchar,
        length: gsize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_compute_hmac_for_string(
        digest_type: GChecksumType,
        key: *const guchar,
        key_len: gsize,
        str_: *const gchar,
        length: gssize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_compute_hmac_for_bytes(
        digest_type: GChecksumType,
        key: *mut GBytes,
        data: *mut GBytes,
    ) -> *mut gchar;
}
pub type GHook = _GHook;
pub type GHookList = _GHookList;
pub type GHookCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(new_hook: *mut GHook, sibling: *mut GHook) -> gint>;
pub type GHookFindFunc =
    ::std::option::Option<unsafe extern "C" fn(hook: *mut GHook, data: gpointer) -> gboolean>;
pub type GHookMarshaller =
    ::std::option::Option<unsafe extern "C" fn(hook: *mut GHook, marshal_data: gpointer)>;
pub type GHookCheckMarshaller = ::std::option::Option<
    unsafe extern "C" fn(hook: *mut GHook, marshal_data: gpointer) -> gboolean,
>;
pub type GHookFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub type GHookCheckFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer) -> gboolean>;
pub type GHookFinalizeFunc =
    ::std::option::Option<unsafe extern "C" fn(hook_list: *mut GHookList, hook: *mut GHook)>;
pub const GHookFlagMask_G_HOOK_FLAG_ACTIVE: GHookFlagMask = 1;
pub const GHookFlagMask_G_HOOK_FLAG_IN_CALL: GHookFlagMask = 2;
pub const GHookFlagMask_G_HOOK_FLAG_MASK: GHookFlagMask = 15;
pub type GHookFlagMask = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHookList {
    pub seq_id: gulong,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub hooks: *mut GHook,
    pub dummy3: gpointer,
    pub finalize_hook: GHookFinalizeFunc,
    pub dummy: [gpointer; 2usize],
}
#[test]
fn bindgen_test_layout__GHookList() {
    const UNINIT: ::std::mem::MaybeUninit<_GHookList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GHookList>(),
        48usize,
        concat!("Size of: ", stringify!(_GHookList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GHookList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GHookList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seq_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(seq_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hooks) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(hooks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(dummy3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finalize_hook) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(finalize_hook)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(dummy)
        )
    );
}
impl _GHookList {
    #[inline]
    pub fn hook_size(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_hook_size(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn is_setup(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_setup(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hook_size: guint,
        is_setup: guint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let hook_size: u32 = unsafe { ::std::mem::transmute(hook_size) };
            hook_size as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let is_setup: u32 = unsafe { ::std::mem::transmute(is_setup) };
            is_setup as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHook {
    pub data: gpointer,
    pub next: *mut GHook,
    pub prev: *mut GHook,
    pub ref_count: guint,
    pub hook_id: gulong,
    pub flags: guint,
    pub func: gpointer,
    pub destroy: GDestroyNotify,
}
#[test]
fn bindgen_test_layout__GHook() {
    const UNINIT: ::std::mem::MaybeUninit<_GHook> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GHook>(),
        56usize,
        concat!("Size of: ", stringify!(_GHook))
    );
    assert_eq!(
        ::std::mem::align_of::<_GHook>(),
        8usize,
        concat!("Alignment of ", stringify!(_GHook))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hook_id) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(hook_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(destroy)
        )
    );
}
extern "C" {
    pub fn g_hook_list_init(hook_list: *mut GHookList, hook_size: guint);
}
extern "C" {
    pub fn g_hook_list_clear(hook_list: *mut GHookList);
}
extern "C" {
    pub fn g_hook_alloc(hook_list: *mut GHookList) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_free(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_ref(hook_list: *mut GHookList, hook: *mut GHook) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_unref(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_destroy(hook_list: *mut GHookList, hook_id: gulong) -> gboolean;
}
extern "C" {
    pub fn g_hook_destroy_link(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_prepend(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_insert_before(hook_list: *mut GHookList, sibling: *mut GHook, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_insert_sorted(
        hook_list: *mut GHookList,
        hook: *mut GHook,
        func: GHookCompareFunc,
    );
}
extern "C" {
    pub fn g_hook_get(hook_list: *mut GHookList, hook_id: gulong) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_find(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: GHookFindFunc,
        data: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_find_data(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        data: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_find_func(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_find_func_data(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: gpointer,
        data: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_first_valid(hook_list: *mut GHookList, may_be_in_call: gboolean) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_next_valid(
        hook_list: *mut GHookList,
        hook: *mut GHook,
        may_be_in_call: gboolean,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_compare_ids(new_hook: *mut GHook, sibling: *mut GHook) -> gint;
}
extern "C" {
    pub fn g_hook_list_invoke(hook_list: *mut GHookList, may_recurse: gboolean);
}
extern "C" {
    pub fn g_hook_list_invoke_check(hook_list: *mut GHookList, may_recurse: gboolean);
}
extern "C" {
    pub fn g_hook_list_marshal(
        hook_list: *mut GHookList,
        may_recurse: gboolean,
        marshaller: GHookMarshaller,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_hook_list_marshal_check(
        hook_list: *mut GHookList,
        may_recurse: gboolean,
        marshaller: GHookCheckMarshaller,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_hostname_is_non_ascii(hostname: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_hostname_is_ascii_encoded(hostname: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_hostname_is_ip_address(hostname: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_hostname_to_ascii(hostname: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_hostname_to_unicode(hostname: *const gchar) -> *mut gchar;
}
#[doc = " GPollFD:\n @fd: the file descriptor to poll (or a HANDLE on Win32)\n @events: a bitwise combination from #GIOCondition, specifying which\n     events should be polled for. Typically for reading from a file\n     descriptor you would use %G_IO_IN | %G_IO_HUP | %G_IO_ERR, and\n     for writing you would use %G_IO_OUT | %G_IO_ERR.\n @revents: a bitwise combination of flags from #GIOCondition, returned\n     from the poll() function to indicate which events occurred.\n\n Represents a file descriptor, which events to poll for, and which events\n occurred."]
pub type GPollFD = _GPollFD;
#[doc = " GPollFunc:\n @ufds: an array of #GPollFD elements\n @nfsd: the number of elements in @ufds\n @timeout_: the maximum time to wait for an event of the file descriptors.\n     A negative value indicates an infinite timeout.\n\n Specifies the type of function passed to g_main_context_set_poll_func().\n The semantics of the function should match those of the poll() system call.\n\n Returns: the number of #GPollFD elements which have events or errors\n     reported, or -1 if an error occurred."]
pub type GPollFunc = ::std::option::Option<
    unsafe extern "C" fn(ufds: *mut GPollFD, nfsd: guint, timeout_: gint) -> gint,
>;
#[doc = " GPollFD:\n @fd: the file descriptor to poll (or a HANDLE on Win32)\n @events: a bitwise combination from #GIOCondition, specifying which\n     events should be polled for. Typically for reading from a file\n     descriptor you would use %G_IO_IN | %G_IO_HUP | %G_IO_ERR, and\n     for writing you would use %G_IO_OUT | %G_IO_ERR.\n @revents: a bitwise combination of flags from #GIOCondition, returned\n     from the poll() function to indicate which events occurred.\n\n Represents a file descriptor, which events to poll for, and which events\n occurred."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPollFD {
    pub fd: gint64,
    pub events: gushort,
    pub revents: gushort,
}
#[test]
fn bindgen_test_layout__GPollFD() {
    const UNINIT: ::std::mem::MaybeUninit<_GPollFD> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GPollFD>(),
        16usize,
        concat!("Size of: ", stringify!(_GPollFD))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPollFD>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPollFD))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollFD),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollFD),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).revents) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollFD),
            "::",
            stringify!(revents)
        )
    );
}
extern "C" {
    #[doc = " G_POLLFD_FORMAT:\n\n A format specifier that can be used in printf()-style format strings\n when printing the @fd member of a #GPollFD."]
    pub fn g_poll(fds: *mut GPollFD, nfds: guint, timeout: gint) -> gint;
}
pub type GSList = _GSList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSList {
    pub data: gpointer,
    pub next: *mut GSList,
}
#[test]
fn bindgen_test_layout__GSList() {
    const UNINIT: ::std::mem::MaybeUninit<_GSList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSList>(),
        16usize,
        concat!("Size of: ", stringify!(_GSList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSList),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSList),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn g_slist_alloc() -> *mut GSList;
}
extern "C" {
    pub fn g_slist_free(list: *mut GSList);
}
extern "C" {
    pub fn g_slist_free_1(list: *mut GSList);
}
extern "C" {
    pub fn g_slist_free_full(list: *mut GSList, free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_slist_append(list: *mut GSList, data: gpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_prepend(list: *mut GSList, data: gpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_insert(list: *mut GSList, data: gpointer, position: gint) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_insert_sorted(
        list: *mut GSList,
        data: gpointer,
        func: GCompareFunc,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_insert_sorted_with_data(
        list: *mut GSList,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_insert_before(
        slist: *mut GSList,
        sibling: *mut GSList,
        data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_concat(list1: *mut GSList, list2: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_remove(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_remove_all(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_remove_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_delete_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_reverse(list: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_copy(list: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_copy_deep(
        list: *mut GSList,
        func: GCopyFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_nth(list: *mut GSList, n: guint) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_find(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_find_custom(
        list: *mut GSList,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_position(list: *mut GSList, llink: *mut GSList) -> gint;
}
extern "C" {
    pub fn g_slist_index(list: *mut GSList, data: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_slist_last(list: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_length(list: *mut GSList) -> guint;
}
extern "C" {
    pub fn g_slist_foreach(list: *mut GSList, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_slist_sort(list: *mut GSList, compare_func: GCompareFunc) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_sort_with_data(
        list: *mut GSList,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_nth_data(list: *mut GSList, n: guint) -> gpointer;
}
extern "C" {
    pub fn g_clear_slist(slist_ptr: *mut *mut GSList, destroy: GDestroyNotify);
}
pub const GIOCondition_G_IO_IN: GIOCondition = 1;
pub const GIOCondition_G_IO_OUT: GIOCondition = 4;
pub const GIOCondition_G_IO_PRI: GIOCondition = 2;
pub const GIOCondition_G_IO_ERR: GIOCondition = 8;
pub const GIOCondition_G_IO_HUP: GIOCondition = 16;
pub const GIOCondition_G_IO_NVAL: GIOCondition = 32;
pub type GIOCondition = ::std::os::raw::c_int;
pub const GMainContextFlags_G_MAIN_CONTEXT_FLAGS_NONE: GMainContextFlags = 0;
pub const GMainContextFlags_G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING: GMainContextFlags = 1;
#[doc = " GMainContextFlags:\n @G_MAIN_CONTEXT_FLAGS_NONE: Default behaviour.\n @G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING: Assume that polling for events will\n free the thread to process other jobs. That's useful if you're using\n `g_main_context_{prepare,query,check,dispatch}` to integrate GMainContext in\n other event loops.\n\n Flags to pass to g_main_context_new_with_flags() which affect the behaviour\n of a #GMainContext.\n\n Since: 2.72"]
pub type GMainContextFlags = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMainContext {
    _unused: [u8; 0],
}
#[doc = " GMainContext:\n\n The `GMainContext` struct is an opaque data\n type representing a set of sources to be handled in a main loop."]
pub type GMainContext = _GMainContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMainLoop {
    _unused: [u8; 0],
}
#[doc = " GMainLoop:\n\n The `GMainLoop` struct is an opaque data type\n representing the main event loop of a GLib or GTK application."]
pub type GMainLoop = _GMainLoop;
#[doc = " GSource:\n\n The `GSource` struct is an opaque data type\n representing an event source."]
pub type GSource = _GSource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourcePrivate {
    _unused: [u8; 0],
}
pub type GSourcePrivate = _GSourcePrivate;
#[doc = " GSourceCallbackFuncs:\n @ref: Called when a reference is added to the callback object\n @unref: Called when a reference to the callback object is dropped\n @get: Called to extract the callback function and data from the\n     callback object.\n\n The `GSourceCallbackFuncs` struct contains\n functions for managing callback objects."]
pub type GSourceCallbackFuncs = _GSourceCallbackFuncs;
#[doc = " GSourceFuncs:\n @prepare: Called before all the file descriptors are polled. If the\n     source can determine that it is ready here (without waiting for the\n     results of the poll() call) it should return %TRUE. It can also return\n     a @timeout_ value which should be the maximum timeout (in milliseconds)\n     which should be passed to the poll() call. The actual timeout used will\n     be -1 if all sources returned -1, or it will be the minimum of all\n     the @timeout_ values returned which were >= 0.  Since 2.36 this may\n     be %NULL, in which case the effect is as if the function always returns\n     %FALSE with a timeout of -1.  If @prepare returns a\n     timeout and the source also has a ready time set, then the\n     lower of the two will be used.\n @check: Called after all the file descriptors are polled. The source\n     should return %TRUE if it is ready to be dispatched. Note that some\n     time may have passed since the previous prepare function was called,\n     so the source should be checked again here.  Since 2.36 this may\n     be %NULL, in which case the effect is as if the function always returns\n     %FALSE.\n @dispatch: Called to dispatch the event source, after it has returned\n     %TRUE in either its @prepare or its @check function, or if a ready time\n     has been reached. The @dispatch function receives a callback function and\n     user data. The callback function may be %NULL if the source was never\n     connected to a callback using g_source_set_callback(). The @dispatch\n     function should call the callback function with @user_data and whatever\n     additional parameters are needed for this type of event source. The\n     return value of the @dispatch function should be %G_SOURCE_REMOVE if the\n     source should be removed or %G_SOURCE_CONTINUE to keep it.\n @finalize: Called when the source is finalized. At this point, the source\n     will have been destroyed, had its callback cleared, and have been removed\n     from its #GMainContext, but it will still have its final reference count,\n     so methods can be called on it from within this function.\n\n The `GSourceFuncs` struct contains a table of\n functions used to handle event sources in a generic manner.\n\n For idle sources, the prepare and check functions always return %TRUE\n to indicate that the source is always ready to be processed. The prepare\n function also returns a timeout value of 0 to ensure that the poll() call\n doesn't block (since that would be time wasted which could have been spent\n running the idle function).\n\n For timeout sources, the prepare and check functions both return %TRUE\n if the timeout interval has expired. The prepare function also returns\n a timeout value to ensure that the poll() call doesn't block too long\n and miss the next timeout.\n\n For file descriptor sources, the prepare function typically returns %FALSE,\n since it must wait until poll() has been called before it knows whether\n any events need to be processed. It sets the returned timeout to -1 to\n indicate that it doesn't mind how long the poll() call blocks. In the\n check function, it tests the results of the poll() call to see if the\n required condition has been met, and returns %TRUE if so."]
pub type GSourceFuncs = _GSourceFuncs;
#[doc = " GSourceFunc:\n @user_data: data passed to the function, set when the source was\n     created with one of the above functions\n\n Specifies the type of function passed to g_timeout_add(),\n g_timeout_add_full(), g_idle_add(), and g_idle_add_full().\n\n When calling g_source_set_callback(), you may need to cast a function of a\n different type to this type. Use G_SOURCE_FUNC() to avoid warnings about\n incompatible function types.\n\n Returns: %FALSE if the source should be removed. %G_SOURCE_CONTINUE and\n %G_SOURCE_REMOVE are more memorable names for the return value."]
pub type GSourceFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gpointer) -> gboolean>;
#[doc = " GSourceOnceFunc:\n @user_data: data passed to the function, set when the source was\n   created\n\n A source function that is only called once before being removed from the main\n context automatically.\n\n See: g_idle_add_once(), g_timeout_add_once()\n\n Since: 2.74"]
pub type GSourceOnceFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gpointer)>;
#[doc = " GChildWatchFunc:\n @pid: the process id of the child process\n @wait_status: Status information about the child process, encoded\n               in a platform-specific manner\n @user_data: user data passed to g_child_watch_add()\n\n Prototype of a #GChildWatchSource callback, called when a child\n process has exited.\n\n To interpret @wait_status, see the documentation\n for g_spawn_check_wait_status(). In particular,\n on Unix platforms, note that it is usually not equal\n to the integer passed to `exit()` or returned from `main()`."]
pub type GChildWatchFunc =
    ::std::option::Option<unsafe extern "C" fn(pid: GPid, wait_status: gint, user_data: gpointer)>;
#[doc = " GSourceDisposeFunc:\n @source: #GSource that is currently being disposed\n\n Dispose function for @source. See g_source_set_dispose_function() for\n details.\n\n Since: 2.64"]
pub type GSourceDisposeFunc = ::std::option::Option<unsafe extern "C" fn(source: *mut GSource)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSource {
    pub callback_data: gpointer,
    pub callback_funcs: *mut GSourceCallbackFuncs,
    pub source_funcs: *const GSourceFuncs,
    pub ref_count: guint,
    pub context: *mut GMainContext,
    pub priority: gint,
    pub flags: guint,
    pub source_id: guint,
    pub poll_fds: *mut GSList,
    pub prev: *mut GSource,
    pub next: *mut GSource,
    pub name: *mut ::std::os::raw::c_char,
    pub priv_: *mut GSourcePrivate,
}
#[test]
fn bindgen_test_layout__GSource() {
    const UNINIT: ::std::mem::MaybeUninit<_GSource> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSource>(),
        96usize,
        concat!("Size of: ", stringify!(_GSource))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSource>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSource))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(callback_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback_funcs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(callback_funcs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_funcs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(source_funcs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_id) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(source_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poll_fds) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(poll_fds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourceCallbackFuncs {
    pub ref_: ::std::option::Option<unsafe extern "C" fn(cb_data: gpointer)>,
    pub unref: ::std::option::Option<unsafe extern "C" fn(cb_data: gpointer)>,
    pub get: ::std::option::Option<
        unsafe extern "C" fn(
            cb_data: gpointer,
            source: *mut GSource,
            func: *mut GSourceFunc,
            data: *mut gpointer,
        ),
    >,
}
#[test]
fn bindgen_test_layout__GSourceCallbackFuncs() {
    const UNINIT: ::std::mem::MaybeUninit<_GSourceCallbackFuncs> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSourceCallbackFuncs>(),
        24usize,
        concat!("Size of: ", stringify!(_GSourceCallbackFuncs))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSourceCallbackFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSourceCallbackFuncs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceCallbackFuncs),
            "::",
            stringify!(ref_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unref) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceCallbackFuncs),
            "::",
            stringify!(unref)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceCallbackFuncs),
            "::",
            stringify!(get)
        )
    );
}
#[doc = " GSourceDummyMarshal:\n\n This is just a placeholder for #GClosureMarshal,\n which cannot be used here for dependency reasons."]
pub type GSourceDummyMarshal = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourceFuncs {
    pub prepare: ::std::option::Option<
        unsafe extern "C" fn(source: *mut GSource, timeout_: *mut gint) -> gboolean,
    >,
    pub check: ::std::option::Option<unsafe extern "C" fn(source: *mut GSource) -> gboolean>,
    pub dispatch: ::std::option::Option<
        unsafe extern "C" fn(
            source: *mut GSource,
            callback: GSourceFunc,
            user_data: gpointer,
        ) -> gboolean,
    >,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(source: *mut GSource)>,
    pub closure_callback: GSourceFunc,
    pub closure_marshal: GSourceDummyMarshal,
}
#[test]
fn bindgen_test_layout__GSourceFuncs() {
    const UNINIT: ::std::mem::MaybeUninit<_GSourceFuncs> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSourceFuncs>(),
        48usize,
        concat!("Size of: ", stringify!(_GSourceFuncs))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSourceFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSourceFuncs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prepare) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(prepare)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).check) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dispatch) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(dispatch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finalize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).closure_callback) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(closure_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).closure_marshal) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(closure_marshal)
        )
    );
}
extern "C" {
    pub fn g_main_context_new() -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_new_with_flags(flags: GMainContextFlags) -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_ref(context: *mut GMainContext) -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_unref(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_default() -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_iteration(context: *mut GMainContext, may_block: gboolean) -> gboolean;
}
extern "C" {
    pub fn g_main_context_pending(context: *mut GMainContext) -> gboolean;
}
extern "C" {
    pub fn g_main_context_find_source_by_id(
        context: *mut GMainContext,
        source_id: guint,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_main_context_find_source_by_user_data(
        context: *mut GMainContext,
        user_data: gpointer,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_main_context_find_source_by_funcs_user_data(
        context: *mut GMainContext,
        funcs: *mut GSourceFuncs,
        user_data: gpointer,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_main_context_wakeup(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_acquire(context: *mut GMainContext) -> gboolean;
}
extern "C" {
    pub fn g_main_context_release(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_is_owner(context: *mut GMainContext) -> gboolean;
}
extern "C" {
    pub fn g_main_context_wait(
        context: *mut GMainContext,
        cond: *mut GCond,
        mutex: *mut GMutex,
    ) -> gboolean;
}
extern "C" {
    pub fn g_main_context_prepare(context: *mut GMainContext, priority: *mut gint) -> gboolean;
}
extern "C" {
    pub fn g_main_context_query(
        context: *mut GMainContext,
        max_priority: gint,
        timeout_: *mut gint,
        fds: *mut GPollFD,
        n_fds: gint,
    ) -> gint;
}
extern "C" {
    pub fn g_main_context_check(
        context: *mut GMainContext,
        max_priority: gint,
        fds: *mut GPollFD,
        n_fds: gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_main_context_dispatch(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_set_poll_func(context: *mut GMainContext, func: GPollFunc);
}
extern "C" {
    pub fn g_main_context_get_poll_func(context: *mut GMainContext) -> GPollFunc;
}
extern "C" {
    pub fn g_main_context_add_poll(context: *mut GMainContext, fd: *mut GPollFD, priority: gint);
}
extern "C" {
    pub fn g_main_context_remove_poll(context: *mut GMainContext, fd: *mut GPollFD);
}
extern "C" {
    pub fn g_main_depth() -> gint;
}
extern "C" {
    pub fn g_main_current_source() -> *mut GSource;
}
extern "C" {
    pub fn g_main_context_push_thread_default(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_pop_thread_default(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_get_thread_default() -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_ref_thread_default() -> *mut GMainContext;
}
#[doc = " GMainContextPusher:\n\n Opaque type. See g_main_context_pusher_new() for details.\n\n Since: 2.64"]
pub type GMainContextPusher = ::std::os::raw::c_void;
extern "C" {
    pub fn g_main_loop_new(context: *mut GMainContext, is_running: gboolean) -> *mut GMainLoop;
}
extern "C" {
    pub fn g_main_loop_run(loop_: *mut GMainLoop);
}
extern "C" {
    pub fn g_main_loop_quit(loop_: *mut GMainLoop);
}
extern "C" {
    pub fn g_main_loop_ref(loop_: *mut GMainLoop) -> *mut GMainLoop;
}
extern "C" {
    pub fn g_main_loop_unref(loop_: *mut GMainLoop);
}
extern "C" {
    pub fn g_main_loop_is_running(loop_: *mut GMainLoop) -> gboolean;
}
extern "C" {
    pub fn g_main_loop_get_context(loop_: *mut GMainLoop) -> *mut GMainContext;
}
extern "C" {
    pub fn g_source_new(source_funcs: *mut GSourceFuncs, struct_size: guint) -> *mut GSource;
}
extern "C" {
    pub fn g_source_set_dispose_function(source: *mut GSource, dispose: GSourceDisposeFunc);
}
extern "C" {
    pub fn g_source_ref(source: *mut GSource) -> *mut GSource;
}
extern "C" {
    pub fn g_source_unref(source: *mut GSource);
}
extern "C" {
    pub fn g_source_attach(source: *mut GSource, context: *mut GMainContext) -> guint;
}
extern "C" {
    pub fn g_source_destroy(source: *mut GSource);
}
extern "C" {
    pub fn g_source_set_priority(source: *mut GSource, priority: gint);
}
extern "C" {
    pub fn g_source_get_priority(source: *mut GSource) -> gint;
}
extern "C" {
    pub fn g_source_set_can_recurse(source: *mut GSource, can_recurse: gboolean);
}
extern "C" {
    pub fn g_source_get_can_recurse(source: *mut GSource) -> gboolean;
}
extern "C" {
    pub fn g_source_get_id(source: *mut GSource) -> guint;
}
extern "C" {
    pub fn g_source_get_context(source: *mut GSource) -> *mut GMainContext;
}
extern "C" {
    pub fn g_source_set_callback(
        source: *mut GSource,
        func: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_source_set_funcs(source: *mut GSource, funcs: *mut GSourceFuncs);
}
extern "C" {
    pub fn g_source_is_destroyed(source: *mut GSource) -> gboolean;
}
extern "C" {
    pub fn g_source_set_name(source: *mut GSource, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_source_set_static_name(source: *mut GSource, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_source_get_name(source: *mut GSource) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_source_set_name_by_id(tag: guint, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_source_set_ready_time(source: *mut GSource, ready_time: gint64);
}
extern "C" {
    pub fn g_source_get_ready_time(source: *mut GSource) -> gint64;
}
extern "C" {
    pub fn g_source_set_callback_indirect(
        source: *mut GSource,
        callback_data: gpointer,
        callback_funcs: *mut GSourceCallbackFuncs,
    );
}
extern "C" {
    pub fn g_source_add_poll(source: *mut GSource, fd: *mut GPollFD);
}
extern "C" {
    pub fn g_source_remove_poll(source: *mut GSource, fd: *mut GPollFD);
}
extern "C" {
    pub fn g_source_add_child_source(source: *mut GSource, child_source: *mut GSource);
}
extern "C" {
    pub fn g_source_remove_child_source(source: *mut GSource, child_source: *mut GSource);
}
extern "C" {
    pub fn g_source_get_current_time(source: *mut GSource, timeval: *mut GTimeVal);
}
extern "C" {
    pub fn g_source_get_time(source: *mut GSource) -> gint64;
}
extern "C" {
    pub fn g_idle_source_new() -> *mut GSource;
}
extern "C" {
    pub fn g_child_watch_source_new(pid: GPid) -> *mut GSource;
}
extern "C" {
    pub fn g_timeout_source_new(interval: guint) -> *mut GSource;
}
extern "C" {
    pub fn g_timeout_source_new_seconds(interval: guint) -> *mut GSource;
}
extern "C" {
    pub fn g_get_current_time(result: *mut GTimeVal);
}
extern "C" {
    pub fn g_get_monotonic_time() -> gint64;
}
extern "C" {
    pub fn g_get_real_time() -> gint64;
}
extern "C" {
    pub fn g_source_remove(tag: guint) -> gboolean;
}
extern "C" {
    pub fn g_source_remove_by_user_data(user_data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_source_remove_by_funcs_user_data(
        funcs: *mut GSourceFuncs,
        user_data: gpointer,
    ) -> gboolean;
}
#[doc = " GClearHandleFunc:\n @handle_id: the handle ID to clear\n\n Specifies the type of function passed to g_clear_handle_id().\n The implementation is expected to free the resource identified\n by @handle_id; for instance, if @handle_id is a #GSource ID,\n g_source_remove() can be used.\n\n Since: 2.56"]
pub type GClearHandleFunc = ::std::option::Option<unsafe extern "C" fn(handle_id: guint)>;
extern "C" {
    pub fn g_clear_handle_id(tag_ptr: *mut guint, clear_func: GClearHandleFunc);
}
extern "C" {
    pub fn g_timeout_add_full(
        priority: gint,
        interval: guint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_timeout_add(interval: guint, function: GSourceFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_timeout_add_once(interval: guint, function: GSourceOnceFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_timeout_add_seconds_full(
        priority: gint,
        interval: guint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_timeout_add_seconds(interval: guint, function: GSourceFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_timeout_add_seconds_once(
        interval: guint,
        function: GSourceOnceFunc,
        data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_child_watch_add_full(
        priority: gint,
        pid: GPid,
        function: GChildWatchFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_child_watch_add(pid: GPid, function: GChildWatchFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_idle_add(function: GSourceFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_idle_add_full(
        priority: gint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_idle_add_once(function: GSourceOnceFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_idle_remove_by_data(data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_main_context_invoke_full(
        context: *mut GMainContext,
        priority: gint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_main_context_invoke(context: *mut GMainContext, function: GSourceFunc, data: gpointer);
}
extern "C" {
    pub static mut g_timeout_funcs: GSourceFuncs;
}
extern "C" {
    pub static mut g_child_watch_funcs: GSourceFuncs;
}
extern "C" {
    pub static mut g_idle_funcs: GSourceFuncs;
}
#[doc = " gunichar:\n\n A type which can hold any UTF-32 or UCS-4 character code,\n also known as a Unicode code point.\n\n If you want to produce the UTF-8 representation of a #gunichar,\n use g_ucs4_to_utf8(). See also g_utf8_to_ucs4() for the reverse\n process.\n\n To print/scan values of this type as integer, use\n %G_GINT32_MODIFIER and/or %G_GUINT32_FORMAT.\n\n The notation to express a Unicode code point in running text is\n as a hexadecimal number with four to six digits and uppercase\n letters, prefixed by the string \"U+\". Leading zeros are omitted,\n unless the code point would have fewer than four hexadecimal digits.\n For example, \"U+0041 LATIN CAPITAL LETTER A\". To print a code point\n in the U+-notation, use the format string \"U+\\%04\"G_GINT32_FORMAT\"X\".\n To scan, use the format string \"U+\\%06\"G_GINT32_FORMAT\"X\".\n\n |[\n gunichar c;\n sscanf (\"U+0041\", \"U+%06\"G_GINT32_FORMAT\"X\", &amp;c)\n g_print (\"Read U+%04\"G_GINT32_FORMAT\"X\", c);\n ]|"]
pub type gunichar = guint32;
#[doc = " gunichar2:\n\n A type which can hold any UTF-16 code\n point<footnote id=\"utf16_surrogate_pairs\">UTF-16 also has so called\n <firstterm>surrogate pairs</firstterm> to encode characters beyond\n the BMP as pairs of 16bit numbers. Surrogate pairs cannot be stored\n in a single gunichar2 field, but all GLib functions accepting gunichar2\n arrays will correctly interpret surrogate pairs.</footnote>.\n\n To print/scan values of this type to/from text you need to convert\n to/from UTF-8, using g_utf16_to_utf8()/g_utf8_to_utf16().\n\n To print/scan values of this type as integer, use\n %G_GINT16_MODIFIER and/or %G_GUINT16_FORMAT."]
pub type gunichar2 = guint16;
pub const GUnicodeType_G_UNICODE_CONTROL: GUnicodeType = 0;
pub const GUnicodeType_G_UNICODE_FORMAT: GUnicodeType = 1;
pub const GUnicodeType_G_UNICODE_UNASSIGNED: GUnicodeType = 2;
pub const GUnicodeType_G_UNICODE_PRIVATE_USE: GUnicodeType = 3;
pub const GUnicodeType_G_UNICODE_SURROGATE: GUnicodeType = 4;
pub const GUnicodeType_G_UNICODE_LOWERCASE_LETTER: GUnicodeType = 5;
pub const GUnicodeType_G_UNICODE_MODIFIER_LETTER: GUnicodeType = 6;
pub const GUnicodeType_G_UNICODE_OTHER_LETTER: GUnicodeType = 7;
pub const GUnicodeType_G_UNICODE_TITLECASE_LETTER: GUnicodeType = 8;
pub const GUnicodeType_G_UNICODE_UPPERCASE_LETTER: GUnicodeType = 9;
pub const GUnicodeType_G_UNICODE_SPACING_MARK: GUnicodeType = 10;
pub const GUnicodeType_G_UNICODE_ENCLOSING_MARK: GUnicodeType = 11;
pub const GUnicodeType_G_UNICODE_NON_SPACING_MARK: GUnicodeType = 12;
pub const GUnicodeType_G_UNICODE_DECIMAL_NUMBER: GUnicodeType = 13;
pub const GUnicodeType_G_UNICODE_LETTER_NUMBER: GUnicodeType = 14;
pub const GUnicodeType_G_UNICODE_OTHER_NUMBER: GUnicodeType = 15;
pub const GUnicodeType_G_UNICODE_CONNECT_PUNCTUATION: GUnicodeType = 16;
pub const GUnicodeType_G_UNICODE_DASH_PUNCTUATION: GUnicodeType = 17;
pub const GUnicodeType_G_UNICODE_CLOSE_PUNCTUATION: GUnicodeType = 18;
pub const GUnicodeType_G_UNICODE_FINAL_PUNCTUATION: GUnicodeType = 19;
pub const GUnicodeType_G_UNICODE_INITIAL_PUNCTUATION: GUnicodeType = 20;
pub const GUnicodeType_G_UNICODE_OTHER_PUNCTUATION: GUnicodeType = 21;
pub const GUnicodeType_G_UNICODE_OPEN_PUNCTUATION: GUnicodeType = 22;
pub const GUnicodeType_G_UNICODE_CURRENCY_SYMBOL: GUnicodeType = 23;
pub const GUnicodeType_G_UNICODE_MODIFIER_SYMBOL: GUnicodeType = 24;
pub const GUnicodeType_G_UNICODE_MATH_SYMBOL: GUnicodeType = 25;
pub const GUnicodeType_G_UNICODE_OTHER_SYMBOL: GUnicodeType = 26;
pub const GUnicodeType_G_UNICODE_LINE_SEPARATOR: GUnicodeType = 27;
pub const GUnicodeType_G_UNICODE_PARAGRAPH_SEPARATOR: GUnicodeType = 28;
pub const GUnicodeType_G_UNICODE_SPACE_SEPARATOR: GUnicodeType = 29;
#[doc = " GUnicodeType:\n @G_UNICODE_CONTROL: General category \"Other, Control\" (Cc)\n @G_UNICODE_FORMAT: General category \"Other, Format\" (Cf)\n @G_UNICODE_UNASSIGNED: General category \"Other, Not Assigned\" (Cn)\n @G_UNICODE_PRIVATE_USE: General category \"Other, Private Use\" (Co)\n @G_UNICODE_SURROGATE: General category \"Other, Surrogate\" (Cs)\n @G_UNICODE_LOWERCASE_LETTER: General category \"Letter, Lowercase\" (Ll)\n @G_UNICODE_MODIFIER_LETTER: General category \"Letter, Modifier\" (Lm)\n @G_UNICODE_OTHER_LETTER: General category \"Letter, Other\" (Lo)\n @G_UNICODE_TITLECASE_LETTER: General category \"Letter, Titlecase\" (Lt)\n @G_UNICODE_UPPERCASE_LETTER: General category \"Letter, Uppercase\" (Lu)\n @G_UNICODE_SPACING_MARK: General category \"Mark, Spacing\" (Mc)\n @G_UNICODE_ENCLOSING_MARK: General category \"Mark, Enclosing\" (Me)\n @G_UNICODE_NON_SPACING_MARK: General category \"Mark, Nonspacing\" (Mn)\n @G_UNICODE_DECIMAL_NUMBER: General category \"Number, Decimal Digit\" (Nd)\n @G_UNICODE_LETTER_NUMBER: General category \"Number, Letter\" (Nl)\n @G_UNICODE_OTHER_NUMBER: General category \"Number, Other\" (No)\n @G_UNICODE_CONNECT_PUNCTUATION: General category \"Punctuation, Connector\" (Pc)\n @G_UNICODE_DASH_PUNCTUATION: General category \"Punctuation, Dash\" (Pd)\n @G_UNICODE_CLOSE_PUNCTUATION: General category \"Punctuation, Close\" (Pe)\n @G_UNICODE_FINAL_PUNCTUATION: General category \"Punctuation, Final quote\" (Pf)\n @G_UNICODE_INITIAL_PUNCTUATION: General category \"Punctuation, Initial quote\" (Pi)\n @G_UNICODE_OTHER_PUNCTUATION: General category \"Punctuation, Other\" (Po)\n @G_UNICODE_OPEN_PUNCTUATION: General category \"Punctuation, Open\" (Ps)\n @G_UNICODE_CURRENCY_SYMBOL: General category \"Symbol, Currency\" (Sc)\n @G_UNICODE_MODIFIER_SYMBOL: General category \"Symbol, Modifier\" (Sk)\n @G_UNICODE_MATH_SYMBOL: General category \"Symbol, Math\" (Sm)\n @G_UNICODE_OTHER_SYMBOL: General category \"Symbol, Other\" (So)\n @G_UNICODE_LINE_SEPARATOR: General category \"Separator, Line\" (Zl)\n @G_UNICODE_PARAGRAPH_SEPARATOR: General category \"Separator, Paragraph\" (Zp)\n @G_UNICODE_SPACE_SEPARATOR: General category \"Separator, Space\" (Zs)\n\n These are the possible character classifications from the\n Unicode specification.\n See [Unicode Character Database](http://www.unicode.org/reports/tr44/#General_Category_Values)."]
pub type GUnicodeType = ::std::os::raw::c_int;
pub const GUnicodeBreakType_G_UNICODE_BREAK_MANDATORY: GUnicodeBreakType = 0;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CARRIAGE_RETURN: GUnicodeBreakType = 1;
pub const GUnicodeBreakType_G_UNICODE_BREAK_LINE_FEED: GUnicodeBreakType = 2;
pub const GUnicodeBreakType_G_UNICODE_BREAK_COMBINING_MARK: GUnicodeBreakType = 3;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SURROGATE: GUnicodeBreakType = 4;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ZERO_WIDTH_SPACE: GUnicodeBreakType = 5;
pub const GUnicodeBreakType_G_UNICODE_BREAK_INSEPARABLE: GUnicodeBreakType = 6;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NON_BREAKING_GLUE: GUnicodeBreakType = 7;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CONTINGENT: GUnicodeBreakType = 8;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SPACE: GUnicodeBreakType = 9;
pub const GUnicodeBreakType_G_UNICODE_BREAK_AFTER: GUnicodeBreakType = 10;
pub const GUnicodeBreakType_G_UNICODE_BREAK_BEFORE: GUnicodeBreakType = 11;
pub const GUnicodeBreakType_G_UNICODE_BREAK_BEFORE_AND_AFTER: GUnicodeBreakType = 12;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HYPHEN: GUnicodeBreakType = 13;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NON_STARTER: GUnicodeBreakType = 14;
pub const GUnicodeBreakType_G_UNICODE_BREAK_OPEN_PUNCTUATION: GUnicodeBreakType = 15;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PUNCTUATION: GUnicodeBreakType = 16;
pub const GUnicodeBreakType_G_UNICODE_BREAK_QUOTATION: GUnicodeBreakType = 17;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EXCLAMATION: GUnicodeBreakType = 18;
pub const GUnicodeBreakType_G_UNICODE_BREAK_IDEOGRAPHIC: GUnicodeBreakType = 19;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NUMERIC: GUnicodeBreakType = 20;
pub const GUnicodeBreakType_G_UNICODE_BREAK_INFIX_SEPARATOR: GUnicodeBreakType = 21;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SYMBOL: GUnicodeBreakType = 22;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ALPHABETIC: GUnicodeBreakType = 23;
pub const GUnicodeBreakType_G_UNICODE_BREAK_PREFIX: GUnicodeBreakType = 24;
pub const GUnicodeBreakType_G_UNICODE_BREAK_POSTFIX: GUnicodeBreakType = 25;
pub const GUnicodeBreakType_G_UNICODE_BREAK_COMPLEX_CONTEXT: GUnicodeBreakType = 26;
pub const GUnicodeBreakType_G_UNICODE_BREAK_AMBIGUOUS: GUnicodeBreakType = 27;
pub const GUnicodeBreakType_G_UNICODE_BREAK_UNKNOWN: GUnicodeBreakType = 28;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NEXT_LINE: GUnicodeBreakType = 29;
pub const GUnicodeBreakType_G_UNICODE_BREAK_WORD_JOINER: GUnicodeBreakType = 30;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_L_JAMO: GUnicodeBreakType = 31;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_V_JAMO: GUnicodeBreakType = 32;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_T_JAMO: GUnicodeBreakType = 33;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: GUnicodeBreakType = 34;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: GUnicodeBreakType = 35;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PARANTHESIS: GUnicodeBreakType = 36;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PARENTHESIS: GUnicodeBreakType = 36;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: GUnicodeBreakType = 37;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HEBREW_LETTER: GUnicodeBreakType = 38;
pub const GUnicodeBreakType_G_UNICODE_BREAK_REGIONAL_INDICATOR: GUnicodeBreakType = 39;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EMOJI_BASE: GUnicodeBreakType = 40;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EMOJI_MODIFIER: GUnicodeBreakType = 41;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ZERO_WIDTH_JOINER: GUnicodeBreakType = 42;
#[doc = " GUnicodeBreakType:\n @G_UNICODE_BREAK_MANDATORY: Mandatory Break (BK)\n @G_UNICODE_BREAK_CARRIAGE_RETURN: Carriage Return (CR)\n @G_UNICODE_BREAK_LINE_FEED: Line Feed (LF)\n @G_UNICODE_BREAK_COMBINING_MARK: Attached Characters and Combining Marks (CM)\n @G_UNICODE_BREAK_SURROGATE: Surrogates (SG)\n @G_UNICODE_BREAK_ZERO_WIDTH_SPACE: Zero Width Space (ZW)\n @G_UNICODE_BREAK_INSEPARABLE: Inseparable (IN)\n @G_UNICODE_BREAK_NON_BREAKING_GLUE: Non-breaking (\"Glue\") (GL)\n @G_UNICODE_BREAK_CONTINGENT: Contingent Break Opportunity (CB)\n @G_UNICODE_BREAK_SPACE: Space (SP)\n @G_UNICODE_BREAK_AFTER: Break Opportunity After (BA)\n @G_UNICODE_BREAK_BEFORE: Break Opportunity Before (BB)\n @G_UNICODE_BREAK_BEFORE_AND_AFTER: Break Opportunity Before and After (B2)\n @G_UNICODE_BREAK_HYPHEN: Hyphen (HY)\n @G_UNICODE_BREAK_NON_STARTER: Nonstarter (NS)\n @G_UNICODE_BREAK_OPEN_PUNCTUATION: Opening Punctuation (OP)\n @G_UNICODE_BREAK_CLOSE_PUNCTUATION: Closing Punctuation (CL)\n @G_UNICODE_BREAK_QUOTATION: Ambiguous Quotation (QU)\n @G_UNICODE_BREAK_EXCLAMATION: Exclamation/Interrogation (EX)\n @G_UNICODE_BREAK_IDEOGRAPHIC: Ideographic (ID)\n @G_UNICODE_BREAK_NUMERIC: Numeric (NU)\n @G_UNICODE_BREAK_INFIX_SEPARATOR: Infix Separator (Numeric) (IS)\n @G_UNICODE_BREAK_SYMBOL: Symbols Allowing Break After (SY)\n @G_UNICODE_BREAK_ALPHABETIC: Ordinary Alphabetic and Symbol Characters (AL)\n @G_UNICODE_BREAK_PREFIX: Prefix (Numeric) (PR)\n @G_UNICODE_BREAK_POSTFIX: Postfix (Numeric) (PO)\n @G_UNICODE_BREAK_COMPLEX_CONTEXT: Complex Content Dependent (South East Asian) (SA)\n @G_UNICODE_BREAK_AMBIGUOUS: Ambiguous (Alphabetic or Ideographic) (AI)\n @G_UNICODE_BREAK_UNKNOWN: Unknown (XX)\n @G_UNICODE_BREAK_NEXT_LINE: Next Line (NL)\n @G_UNICODE_BREAK_WORD_JOINER: Word Joiner (WJ)\n @G_UNICODE_BREAK_HANGUL_L_JAMO: Hangul L Jamo (JL)\n @G_UNICODE_BREAK_HANGUL_V_JAMO: Hangul V Jamo (JV)\n @G_UNICODE_BREAK_HANGUL_T_JAMO: Hangul T Jamo (JT)\n @G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: Hangul LV Syllable (H2)\n @G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: Hangul LVT Syllable (H3)\n @G_UNICODE_BREAK_CLOSE_PARANTHESIS: Closing Parenthesis (CP). Since 2.28. Deprecated: 2.70: Use %G_UNICODE_BREAK_CLOSE_PARENTHESIS instead.\n @G_UNICODE_BREAK_CLOSE_PARENTHESIS: Closing Parenthesis (CP). Since 2.70\n @G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: Conditional Japanese Starter (CJ). Since: 2.32\n @G_UNICODE_BREAK_HEBREW_LETTER: Hebrew Letter (HL). Since: 2.32\n @G_UNICODE_BREAK_REGIONAL_INDICATOR: Regional Indicator (RI). Since: 2.36\n @G_UNICODE_BREAK_EMOJI_BASE: Emoji Base (EB). Since: 2.50\n @G_UNICODE_BREAK_EMOJI_MODIFIER: Emoji Modifier (EM). Since: 2.50\n @G_UNICODE_BREAK_ZERO_WIDTH_JOINER: Zero Width Joiner (ZWJ). Since: 2.50\n\n These are the possible line break classifications.\n\n Since new unicode versions may add new types here, applications should be ready\n to handle unknown values. They may be regarded as %G_UNICODE_BREAK_UNKNOWN.\n\n See [Unicode Line Breaking Algorithm](https://www.unicode.org/reports/tr14/)."]
pub type GUnicodeBreakType = ::std::os::raw::c_int;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INVALID_CODE: GUnicodeScript = -1;
pub const GUnicodeScript_G_UNICODE_SCRIPT_COMMON: GUnicodeScript = 0;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INHERITED: GUnicodeScript = 1;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ARABIC: GUnicodeScript = 2;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ARMENIAN: GUnicodeScript = 3;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BENGALI: GUnicodeScript = 4;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BOPOMOFO: GUnicodeScript = 5;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHEROKEE: GUnicodeScript = 6;
pub const GUnicodeScript_G_UNICODE_SCRIPT_COPTIC: GUnicodeScript = 7;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYRILLIC: GUnicodeScript = 8;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DESERET: GUnicodeScript = 9;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DEVANAGARI: GUnicodeScript = 10;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ETHIOPIC: GUnicodeScript = 11;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GEORGIAN: GUnicodeScript = 12;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GOTHIC: GUnicodeScript = 13;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GREEK: GUnicodeScript = 14;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GUJARATI: GUnicodeScript = 15;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GURMUKHI: GUnicodeScript = 16;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HAN: GUnicodeScript = 17;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANGUL: GUnicodeScript = 18;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HEBREW: GUnicodeScript = 19;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HIRAGANA: GUnicodeScript = 20;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KANNADA: GUnicodeScript = 21;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KATAKANA: GUnicodeScript = 22;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHMER: GUnicodeScript = 23;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LAO: GUnicodeScript = 24;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LATIN: GUnicodeScript = 25;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MALAYALAM: GUnicodeScript = 26;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MONGOLIAN: GUnicodeScript = 27;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MYANMAR: GUnicodeScript = 28;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OGHAM: GUnicodeScript = 29;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_ITALIC: GUnicodeScript = 30;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ORIYA: GUnicodeScript = 31;
pub const GUnicodeScript_G_UNICODE_SCRIPT_RUNIC: GUnicodeScript = 32;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SINHALA: GUnicodeScript = 33;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SYRIAC: GUnicodeScript = 34;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAMIL: GUnicodeScript = 35;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TELUGU: GUnicodeScript = 36;
pub const GUnicodeScript_G_UNICODE_SCRIPT_THAANA: GUnicodeScript = 37;
pub const GUnicodeScript_G_UNICODE_SCRIPT_THAI: GUnicodeScript = 38;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIBETAN: GUnicodeScript = 39;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL: GUnicodeScript = 40;
pub const GUnicodeScript_G_UNICODE_SCRIPT_YI: GUnicodeScript = 41;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAGALOG: GUnicodeScript = 42;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANUNOO: GUnicodeScript = 43;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BUHID: GUnicodeScript = 44;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAGBANWA: GUnicodeScript = 45;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BRAILLE: GUnicodeScript = 46;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYPRIOT: GUnicodeScript = 47;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LIMBU: GUnicodeScript = 48;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OSMANYA: GUnicodeScript = 49;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SHAVIAN: GUnicodeScript = 50;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LINEAR_B: GUnicodeScript = 51;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_LE: GUnicodeScript = 52;
pub const GUnicodeScript_G_UNICODE_SCRIPT_UGARITIC: GUnicodeScript = 53;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NEW_TAI_LUE: GUnicodeScript = 54;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BUGINESE: GUnicodeScript = 55;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GLAGOLITIC: GUnicodeScript = 56;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIFINAGH: GUnicodeScript = 57;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SYLOTI_NAGRI: GUnicodeScript = 58;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_PERSIAN: GUnicodeScript = 59;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHAROSHTHI: GUnicodeScript = 60;
pub const GUnicodeScript_G_UNICODE_SCRIPT_UNKNOWN: GUnicodeScript = 61;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BALINESE: GUnicodeScript = 62;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CUNEIFORM: GUnicodeScript = 63;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PHOENICIAN: GUnicodeScript = 64;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PHAGS_PA: GUnicodeScript = 65;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NKO: GUnicodeScript = 66;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAYAH_LI: GUnicodeScript = 67;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LEPCHA: GUnicodeScript = 68;
pub const GUnicodeScript_G_UNICODE_SCRIPT_REJANG: GUnicodeScript = 69;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SUNDANESE: GUnicodeScript = 70;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SAURASHTRA: GUnicodeScript = 71;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHAM: GUnicodeScript = 72;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OL_CHIKI: GUnicodeScript = 73;
pub const GUnicodeScript_G_UNICODE_SCRIPT_VAI: GUnicodeScript = 74;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CARIAN: GUnicodeScript = 75;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LYCIAN: GUnicodeScript = 76;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LYDIAN: GUnicodeScript = 77;
pub const GUnicodeScript_G_UNICODE_SCRIPT_AVESTAN: GUnicodeScript = 78;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BAMUM: GUnicodeScript = 79;
pub const GUnicodeScript_G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS: GUnicodeScript = 80;
pub const GUnicodeScript_G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC: GUnicodeScript = 81;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI: GUnicodeScript = 82;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN: GUnicodeScript = 83;
pub const GUnicodeScript_G_UNICODE_SCRIPT_JAVANESE: GUnicodeScript = 84;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAITHI: GUnicodeScript = 85;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LISU: GUnicodeScript = 86;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEETEI_MAYEK: GUnicodeScript = 87;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN: GUnicodeScript = 88;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_TURKIC: GUnicodeScript = 89;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SAMARITAN: GUnicodeScript = 90;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_THAM: GUnicodeScript = 91;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_VIET: GUnicodeScript = 92;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BATAK: GUnicodeScript = 93;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BRAHMI: GUnicodeScript = 94;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MANDAIC: GUnicodeScript = 95;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHAKMA: GUnicodeScript = 96;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEROITIC_CURSIVE: GUnicodeScript = 97;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: GUnicodeScript = 98;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MIAO: GUnicodeScript = 99;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SHARADA: GUnicodeScript = 100;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SORA_SOMPENG: GUnicodeScript = 101;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAKRI: GUnicodeScript = 102;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BASSA_VAH: GUnicodeScript = 103;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN: GUnicodeScript = 104;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DUPLOYAN: GUnicodeScript = 105;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ELBASAN: GUnicodeScript = 106;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GRANTHA: GUnicodeScript = 107;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHOJKI: GUnicodeScript = 108;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHUDAWADI: GUnicodeScript = 109;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LINEAR_A: GUnicodeScript = 110;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MAHAJANI: GUnicodeScript = 111;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MANICHAEAN: GUnicodeScript = 112;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MENDE_KIKAKUI: GUnicodeScript = 113;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MODI: GUnicodeScript = 114;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MRO: GUnicodeScript = 115;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NABATAEAN: GUnicodeScript = 116;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN: GUnicodeScript = 117;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_PERMIC: GUnicodeScript = 118;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PAHAWH_HMONG: GUnicodeScript = 119;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PALMYRENE: GUnicodeScript = 120;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PAU_CIN_HAU: GUnicodeScript = 121;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PSALTER_PAHLAVI: GUnicodeScript = 122;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SIDDHAM: GUnicodeScript = 123;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIRHUTA: GUnicodeScript = 124;
pub const GUnicodeScript_G_UNICODE_SCRIPT_WARANG_CITI: GUnicodeScript = 125;
pub const GUnicodeScript_G_UNICODE_SCRIPT_AHOM: GUnicodeScript = 126;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: GUnicodeScript = 127;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HATRAN: GUnicodeScript = 128;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MULTANI: GUnicodeScript = 129;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_HUNGARIAN: GUnicodeScript = 130;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SIGNWRITING: GUnicodeScript = 131;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ADLAM: GUnicodeScript = 132;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BHAIKSUKI: GUnicodeScript = 133;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MARCHEN: GUnicodeScript = 134;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NEWA: GUnicodeScript = 135;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OSAGE: GUnicodeScript = 136;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TANGUT: GUnicodeScript = 137;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MASARAM_GONDI: GUnicodeScript = 138;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NUSHU: GUnicodeScript = 139;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SOYOMBO: GUnicodeScript = 140;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ZANABAZAR_SQUARE: GUnicodeScript = 141;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DOGRA: GUnicodeScript = 142;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GUNJALA_GONDI: GUnicodeScript = 143;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANIFI_ROHINGYA: GUnicodeScript = 144;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MAKASAR: GUnicodeScript = 145;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEDEFAIDRIN: GUnicodeScript = 146;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_SOGDIAN: GUnicodeScript = 147;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SOGDIAN: GUnicodeScript = 148;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ELYMAIC: GUnicodeScript = 149;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NANDINAGARI: GUnicodeScript = 150;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG: GUnicodeScript = 151;
pub const GUnicodeScript_G_UNICODE_SCRIPT_WANCHO: GUnicodeScript = 152;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHORASMIAN: GUnicodeScript = 153;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DIVES_AKURU: GUnicodeScript = 154;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT: GUnicodeScript = 155;
pub const GUnicodeScript_G_UNICODE_SCRIPT_YEZIDI: GUnicodeScript = 156;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYPRO_MINOAN: GUnicodeScript = 157;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_UYGHUR: GUnicodeScript = 158;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TANGSA: GUnicodeScript = 159;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TOTO: GUnicodeScript = 160;
pub const GUnicodeScript_G_UNICODE_SCRIPT_VITHKUQI: GUnicodeScript = 161;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MATH: GUnicodeScript = 162;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAWI: GUnicodeScript = 163;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NAG_MUNDARI: GUnicodeScript = 164;
#[doc = " GUnicodeScript:\n @G_UNICODE_SCRIPT_INVALID_CODE:\n                               a value never returned from g_unichar_get_script()\n @G_UNICODE_SCRIPT_COMMON:     a character used by multiple different scripts\n @G_UNICODE_SCRIPT_INHERITED:  a mark glyph that takes its script from the\n                               base glyph to which it is attached\n @G_UNICODE_SCRIPT_ARABIC:     Arabic\n @G_UNICODE_SCRIPT_ARMENIAN:   Armenian\n @G_UNICODE_SCRIPT_BENGALI:    Bengali\n @G_UNICODE_SCRIPT_BOPOMOFO:   Bopomofo\n @G_UNICODE_SCRIPT_CHEROKEE:   Cherokee\n @G_UNICODE_SCRIPT_COPTIC:     Coptic\n @G_UNICODE_SCRIPT_CYRILLIC:   Cyrillic\n @G_UNICODE_SCRIPT_DESERET:    Deseret\n @G_UNICODE_SCRIPT_DEVANAGARI: Devanagari\n @G_UNICODE_SCRIPT_ETHIOPIC:   Ethiopic\n @G_UNICODE_SCRIPT_GEORGIAN:   Georgian\n @G_UNICODE_SCRIPT_GOTHIC:     Gothic\n @G_UNICODE_SCRIPT_GREEK:      Greek\n @G_UNICODE_SCRIPT_GUJARATI:   Gujarati\n @G_UNICODE_SCRIPT_GURMUKHI:   Gurmukhi\n @G_UNICODE_SCRIPT_HAN:        Han\n @G_UNICODE_SCRIPT_HANGUL:     Hangul\n @G_UNICODE_SCRIPT_HEBREW:     Hebrew\n @G_UNICODE_SCRIPT_HIRAGANA:   Hiragana\n @G_UNICODE_SCRIPT_KANNADA:    Kannada\n @G_UNICODE_SCRIPT_KATAKANA:   Katakana\n @G_UNICODE_SCRIPT_KHMER:      Khmer\n @G_UNICODE_SCRIPT_LAO:        Lao\n @G_UNICODE_SCRIPT_LATIN:      Latin\n @G_UNICODE_SCRIPT_MALAYALAM:  Malayalam\n @G_UNICODE_SCRIPT_MONGOLIAN:  Mongolian\n @G_UNICODE_SCRIPT_MYANMAR:    Myanmar\n @G_UNICODE_SCRIPT_OGHAM:      Ogham\n @G_UNICODE_SCRIPT_OLD_ITALIC: Old Italic\n @G_UNICODE_SCRIPT_ORIYA:      Oriya\n @G_UNICODE_SCRIPT_RUNIC:      Runic\n @G_UNICODE_SCRIPT_SINHALA:    Sinhala\n @G_UNICODE_SCRIPT_SYRIAC:     Syriac\n @G_UNICODE_SCRIPT_TAMIL:      Tamil\n @G_UNICODE_SCRIPT_TELUGU:     Telugu\n @G_UNICODE_SCRIPT_THAANA:     Thaana\n @G_UNICODE_SCRIPT_THAI:       Thai\n @G_UNICODE_SCRIPT_TIBETAN:    Tibetan\n @G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL:\n                               Canadian Aboriginal\n @G_UNICODE_SCRIPT_YI:         Yi\n @G_UNICODE_SCRIPT_TAGALOG:    Tagalog\n @G_UNICODE_SCRIPT_HANUNOO:    Hanunoo\n @G_UNICODE_SCRIPT_BUHID:      Buhid\n @G_UNICODE_SCRIPT_TAGBANWA:   Tagbanwa\n @G_UNICODE_SCRIPT_BRAILLE:    Braille\n @G_UNICODE_SCRIPT_CYPRIOT:    Cypriot\n @G_UNICODE_SCRIPT_LIMBU:      Limbu\n @G_UNICODE_SCRIPT_OSMANYA:    Osmanya\n @G_UNICODE_SCRIPT_SHAVIAN:    Shavian\n @G_UNICODE_SCRIPT_LINEAR_B:   Linear B\n @G_UNICODE_SCRIPT_TAI_LE:     Tai Le\n @G_UNICODE_SCRIPT_UGARITIC:   Ugaritic\n @G_UNICODE_SCRIPT_NEW_TAI_LUE:\n                               New Tai Lue\n @G_UNICODE_SCRIPT_BUGINESE:   Buginese\n @G_UNICODE_SCRIPT_GLAGOLITIC: Glagolitic\n @G_UNICODE_SCRIPT_TIFINAGH:   Tifinagh\n @G_UNICODE_SCRIPT_SYLOTI_NAGRI:\n                               Syloti Nagri\n @G_UNICODE_SCRIPT_OLD_PERSIAN:\n                               Old Persian\n @G_UNICODE_SCRIPT_KHAROSHTHI: Kharoshthi\n @G_UNICODE_SCRIPT_UNKNOWN:    an unassigned code point\n @G_UNICODE_SCRIPT_BALINESE:   Balinese\n @G_UNICODE_SCRIPT_CUNEIFORM:  Cuneiform\n @G_UNICODE_SCRIPT_PHOENICIAN: Phoenician\n @G_UNICODE_SCRIPT_PHAGS_PA:   Phags-pa\n @G_UNICODE_SCRIPT_NKO:        N'Ko\n @G_UNICODE_SCRIPT_KAYAH_LI:   Kayah Li. Since 2.16.3\n @G_UNICODE_SCRIPT_LEPCHA:     Lepcha. Since 2.16.3\n @G_UNICODE_SCRIPT_REJANG:     Rejang. Since 2.16.3\n @G_UNICODE_SCRIPT_SUNDANESE:  Sundanese. Since 2.16.3\n @G_UNICODE_SCRIPT_SAURASHTRA: Saurashtra. Since 2.16.3\n @G_UNICODE_SCRIPT_CHAM:       Cham. Since 2.16.3\n @G_UNICODE_SCRIPT_OL_CHIKI:   Ol Chiki. Since 2.16.3\n @G_UNICODE_SCRIPT_VAI:        Vai. Since 2.16.3\n @G_UNICODE_SCRIPT_CARIAN:     Carian. Since 2.16.3\n @G_UNICODE_SCRIPT_LYCIAN:     Lycian. Since 2.16.3\n @G_UNICODE_SCRIPT_LYDIAN:     Lydian. Since 2.16.3\n @G_UNICODE_SCRIPT_AVESTAN:    Avestan. Since 2.26\n @G_UNICODE_SCRIPT_BAMUM:      Bamum. Since 2.26\n @G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS:\n                               Egyptian Hieroglpyhs. Since 2.26\n @G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC:\n                               Imperial Aramaic. Since 2.26\n @G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI:\n                               Inscriptional Pahlavi. Since 2.26\n @G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN:\n                               Inscriptional Parthian. Since 2.26\n @G_UNICODE_SCRIPT_JAVANESE:   Javanese. Since 2.26\n @G_UNICODE_SCRIPT_KAITHI:     Kaithi. Since 2.26\n @G_UNICODE_SCRIPT_LISU:       Lisu. Since 2.26\n @G_UNICODE_SCRIPT_MEETEI_MAYEK:\n                               Meetei Mayek. Since 2.26\n @G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN:\n                               Old South Arabian. Since 2.26\n @G_UNICODE_SCRIPT_OLD_TURKIC: Old Turkic. Since 2.28\n @G_UNICODE_SCRIPT_SAMARITAN:  Samaritan. Since 2.26\n @G_UNICODE_SCRIPT_TAI_THAM:   Tai Tham. Since 2.26\n @G_UNICODE_SCRIPT_TAI_VIET:   Tai Viet. Since 2.26\n @G_UNICODE_SCRIPT_BATAK:      Batak. Since 2.28\n @G_UNICODE_SCRIPT_BRAHMI:     Brahmi. Since 2.28\n @G_UNICODE_SCRIPT_MANDAIC:    Mandaic. Since 2.28\n @G_UNICODE_SCRIPT_CHAKMA:               Chakma. Since: 2.32\n @G_UNICODE_SCRIPT_MEROITIC_CURSIVE:     Meroitic Cursive. Since: 2.32\n @G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: Meroitic Hieroglyphs. Since: 2.32\n @G_UNICODE_SCRIPT_MIAO:                 Miao. Since: 2.32\n @G_UNICODE_SCRIPT_SHARADA:              Sharada. Since: 2.32\n @G_UNICODE_SCRIPT_SORA_SOMPENG:         Sora Sompeng. Since: 2.32\n @G_UNICODE_SCRIPT_TAKRI:                Takri. Since: 2.32\n @G_UNICODE_SCRIPT_BASSA_VAH:            Bassa. Since: 2.42\n @G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN:   Caucasian Albanian. Since: 2.42\n @G_UNICODE_SCRIPT_DUPLOYAN:             Duployan. Since: 2.42\n @G_UNICODE_SCRIPT_ELBASAN:              Elbasan. Since: 2.42\n @G_UNICODE_SCRIPT_GRANTHA:              Grantha. Since: 2.42\n @G_UNICODE_SCRIPT_KHOJKI:               Kjohki. Since: 2.42\n @G_UNICODE_SCRIPT_KHUDAWADI:            Khudawadi, Sindhi. Since: 2.42\n @G_UNICODE_SCRIPT_LINEAR_A:             Linear A. Since: 2.42\n @G_UNICODE_SCRIPT_MAHAJANI:             Mahajani. Since: 2.42\n @G_UNICODE_SCRIPT_MANICHAEAN:           Manichaean. Since: 2.42\n @G_UNICODE_SCRIPT_MENDE_KIKAKUI:        Mende Kikakui. Since: 2.42\n @G_UNICODE_SCRIPT_MODI:                 Modi. Since: 2.42\n @G_UNICODE_SCRIPT_MRO:                  Mro. Since: 2.42\n @G_UNICODE_SCRIPT_NABATAEAN:            Nabataean. Since: 2.42\n @G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN:    Old North Arabian. Since: 2.42\n @G_UNICODE_SCRIPT_OLD_PERMIC:           Old Permic. Since: 2.42\n @G_UNICODE_SCRIPT_PAHAWH_HMONG:         Pahawh Hmong. Since: 2.42\n @G_UNICODE_SCRIPT_PALMYRENE:            Palmyrene. Since: 2.42\n @G_UNICODE_SCRIPT_PAU_CIN_HAU:          Pau Cin Hau. Since: 2.42\n @G_UNICODE_SCRIPT_PSALTER_PAHLAVI:      Psalter Pahlavi. Since: 2.42\n @G_UNICODE_SCRIPT_SIDDHAM:              Siddham. Since: 2.42\n @G_UNICODE_SCRIPT_TIRHUTA:              Tirhuta. Since: 2.42\n @G_UNICODE_SCRIPT_WARANG_CITI:          Warang Citi. Since: 2.42\n @G_UNICODE_SCRIPT_AHOM:                 Ahom. Since: 2.48\n @G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: Anatolian Hieroglyphs. Since: 2.48\n @G_UNICODE_SCRIPT_HATRAN:               Hatran. Since: 2.48\n @G_UNICODE_SCRIPT_MULTANI:              Multani. Since: 2.48\n @G_UNICODE_SCRIPT_OLD_HUNGARIAN:        Old Hungarian. Since: 2.48\n @G_UNICODE_SCRIPT_SIGNWRITING:          Signwriting. Since: 2.48\n @G_UNICODE_SCRIPT_ADLAM:                Adlam. Since: 2.50\n @G_UNICODE_SCRIPT_BHAIKSUKI:            Bhaiksuki. Since: 2.50\n @G_UNICODE_SCRIPT_MARCHEN:              Marchen. Since: 2.50\n @G_UNICODE_SCRIPT_NEWA:                 Newa. Since: 2.50\n @G_UNICODE_SCRIPT_OSAGE:                Osage. Since: 2.50\n @G_UNICODE_SCRIPT_TANGUT:               Tangut. Since: 2.50\n @G_UNICODE_SCRIPT_MASARAM_GONDI:        Masaram Gondi. Since: 2.54\n @G_UNICODE_SCRIPT_NUSHU:                Nushu. Since: 2.54\n @G_UNICODE_SCRIPT_SOYOMBO:              Soyombo. Since: 2.54\n @G_UNICODE_SCRIPT_ZANABAZAR_SQUARE:     Zanabazar Square. Since: 2.54\n @G_UNICODE_SCRIPT_DOGRA:                Dogra. Since: 2.58\n @G_UNICODE_SCRIPT_GUNJALA_GONDI:        Gunjala Gondi. Since: 2.58\n @G_UNICODE_SCRIPT_HANIFI_ROHINGYA:      Hanifi Rohingya. Since: 2.58\n @G_UNICODE_SCRIPT_MAKASAR:              Makasar. Since: 2.58\n @G_UNICODE_SCRIPT_MEDEFAIDRIN:          Medefaidrin. Since: 2.58\n @G_UNICODE_SCRIPT_OLD_SOGDIAN:          Old Sogdian. Since: 2.58\n @G_UNICODE_SCRIPT_SOGDIAN:              Sogdian. Since: 2.58\n @G_UNICODE_SCRIPT_ELYMAIC:              Elym. Since: 2.62\n @G_UNICODE_SCRIPT_NANDINAGARI:          Nand. Since: 2.62\n @G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG: Rohg. Since: 2.62\n @G_UNICODE_SCRIPT_WANCHO:               Wcho. Since: 2.62\n @G_UNICODE_SCRIPT_CHORASMIAN:           Chorasmian. Since: 2.66\n @G_UNICODE_SCRIPT_DIVES_AKURU:          Dives Akuru. Since: 2.66\n @G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT:  Khitan small script. Since: 2.66\n @G_UNICODE_SCRIPT_YEZIDI:               Yezidi. Since: 2.66\n @G_UNICODE_SCRIPT_CYPRO_MINOAN:         Cypro-Minoan. Since: 2.72\n @G_UNICODE_SCRIPT_OLD_UYGHUR:           Old Uyghur. Since: 2.72\n @G_UNICODE_SCRIPT_TANGSA:               Tangsa. Since: 2.72\n @G_UNICODE_SCRIPT_TOTO:                 Toto. Since: 2.72\n @G_UNICODE_SCRIPT_VITHKUQI:             Vithkuqi. Since: 2.72\n @G_UNICODE_SCRIPT_MATH:                 Mathematical notation. Since: 2.72\n @G_UNICODE_SCRIPT_KAWI:                 Kawi. Since 2.74\n @G_UNICODE_SCRIPT_NAG_MUNDARI:          Nag Mundari. Since 2.74\n\n The #GUnicodeScript enumeration identifies different writing\n systems. The values correspond to the names as defined in the\n Unicode standard. The enumeration has been added in GLib 2.14,\n and is interchangeable with #PangoScript.\n\n Note that new types may be added in the future. Applications\n should be ready to handle unknown values.\n See [Unicode Standard Annex #24: Script names](http://www.unicode.org/reports/tr24/)."]
pub type GUnicodeScript = ::std::os::raw::c_int;
extern "C" {
    pub fn g_unicode_script_to_iso15924(script: GUnicodeScript) -> guint32;
}
extern "C" {
    pub fn g_unicode_script_from_iso15924(iso15924: guint32) -> GUnicodeScript;
}
extern "C" {
    pub fn g_unichar_isalnum(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isalpha(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_iscntrl(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isdigit(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isgraph(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_islower(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isprint(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_ispunct(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isspace(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isupper(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isxdigit(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_istitle(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isdefined(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_iswide(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_iswide_cjk(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_iszerowidth(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_ismark(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_toupper(c: gunichar) -> gunichar;
}
extern "C" {
    pub fn g_unichar_tolower(c: gunichar) -> gunichar;
}
extern "C" {
    pub fn g_unichar_totitle(c: gunichar) -> gunichar;
}
extern "C" {
    pub fn g_unichar_digit_value(c: gunichar) -> gint;
}
extern "C" {
    pub fn g_unichar_xdigit_value(c: gunichar) -> gint;
}
extern "C" {
    pub fn g_unichar_type(c: gunichar) -> GUnicodeType;
}
extern "C" {
    pub fn g_unichar_break_type(c: gunichar) -> GUnicodeBreakType;
}
extern "C" {
    pub fn g_unichar_combining_class(uc: gunichar) -> gint;
}
extern "C" {
    pub fn g_unichar_get_mirror_char(ch: gunichar, mirrored_ch: *mut gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_get_script(ch: gunichar) -> GUnicodeScript;
}
extern "C" {
    pub fn g_unichar_validate(ch: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_compose(a: gunichar, b: gunichar, ch: *mut gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_decompose(ch: gunichar, a: *mut gunichar, b: *mut gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_fully_decompose(
        ch: gunichar,
        compat: gboolean,
        result: *mut gunichar,
        result_len: gsize,
    ) -> gsize;
}
extern "C" {
    pub fn g_unicode_canonical_ordering(string: *mut gunichar, len: gsize);
}
extern "C" {
    pub fn g_unicode_canonical_decomposition(ch: gunichar, result_len: *mut gsize)
        -> *mut gunichar;
}
extern "C" {
    pub static g_utf8_skip: *const gchar;
}
extern "C" {
    pub fn g_utf8_get_char(p: *const gchar) -> gunichar;
}
extern "C" {
    pub fn g_utf8_get_char_validated(p: *const gchar, max_len: gssize) -> gunichar;
}
extern "C" {
    pub fn g_utf8_offset_to_pointer(str_: *const gchar, offset: glong) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_pointer_to_offset(str_: *const gchar, pos: *const gchar) -> glong;
}
extern "C" {
    pub fn g_utf8_prev_char(p: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_find_next_char(p: *const gchar, end: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_find_prev_char(str_: *const gchar, p: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strlen(p: *const gchar, max: gssize) -> glong;
}
extern "C" {
    pub fn g_utf8_substring(str_: *const gchar, start_pos: glong, end_pos: glong) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strncpy(dest: *mut gchar, src: *const gchar, n: gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_truncate_middle(string: *const gchar, truncate_length: gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strchr(p: *const gchar, len: gssize, c: gunichar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strrchr(p: *const gchar, len: gssize, c: gunichar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strreverse(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_to_utf16(
        str_: *const gchar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar2;
}
extern "C" {
    pub fn g_utf8_to_ucs4(
        str_: *const gchar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar;
}
extern "C" {
    pub fn g_utf8_to_ucs4_fast(
        str_: *const gchar,
        len: glong,
        items_written: *mut glong,
    ) -> *mut gunichar;
}
extern "C" {
    pub fn g_utf16_to_ucs4(
        str_: *const gunichar2,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar;
}
extern "C" {
    pub fn g_utf16_to_utf8(
        str_: *const gunichar2,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_ucs4_to_utf16(
        str_: *const gunichar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar2;
}
extern "C" {
    pub fn g_ucs4_to_utf8(
        str_: *const gunichar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_unichar_to_utf8(c: gunichar, outbuf: *mut gchar) -> gint;
}
extern "C" {
    pub fn g_utf8_validate(str_: *const gchar, max_len: gssize, end: *mut *const gchar)
        -> gboolean;
}
extern "C" {
    pub fn g_utf8_validate_len(
        str_: *const gchar,
        max_len: gsize,
        end: *mut *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_utf8_strup(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strdown(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_casefold(str_: *const gchar, len: gssize) -> *mut gchar;
}
pub const GNormalizeMode_G_NORMALIZE_DEFAULT: GNormalizeMode = 0;
pub const GNormalizeMode_G_NORMALIZE_NFD: GNormalizeMode = 0;
pub const GNormalizeMode_G_NORMALIZE_DEFAULT_COMPOSE: GNormalizeMode = 1;
pub const GNormalizeMode_G_NORMALIZE_NFC: GNormalizeMode = 1;
pub const GNormalizeMode_G_NORMALIZE_ALL: GNormalizeMode = 2;
pub const GNormalizeMode_G_NORMALIZE_NFKD: GNormalizeMode = 2;
pub const GNormalizeMode_G_NORMALIZE_ALL_COMPOSE: GNormalizeMode = 3;
pub const GNormalizeMode_G_NORMALIZE_NFKC: GNormalizeMode = 3;
#[doc = " GNormalizeMode:\n @G_NORMALIZE_DEFAULT: standardize differences that do not affect the\n     text content, such as the above-mentioned accent representation\n @G_NORMALIZE_NFD: another name for %G_NORMALIZE_DEFAULT\n @G_NORMALIZE_DEFAULT_COMPOSE: like %G_NORMALIZE_DEFAULT, but with\n     composed forms rather than a maximally decomposed form\n @G_NORMALIZE_NFC: another name for %G_NORMALIZE_DEFAULT_COMPOSE\n @G_NORMALIZE_ALL: beyond %G_NORMALIZE_DEFAULT also standardize the\n     \"compatibility\" characters in Unicode, such as SUPERSCRIPT THREE\n     to the standard forms (in this case DIGIT THREE). Formatting\n     information may be lost but for most text operations such\n     characters should be considered the same\n @G_NORMALIZE_NFKD: another name for %G_NORMALIZE_ALL\n @G_NORMALIZE_ALL_COMPOSE: like %G_NORMALIZE_ALL, but with composed\n     forms rather than a maximally decomposed form\n @G_NORMALIZE_NFKC: another name for %G_NORMALIZE_ALL_COMPOSE\n\n Defines how a Unicode string is transformed in a canonical\n form, standardizing such issues as whether a character with\n an accent is represented as a base character and combining\n accent or as a single precomposed character. Unicode strings\n should generally be normalized before comparing them."]
pub type GNormalizeMode = ::std::os::raw::c_int;
extern "C" {
    pub fn g_utf8_normalize(str_: *const gchar, len: gssize, mode: GNormalizeMode) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_collate(str1: *const gchar, str2: *const gchar) -> gint;
}
extern "C" {
    pub fn g_utf8_collate_key(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_collate_key_for_filename(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_make_valid(str_: *const gchar, len: gssize) -> *mut gchar;
}
pub const GAsciiType_G_ASCII_ALNUM: GAsciiType = 1;
pub const GAsciiType_G_ASCII_ALPHA: GAsciiType = 2;
pub const GAsciiType_G_ASCII_CNTRL: GAsciiType = 4;
pub const GAsciiType_G_ASCII_DIGIT: GAsciiType = 8;
pub const GAsciiType_G_ASCII_GRAPH: GAsciiType = 16;
pub const GAsciiType_G_ASCII_LOWER: GAsciiType = 32;
pub const GAsciiType_G_ASCII_PRINT: GAsciiType = 64;
pub const GAsciiType_G_ASCII_PUNCT: GAsciiType = 128;
pub const GAsciiType_G_ASCII_SPACE: GAsciiType = 256;
pub const GAsciiType_G_ASCII_UPPER: GAsciiType = 512;
pub const GAsciiType_G_ASCII_XDIGIT: GAsciiType = 1024;
pub type GAsciiType = ::std::os::raw::c_int;
extern "C" {
    pub static g_ascii_table: *const guint16;
}
extern "C" {
    pub fn g_ascii_tolower(c: gchar) -> gchar;
}
extern "C" {
    pub fn g_ascii_toupper(c: gchar) -> gchar;
}
extern "C" {
    pub fn g_ascii_digit_value(c: gchar) -> gint;
}
extern "C" {
    pub fn g_ascii_xdigit_value(c: gchar) -> gint;
}
extern "C" {
    pub fn g_strdelimit(
        string: *mut gchar,
        delimiters: *const gchar,
        new_delimiter: gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_strcanon(
        string: *mut gchar,
        valid_chars: *const gchar,
        substitutor: gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_strerror(errnum: gint) -> *const gchar;
}
extern "C" {
    pub fn g_strsignal(signum: gint) -> *const gchar;
}
extern "C" {
    pub fn g_strreverse(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strlcpy(dest: *mut gchar, src: *const gchar, dest_size: gsize) -> gsize;
}
extern "C" {
    pub fn g_strlcat(dest: *mut gchar, src: *const gchar, dest_size: gsize) -> gsize;
}
extern "C" {
    pub fn g_strstr_len(
        haystack: *const gchar,
        haystack_len: gssize,
        needle: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_strrstr(haystack: *const gchar, needle: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strrstr_len(
        haystack: *const gchar,
        haystack_len: gssize,
        needle: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_str_has_suffix(str_: *const gchar, suffix: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_str_has_prefix(str_: *const gchar, prefix: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_strtod(nptr: *const gchar, endptr: *mut *mut gchar) -> gdouble;
}
extern "C" {
    pub fn g_ascii_strtod(nptr: *const gchar, endptr: *mut *mut gchar) -> gdouble;
}
extern "C" {
    pub fn g_ascii_strtoull(nptr: *const gchar, endptr: *mut *mut gchar, base: guint) -> guint64;
}
extern "C" {
    pub fn g_ascii_strtoll(nptr: *const gchar, endptr: *mut *mut gchar, base: guint) -> gint64;
}
extern "C" {
    pub fn g_ascii_dtostr(buffer: *mut gchar, buf_len: gint, d: gdouble) -> *mut gchar;
}
extern "C" {
    pub fn g_ascii_formatd(
        buffer: *mut gchar,
        buf_len: gint,
        format: *const gchar,
        d: gdouble,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_strchug(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strchomp(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_ascii_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
}
extern "C" {
    pub fn g_ascii_strncasecmp(s1: *const gchar, s2: *const gchar, n: gsize) -> gint;
}
extern "C" {
    pub fn g_ascii_strdown(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_ascii_strup(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_str_is_ascii(str_: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
}
extern "C" {
    pub fn g_strncasecmp(s1: *const gchar, s2: *const gchar, n: guint) -> gint;
}
extern "C" {
    pub fn g_strdown(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strup(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strdup(str_: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strdup_printf(format: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_strdup_vprintf(format: *const gchar, args: va_list) -> *mut gchar;
}
extern "C" {
    pub fn g_strndup(str_: *const gchar, n: gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_strnfill(length: gsize, fill_char: gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strconcat(string1: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_strjoin(separator: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_strcompress(source: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strescape(source: *const gchar, exceptions: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_memdup(mem: gconstpointer, byte_size: guint) -> gpointer;
}
extern "C" {
    pub fn g_memdup2(mem: gconstpointer, byte_size: gsize) -> gpointer;
}
pub type GStrv = *mut *mut gchar;
extern "C" {
    pub fn g_strsplit(
        string: *const gchar,
        delimiter: *const gchar,
        max_tokens: gint,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_strsplit_set(
        string: *const gchar,
        delimiters: *const gchar,
        max_tokens: gint,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_strjoinv(separator: *const gchar, str_array: *mut *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strfreev(str_array: *mut *mut gchar);
}
extern "C" {
    pub fn g_strdupv(str_array: *mut *mut gchar) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_strv_length(str_array: *mut *mut gchar) -> guint;
}
extern "C" {
    pub fn g_stpcpy(dest: *mut gchar, src: *const ::std::os::raw::c_char) -> *mut gchar;
}
extern "C" {
    pub fn g_str_to_ascii(str_: *const gchar, from_locale: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_str_tokenize_and_fold(
        string: *const gchar,
        translit_locale: *const gchar,
        ascii_alternates: *mut *mut *mut gchar,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_str_match_string(
        search_term: *const gchar,
        potential_hit: *const gchar,
        accept_alternates: gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn g_strv_contains(strv: *const *const gchar, str_: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_strv_equal(strv1: *const *const gchar, strv2: *const *const gchar) -> gboolean;
}
pub const GNumberParserError_G_NUMBER_PARSER_ERROR_INVALID: GNumberParserError = 0;
pub const GNumberParserError_G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS: GNumberParserError = 1;
#[doc = " GNumberParserError:\n @G_NUMBER_PARSER_ERROR_INVALID: String was not a valid number.\n @G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS: String was a number, but out of bounds.\n\n Error codes returned by functions converting a string to a number.\n\n Since: 2.54"]
pub type GNumberParserError = ::std::os::raw::c_int;
extern "C" {
    pub fn g_number_parser_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_ascii_string_to_signed(
        str_: *const gchar,
        base: guint,
        min: gint64,
        max: gint64,
        out_num: *mut gint64,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_ascii_string_to_unsigned(
        str_: *const gchar,
        base: guint,
        min: guint64,
        max: guint64,
        out_num: *mut guint64,
        error: *mut *mut GError,
    ) -> gboolean;
}
pub type GString = _GString;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GString {
    pub str_: *mut gchar,
    pub len: gsize,
    pub allocated_len: gsize,
}
#[test]
fn bindgen_test_layout__GString() {
    const UNINIT: ::std::mem::MaybeUninit<_GString> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GString>(),
        24usize,
        concat!("Size of: ", stringify!(_GString))
    );
    assert_eq!(
        ::std::mem::align_of::<_GString>(),
        8usize,
        concat!("Alignment of ", stringify!(_GString))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GString),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GString),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocated_len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GString),
            "::",
            stringify!(allocated_len)
        )
    );
}
extern "C" {
    pub fn g_string_new(init: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_new_take(init: *mut gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_new_len(init: *const gchar, len: gssize) -> *mut GString;
}
extern "C" {
    pub fn g_string_sized_new(dfl_size: gsize) -> *mut GString;
}
extern "C" {
    pub fn g_string_free(string: *mut GString, free_segment: gboolean) -> *mut gchar;
}
extern "C" {
    pub fn g_string_free_and_steal(string: *mut GString) -> *mut gchar;
}
extern "C" {
    pub fn g_string_free_to_bytes(string: *mut GString) -> *mut GBytes;
}
extern "C" {
    pub fn g_string_equal(v: *const GString, v2: *const GString) -> gboolean;
}
extern "C" {
    pub fn g_string_hash(str_: *const GString) -> guint;
}
extern "C" {
    pub fn g_string_assign(string: *mut GString, rval: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_truncate(string: *mut GString, len: gsize) -> *mut GString;
}
extern "C" {
    pub fn g_string_set_size(string: *mut GString, len: gsize) -> *mut GString;
}
extern "C" {
    pub fn g_string_insert_len(
        string: *mut GString,
        pos: gssize,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_append(string: *mut GString, val: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_append_len(
        string: *mut GString,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_append_c(string: *mut GString, c: gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_append_unichar(string: *mut GString, wc: gunichar) -> *mut GString;
}
extern "C" {
    pub fn g_string_prepend(string: *mut GString, val: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_prepend_c(string: *mut GString, c: gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_prepend_unichar(string: *mut GString, wc: gunichar) -> *mut GString;
}
extern "C" {
    pub fn g_string_prepend_len(
        string: *mut GString,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_insert(string: *mut GString, pos: gssize, val: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_insert_c(string: *mut GString, pos: gssize, c: gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_insert_unichar(string: *mut GString, pos: gssize, wc: gunichar)
        -> *mut GString;
}
extern "C" {
    pub fn g_string_overwrite(string: *mut GString, pos: gsize, val: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_overwrite_len(
        string: *mut GString,
        pos: gsize,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_erase(string: *mut GString, pos: gssize, len: gssize) -> *mut GString;
}
extern "C" {
    pub fn g_string_replace(
        string: *mut GString,
        find: *const gchar,
        replace: *const gchar,
        limit: guint,
    ) -> guint;
}
extern "C" {
    pub fn g_string_ascii_down(string: *mut GString) -> *mut GString;
}
extern "C" {
    pub fn g_string_ascii_up(string: *mut GString) -> *mut GString;
}
extern "C" {
    pub fn g_string_vprintf(string: *mut GString, format: *const gchar, args: va_list);
}
extern "C" {
    pub fn g_string_printf(string: *mut GString, format: *const gchar, ...);
}
extern "C" {
    pub fn g_string_append_vprintf(string: *mut GString, format: *const gchar, args: va_list);
}
extern "C" {
    pub fn g_string_append_printf(string: *mut GString, format: *const gchar, ...);
}
extern "C" {
    pub fn g_string_append_uri_escaped(
        string: *mut GString,
        unescaped: *const gchar,
        reserved_chars_allowed: *const gchar,
        allow_utf8: gboolean,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_down(string: *mut GString) -> *mut GString;
}
extern "C" {
    pub fn g_string_up(string: *mut GString) -> *mut GString;
}
pub type GIOChannel = _GIOChannel;
pub type GIOFuncs = _GIOFuncs;
pub const GIOError_G_IO_ERROR_NONE: GIOError = 0;
pub const GIOError_G_IO_ERROR_AGAIN: GIOError = 1;
pub const GIOError_G_IO_ERROR_INVAL: GIOError = 2;
pub const GIOError_G_IO_ERROR_UNKNOWN: GIOError = 3;
pub type GIOError = ::std::os::raw::c_int;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_FBIG: GIOChannelError = 0;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_INVAL: GIOChannelError = 1;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_IO: GIOChannelError = 2;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_ISDIR: GIOChannelError = 3;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_NOSPC: GIOChannelError = 4;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_NXIO: GIOChannelError = 5;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_OVERFLOW: GIOChannelError = 6;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_PIPE: GIOChannelError = 7;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_FAILED: GIOChannelError = 8;
pub type GIOChannelError = ::std::os::raw::c_int;
pub const GIOStatus_G_IO_STATUS_ERROR: GIOStatus = 0;
pub const GIOStatus_G_IO_STATUS_NORMAL: GIOStatus = 1;
pub const GIOStatus_G_IO_STATUS_EOF: GIOStatus = 2;
pub const GIOStatus_G_IO_STATUS_AGAIN: GIOStatus = 3;
pub type GIOStatus = ::std::os::raw::c_int;
pub const GSeekType_G_SEEK_CUR: GSeekType = 0;
pub const GSeekType_G_SEEK_SET: GSeekType = 1;
pub const GSeekType_G_SEEK_END: GSeekType = 2;
pub type GSeekType = ::std::os::raw::c_int;
pub const GIOFlags_G_IO_FLAG_NONE: GIOFlags = 0;
pub const GIOFlags_G_IO_FLAG_APPEND: GIOFlags = 1;
pub const GIOFlags_G_IO_FLAG_NONBLOCK: GIOFlags = 2;
pub const GIOFlags_G_IO_FLAG_IS_READABLE: GIOFlags = 4;
pub const GIOFlags_G_IO_FLAG_IS_WRITABLE: GIOFlags = 8;
pub const GIOFlags_G_IO_FLAG_IS_WRITEABLE: GIOFlags = 8;
pub const GIOFlags_G_IO_FLAG_IS_SEEKABLE: GIOFlags = 16;
pub const GIOFlags_G_IO_FLAG_MASK: GIOFlags = 31;
pub const GIOFlags_G_IO_FLAG_GET_MASK: GIOFlags = 31;
pub const GIOFlags_G_IO_FLAG_SET_MASK: GIOFlags = 3;
pub type GIOFlags = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOChannel {
    pub ref_count: gint,
    pub funcs: *mut GIOFuncs,
    pub encoding: *mut gchar,
    pub read_cd: GIConv,
    pub write_cd: GIConv,
    pub line_term: *mut gchar,
    pub line_term_len: guint,
    pub buf_size: gsize,
    pub read_buf: *mut GString,
    pub encoded_read_buf: *mut GString,
    pub write_buf: *mut GString,
    pub partial_write_buf: [gchar; 6usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u64,
    pub reserved1: gpointer,
    pub reserved2: gpointer,
}
#[test]
fn bindgen_test_layout__GIOChannel() {
    const UNINIT: ::std::mem::MaybeUninit<_GIOChannel> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GIOChannel>(),
        120usize,
        concat!("Size of: ", stringify!(_GIOChannel))
    );
    assert_eq!(
        ::std::mem::align_of::<_GIOChannel>(),
        8usize,
        concat!("Alignment of ", stringify!(_GIOChannel))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).funcs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(funcs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encoding) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(encoding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_cd) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(read_cd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_cd) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(write_cd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_term) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(line_term)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_term_len) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(line_term_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(buf_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_buf) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(read_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encoded_read_buf) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(encoded_read_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_buf) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(write_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partial_write_buf) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(partial_write_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _GIOChannel {
    #[inline]
    pub fn use_buffer(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_buffer(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn do_encode(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_encode(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn close_on_unref(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close_on_unref(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_readable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_readable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_writeable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_writeable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_seekable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_seekable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        use_buffer: guint,
        do_encode: guint,
        close_on_unref: guint,
        is_readable: guint,
        is_writeable: guint,
        is_seekable: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let use_buffer: u32 = unsafe { ::std::mem::transmute(use_buffer) };
            use_buffer as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let do_encode: u32 = unsafe { ::std::mem::transmute(do_encode) };
            do_encode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let close_on_unref: u32 = unsafe { ::std::mem::transmute(close_on_unref) };
            close_on_unref as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_readable: u32 = unsafe { ::std::mem::transmute(is_readable) };
            is_readable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_writeable: u32 = unsafe { ::std::mem::transmute(is_writeable) };
            is_writeable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_seekable: u32 = unsafe { ::std::mem::transmute(is_seekable) };
            is_seekable as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type GIOFunc = ::std::option::Option<
    unsafe extern "C" fn(
        source: *mut GIOChannel,
        condition: GIOCondition,
        data: gpointer,
    ) -> gboolean,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOFuncs {
    pub io_read: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            buf: *mut gchar,
            count: gsize,
            bytes_read: *mut gsize,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_write: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            buf: *const gchar,
            count: gsize,
            bytes_written: *mut gsize,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_seek: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            offset: gint64,
            type_: GSeekType,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_close: ::std::option::Option<
        unsafe extern "C" fn(channel: *mut GIOChannel, err: *mut *mut GError) -> GIOStatus,
    >,
    pub io_create_watch: ::std::option::Option<
        unsafe extern "C" fn(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource,
    >,
    pub io_free: ::std::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel)>,
    pub io_set_flags: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            flags: GIOFlags,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_get_flags:
        ::std::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel) -> GIOFlags>,
}
#[test]
fn bindgen_test_layout__GIOFuncs() {
    const UNINIT: ::std::mem::MaybeUninit<_GIOFuncs> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GIOFuncs>(),
        64usize,
        concat!("Size of: ", stringify!(_GIOFuncs))
    );
    assert_eq!(
        ::std::mem::align_of::<_GIOFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GIOFuncs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_write) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_seek) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_close) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_create_watch) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_create_watch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_free) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_set_flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_set_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_get_flags) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_get_flags)
        )
    );
}
extern "C" {
    pub fn g_io_channel_init(channel: *mut GIOChannel);
}
extern "C" {
    pub fn g_io_channel_ref(channel: *mut GIOChannel) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_unref(channel: *mut GIOChannel);
}
extern "C" {
    pub fn g_io_channel_read(
        channel: *mut GIOChannel,
        buf: *mut gchar,
        count: gsize,
        bytes_read: *mut gsize,
    ) -> GIOError;
}
extern "C" {
    pub fn g_io_channel_write(
        channel: *mut GIOChannel,
        buf: *const gchar,
        count: gsize,
        bytes_written: *mut gsize,
    ) -> GIOError;
}
extern "C" {
    pub fn g_io_channel_seek(
        channel: *mut GIOChannel,
        offset: gint64,
        type_: GSeekType,
    ) -> GIOError;
}
extern "C" {
    pub fn g_io_channel_close(channel: *mut GIOChannel);
}
extern "C" {
    pub fn g_io_channel_shutdown(
        channel: *mut GIOChannel,
        flush: gboolean,
        err: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_add_watch_full(
        channel: *mut GIOChannel,
        priority: gint,
        condition: GIOCondition,
        func: GIOFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_io_create_watch(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource;
}
extern "C" {
    pub fn g_io_add_watch(
        channel: *mut GIOChannel,
        condition: GIOCondition,
        func: GIOFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_io_channel_set_buffer_size(channel: *mut GIOChannel, size: gsize);
}
extern "C" {
    pub fn g_io_channel_get_buffer_size(channel: *mut GIOChannel) -> gsize;
}
extern "C" {
    pub fn g_io_channel_get_buffer_condition(channel: *mut GIOChannel) -> GIOCondition;
}
extern "C" {
    pub fn g_io_channel_set_flags(
        channel: *mut GIOChannel,
        flags: GIOFlags,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_get_flags(channel: *mut GIOChannel) -> GIOFlags;
}
extern "C" {
    pub fn g_io_channel_set_line_term(
        channel: *mut GIOChannel,
        line_term: *const gchar,
        length: gint,
    );
}
extern "C" {
    pub fn g_io_channel_get_line_term(channel: *mut GIOChannel, length: *mut gint) -> *const gchar;
}
extern "C" {
    pub fn g_io_channel_set_buffered(channel: *mut GIOChannel, buffered: gboolean);
}
extern "C" {
    pub fn g_io_channel_get_buffered(channel: *mut GIOChannel) -> gboolean;
}
extern "C" {
    pub fn g_io_channel_set_encoding(
        channel: *mut GIOChannel,
        encoding: *const gchar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_get_encoding(channel: *mut GIOChannel) -> *const gchar;
}
extern "C" {
    pub fn g_io_channel_set_close_on_unref(channel: *mut GIOChannel, do_close: gboolean);
}
extern "C" {
    pub fn g_io_channel_get_close_on_unref(channel: *mut GIOChannel) -> gboolean;
}
extern "C" {
    pub fn g_io_channel_flush(channel: *mut GIOChannel, error: *mut *mut GError) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_line(
        channel: *mut GIOChannel,
        str_return: *mut *mut gchar,
        length: *mut gsize,
        terminator_pos: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_line_string(
        channel: *mut GIOChannel,
        buffer: *mut GString,
        terminator_pos: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_to_end(
        channel: *mut GIOChannel,
        str_return: *mut *mut gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_chars(
        channel: *mut GIOChannel,
        buf: *mut gchar,
        count: gsize,
        bytes_read: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_unichar(
        channel: *mut GIOChannel,
        thechar: *mut gunichar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_write_chars(
        channel: *mut GIOChannel,
        buf: *const gchar,
        count: gssize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_write_unichar(
        channel: *mut GIOChannel,
        thechar: gunichar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_seek_position(
        channel: *mut GIOChannel,
        offset: gint64,
        type_: GSeekType,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_new_file(
        filename: *const gchar,
        mode: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_io_channel_error_from_errno(en: gint) -> GIOChannelError;
}
extern "C" {
    pub fn g_io_channel_unix_new(fd: ::std::os::raw::c_int) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_unix_get_fd(channel: *mut GIOChannel) -> gint;
}
extern "C" {
    pub static mut g_io_watch_funcs: GSourceFuncs;
}
extern "C" {
    pub fn g_io_channel_win32_make_pollfd(
        channel: *mut GIOChannel,
        condition: GIOCondition,
        fd: *mut GPollFD,
    );
}
extern "C" {
    pub fn g_io_channel_win32_poll(fds: *mut GPollFD, n_fds: gint, timeout_: gint) -> gint;
}
extern "C" {
    pub fn g_io_channel_win32_new_messages(hwnd: gsize) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_win32_new_fd(fd: gint) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_win32_get_fd(channel: *mut GIOChannel) -> gint;
}
extern "C" {
    pub fn g_io_channel_win32_new_socket(socket: gint) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_win32_new_stream_socket(socket: gint) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_win32_set_debug(channel: *mut GIOChannel, flag: gboolean);
}
pub const GKeyFileError_G_KEY_FILE_ERROR_UNKNOWN_ENCODING: GKeyFileError = 0;
pub const GKeyFileError_G_KEY_FILE_ERROR_PARSE: GKeyFileError = 1;
pub const GKeyFileError_G_KEY_FILE_ERROR_NOT_FOUND: GKeyFileError = 2;
pub const GKeyFileError_G_KEY_FILE_ERROR_KEY_NOT_FOUND: GKeyFileError = 3;
pub const GKeyFileError_G_KEY_FILE_ERROR_GROUP_NOT_FOUND: GKeyFileError = 4;
pub const GKeyFileError_G_KEY_FILE_ERROR_INVALID_VALUE: GKeyFileError = 5;
pub type GKeyFileError = ::std::os::raw::c_int;
extern "C" {
    pub fn g_key_file_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GKeyFile {
    _unused: [u8; 0],
}
pub type GKeyFile = _GKeyFile;
pub const GKeyFileFlags_G_KEY_FILE_NONE: GKeyFileFlags = 0;
pub const GKeyFileFlags_G_KEY_FILE_KEEP_COMMENTS: GKeyFileFlags = 1;
pub const GKeyFileFlags_G_KEY_FILE_KEEP_TRANSLATIONS: GKeyFileFlags = 2;
pub type GKeyFileFlags = ::std::os::raw::c_int;
extern "C" {
    pub fn g_key_file_new() -> *mut GKeyFile;
}
extern "C" {
    pub fn g_key_file_ref(key_file: *mut GKeyFile) -> *mut GKeyFile;
}
extern "C" {
    pub fn g_key_file_unref(key_file: *mut GKeyFile);
}
extern "C" {
    pub fn g_key_file_free(key_file: *mut GKeyFile);
}
extern "C" {
    pub fn g_key_file_set_list_separator(key_file: *mut GKeyFile, separator: gchar);
}
extern "C" {
    pub fn g_key_file_load_from_file(
        key_file: *mut GKeyFile,
        file: *const gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_load_from_data(
        key_file: *mut GKeyFile,
        data: *const gchar,
        length: gsize,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_load_from_bytes(
        key_file: *mut GKeyFile,
        bytes: *mut GBytes,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_load_from_dirs(
        key_file: *mut GKeyFile,
        file: *const gchar,
        search_dirs: *mut *const gchar,
        full_path: *mut *mut gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_load_from_data_dirs(
        key_file: *mut GKeyFile,
        file: *const gchar,
        full_path: *mut *mut gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_to_data(
        key_file: *mut GKeyFile,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_save_to_file(
        key_file: *mut GKeyFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_get_start_group(key_file: *mut GKeyFile) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_get_groups(key_file: *mut GKeyFile, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_key_file_get_keys(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_key_file_has_group(key_file: *mut GKeyFile, group_name: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_key_file_has_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_get_value(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_value(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: *const gchar,
    );
}
extern "C" {
    pub fn g_key_file_get_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        string: *const gchar,
    );
}
extern "C" {
    pub fn g_key_file_get_locale_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_get_locale_for_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_locale_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        string: *const gchar,
    );
}
extern "C" {
    pub fn g_key_file_get_boolean(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_set_boolean(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gboolean,
    );
}
extern "C" {
    pub fn g_key_file_get_integer(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    pub fn g_key_file_set_integer(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gint,
    );
}
extern "C" {
    pub fn g_key_file_get_int64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gint64;
}
extern "C" {
    pub fn g_key_file_set_int64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gint64,
    );
}
extern "C" {
    pub fn g_key_file_get_uint64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> guint64;
}
extern "C" {
    pub fn g_key_file_set_uint64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: guint64,
    );
}
extern "C" {
    pub fn g_key_file_get_double(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gdouble;
}
extern "C" {
    pub fn g_key_file_set_double(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gdouble,
    );
}
extern "C" {
    pub fn g_key_file_get_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *const *const gchar,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_get_locale_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_locale_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        list: *const *const gchar,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_get_boolean_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gboolean;
}
extern "C" {
    pub fn g_key_file_set_boolean_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gboolean,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_get_integer_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gint;
}
extern "C" {
    pub fn g_key_file_set_double_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gdouble,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_get_double_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gdouble;
}
extern "C" {
    pub fn g_key_file_set_integer_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gint,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_set_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        comment: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_get_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_remove_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_remove_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_remove_group(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMappedFile {
    _unused: [u8; 0],
}
pub type GMappedFile = _GMappedFile;
extern "C" {
    pub fn g_mapped_file_new(
        filename: *const gchar,
        writable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GMappedFile;
}
extern "C" {
    pub fn g_mapped_file_new_from_fd(
        fd: gint,
        writable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GMappedFile;
}
extern "C" {
    pub fn g_mapped_file_get_length(file: *mut GMappedFile) -> gsize;
}
extern "C" {
    pub fn g_mapped_file_get_contents(file: *mut GMappedFile) -> *mut gchar;
}
extern "C" {
    pub fn g_mapped_file_get_bytes(file: *mut GMappedFile) -> *mut GBytes;
}
extern "C" {
    pub fn g_mapped_file_ref(file: *mut GMappedFile) -> *mut GMappedFile;
}
extern "C" {
    pub fn g_mapped_file_unref(file: *mut GMappedFile);
}
extern "C" {
    pub fn g_mapped_file_free(file: *mut GMappedFile);
}
pub const GMarkupError_G_MARKUP_ERROR_BAD_UTF8: GMarkupError = 0;
pub const GMarkupError_G_MARKUP_ERROR_EMPTY: GMarkupError = 1;
pub const GMarkupError_G_MARKUP_ERROR_PARSE: GMarkupError = 2;
pub const GMarkupError_G_MARKUP_ERROR_UNKNOWN_ELEMENT: GMarkupError = 3;
pub const GMarkupError_G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: GMarkupError = 4;
pub const GMarkupError_G_MARKUP_ERROR_INVALID_CONTENT: GMarkupError = 5;
pub const GMarkupError_G_MARKUP_ERROR_MISSING_ATTRIBUTE: GMarkupError = 6;
#[doc = " GMarkupError:\n @G_MARKUP_ERROR_BAD_UTF8: text being parsed was not valid UTF-8\n @G_MARKUP_ERROR_EMPTY: document contained nothing, or only whitespace\n @G_MARKUP_ERROR_PARSE: document was ill-formed\n @G_MARKUP_ERROR_UNKNOWN_ELEMENT: error should be set by #GMarkupParser\n     functions; element wasn't known\n @G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: error should be set by #GMarkupParser\n     functions; attribute wasn't known\n @G_MARKUP_ERROR_INVALID_CONTENT: error should be set by #GMarkupParser\n     functions; content was invalid\n @G_MARKUP_ERROR_MISSING_ATTRIBUTE: error should be set by #GMarkupParser\n     functions; a required attribute was missing\n\n Error codes returned by markup parsing."]
pub type GMarkupError = ::std::os::raw::c_int;
extern "C" {
    pub fn g_markup_error_quark() -> GQuark;
}
pub const GMarkupParseFlags_G_MARKUP_DEFAULT_FLAGS: GMarkupParseFlags = 0;
pub const GMarkupParseFlags_G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: GMarkupParseFlags = 1;
pub const GMarkupParseFlags_G_MARKUP_TREAT_CDATA_AS_TEXT: GMarkupParseFlags = 2;
pub const GMarkupParseFlags_G_MARKUP_PREFIX_ERROR_POSITION: GMarkupParseFlags = 4;
pub const GMarkupParseFlags_G_MARKUP_IGNORE_QUALIFIED: GMarkupParseFlags = 8;
#[doc = " GMarkupParseFlags:\n @G_MARKUP_DEFAULT_FLAGS: No special behaviour. Since: 2.74\n @G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: flag you should not use\n @G_MARKUP_TREAT_CDATA_AS_TEXT: When this flag is set, CDATA marked\n     sections are not passed literally to the @passthrough function of\n     the parser. Instead, the content of the section (without the\n     `<![CDATA[` and `]]>`) is\n     passed to the @text function. This flag was added in GLib 2.12\n @G_MARKUP_PREFIX_ERROR_POSITION: Normally errors caught by GMarkup\n     itself have line/column information prefixed to them to let the\n     caller know the location of the error. When this flag is set the\n     location information is also prefixed to errors generated by the\n     #GMarkupParser implementation functions\n @G_MARKUP_IGNORE_QUALIFIED: Ignore (don't report) qualified\n     attributes and tags, along with their contents.  A qualified\n     attribute or tag is one that contains ':' in its name (ie: is in\n     another namespace).  Since: 2.40.\n\n Flags that affect the behaviour of the parser."]
pub type GMarkupParseFlags = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMarkupParseContext {
    _unused: [u8; 0],
}
#[doc = " GMarkupParseContext:\n\n A parse context is used to parse a stream of bytes that\n you expect to contain marked-up text.\n\n See g_markup_parse_context_new(), #GMarkupParser, and so\n on for more details."]
pub type GMarkupParseContext = _GMarkupParseContext;
#[doc = " GMarkupParser:\n @start_element: Callback to invoke when the opening tag of an element\n     is seen. The callback's @attribute_names and @attribute_values parameters\n     are %NULL-terminated.\n @end_element: Callback to invoke when the closing tag of an element\n     is seen. Note that this is also called for empty tags like\n     `<empty/>`.\n @text: Callback to invoke when some text is seen (text is always\n     inside an element). Note that the text of an element may be spread\n     over multiple calls of this function. If the\n     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is set, this function is also\n     called for the content of CDATA marked sections.\n @passthrough: Callback to invoke for comments, processing instructions\n     and doctype declarations; if you're re-writing the parsed document,\n     write the passthrough text back out in the same position. If the\n     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is not set, this function is also\n     called for CDATA marked sections.\n @error: Callback to invoke when an error occurs.\n\n Any of the fields in #GMarkupParser can be %NULL, in which case they\n will be ignored. Except for the @error function, any of these callbacks\n can set an error; in particular the %G_MARKUP_ERROR_UNKNOWN_ELEMENT,\n %G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE, and %G_MARKUP_ERROR_INVALID_CONTENT\n errors are intended to be set from these callbacks. If you set an error\n from a callback, g_markup_parse_context_parse() will report that error\n back to its caller."]
pub type GMarkupParser = _GMarkupParser;
#[doc = " GMarkupParser:\n @start_element: Callback to invoke when the opening tag of an element\n     is seen. The callback's @attribute_names and @attribute_values parameters\n     are %NULL-terminated.\n @end_element: Callback to invoke when the closing tag of an element\n     is seen. Note that this is also called for empty tags like\n     `<empty/>`.\n @text: Callback to invoke when some text is seen (text is always\n     inside an element). Note that the text of an element may be spread\n     over multiple calls of this function. If the\n     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is set, this function is also\n     called for the content of CDATA marked sections.\n @passthrough: Callback to invoke for comments, processing instructions\n     and doctype declarations; if you're re-writing the parsed document,\n     write the passthrough text back out in the same position. If the\n     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is not set, this function is also\n     called for CDATA marked sections.\n @error: Callback to invoke when an error occurs.\n\n Any of the fields in #GMarkupParser can be %NULL, in which case they\n will be ignored. Except for the @error function, any of these callbacks\n can set an error; in particular the %G_MARKUP_ERROR_UNKNOWN_ELEMENT,\n %G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE, and %G_MARKUP_ERROR_INVALID_CONTENT\n errors are intended to be set from these callbacks. If you set an error\n from a callback, g_markup_parse_context_parse() will report that error\n back to its caller."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMarkupParser {
    pub start_element: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            element_name: *const gchar,
            attribute_names: *mut *const gchar,
            attribute_values: *mut *const gchar,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub end_element: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            element_name: *const gchar,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub text: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            text: *const gchar,
            text_len: gsize,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub passthrough: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            passthrough_text: *const gchar,
            text_len: gsize,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub error: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            error: *mut GError,
            user_data: gpointer,
        ),
    >,
}
#[test]
fn bindgen_test_layout__GMarkupParser() {
    const UNINIT: ::std::mem::MaybeUninit<_GMarkupParser> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMarkupParser>(),
        40usize,
        concat!("Size of: ", stringify!(_GMarkupParser))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMarkupParser>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMarkupParser))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(start_element)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_element) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(end_element)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).passthrough) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(passthrough)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(error)
        )
    );
}
extern "C" {
    pub fn g_markup_parse_context_new(
        parser: *const GMarkupParser,
        flags: GMarkupParseFlags,
        user_data: gpointer,
        user_data_dnotify: GDestroyNotify,
    ) -> *mut GMarkupParseContext;
}
extern "C" {
    pub fn g_markup_parse_context_ref(
        context: *mut GMarkupParseContext,
    ) -> *mut GMarkupParseContext;
}
extern "C" {
    pub fn g_markup_parse_context_unref(context: *mut GMarkupParseContext);
}
extern "C" {
    pub fn g_markup_parse_context_free(context: *mut GMarkupParseContext);
}
extern "C" {
    pub fn g_markup_parse_context_parse(
        context: *mut GMarkupParseContext,
        text: *const gchar,
        text_len: gssize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_markup_parse_context_push(
        context: *mut GMarkupParseContext,
        parser: *const GMarkupParser,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_markup_parse_context_pop(context: *mut GMarkupParseContext) -> gpointer;
}
extern "C" {
    pub fn g_markup_parse_context_end_parse(
        context: *mut GMarkupParseContext,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_markup_parse_context_get_element(context: *mut GMarkupParseContext) -> *const gchar;
}
extern "C" {
    pub fn g_markup_parse_context_get_element_stack(
        context: *mut GMarkupParseContext,
    ) -> *const GSList;
}
extern "C" {
    pub fn g_markup_parse_context_get_position(
        context: *mut GMarkupParseContext,
        line_number: *mut gint,
        char_number: *mut gint,
    );
}
extern "C" {
    pub fn g_markup_parse_context_get_user_data(context: *mut GMarkupParseContext) -> gpointer;
}
extern "C" {
    pub fn g_markup_escape_text(text: *const gchar, length: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_markup_printf_escaped(format: *const ::std::os::raw::c_char, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_markup_vprintf_escaped(
        format: *const ::std::os::raw::c_char,
        args: va_list,
    ) -> *mut gchar;
}
pub const GMarkupCollectType_G_MARKUP_COLLECT_INVALID: GMarkupCollectType = 0;
pub const GMarkupCollectType_G_MARKUP_COLLECT_STRING: GMarkupCollectType = 1;
pub const GMarkupCollectType_G_MARKUP_COLLECT_STRDUP: GMarkupCollectType = 2;
pub const GMarkupCollectType_G_MARKUP_COLLECT_BOOLEAN: GMarkupCollectType = 3;
pub const GMarkupCollectType_G_MARKUP_COLLECT_TRISTATE: GMarkupCollectType = 4;
pub const GMarkupCollectType_G_MARKUP_COLLECT_OPTIONAL: GMarkupCollectType = 65536;
pub type GMarkupCollectType = ::std::os::raw::c_int;
extern "C" {
    pub fn g_markup_collect_attributes(
        element_name: *const gchar,
        attribute_names: *mut *const gchar,
        attribute_values: *mut *const gchar,
        error: *mut *mut GError,
        first_type: GMarkupCollectType,
        first_attr: *const gchar,
        ...
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantType {
    _unused: [u8; 0],
}
#[doc = " GVariantType:\n\n A type in the GVariant type system.\n\n Two types may not be compared by value; use g_variant_type_equal() or\n g_variant_type_is_subtype_of().  May be copied using\n g_variant_type_copy() and freed using g_variant_type_free()."]
pub type GVariantType = _GVariantType;
extern "C" {
    pub fn g_variant_type_string_is_valid(type_string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_string_scan(
        string: *const gchar,
        limit: *const gchar,
        endptr: *mut *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_free(type_: *mut GVariantType);
}
extern "C" {
    pub fn g_variant_type_copy(type_: *const GVariantType) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_new(type_string: *const gchar) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_get_string_length(type_: *const GVariantType) -> gsize;
}
extern "C" {
    pub fn g_variant_type_peek_string(type_: *const GVariantType) -> *const gchar;
}
extern "C" {
    pub fn g_variant_type_dup_string(type_: *const GVariantType) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_type_is_definite(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_container(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_basic(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_maybe(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_array(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_tuple(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_dict_entry(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_variant(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_hash(type_: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_variant_type_equal(type1: gconstpointer, type2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_subtype_of(
        type_: *const GVariantType,
        supertype: *const GVariantType,
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_element(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_first(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_next(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_n_items(type_: *const GVariantType) -> gsize;
}
extern "C" {
    pub fn g_variant_type_key(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_value(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_new_array(element: *const GVariantType) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_new_maybe(element: *const GVariantType) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_new_tuple(
        items: *const *const GVariantType,
        length: gint,
    ) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_new_dict_entry(
        key: *const GVariantType,
        value: *const GVariantType,
    ) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_checked_(arg1: *const gchar) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_string_get_depth_(type_string: *const gchar) -> gsize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariant {
    _unused: [u8; 0],
}
pub type GVariant = _GVariant;
pub const GVariantClass_G_VARIANT_CLASS_BOOLEAN: GVariantClass = 98;
pub const GVariantClass_G_VARIANT_CLASS_BYTE: GVariantClass = 121;
pub const GVariantClass_G_VARIANT_CLASS_INT16: GVariantClass = 110;
pub const GVariantClass_G_VARIANT_CLASS_UINT16: GVariantClass = 113;
pub const GVariantClass_G_VARIANT_CLASS_INT32: GVariantClass = 105;
pub const GVariantClass_G_VARIANT_CLASS_UINT32: GVariantClass = 117;
pub const GVariantClass_G_VARIANT_CLASS_INT64: GVariantClass = 120;
pub const GVariantClass_G_VARIANT_CLASS_UINT64: GVariantClass = 116;
pub const GVariantClass_G_VARIANT_CLASS_HANDLE: GVariantClass = 104;
pub const GVariantClass_G_VARIANT_CLASS_DOUBLE: GVariantClass = 100;
pub const GVariantClass_G_VARIANT_CLASS_STRING: GVariantClass = 115;
pub const GVariantClass_G_VARIANT_CLASS_OBJECT_PATH: GVariantClass = 111;
pub const GVariantClass_G_VARIANT_CLASS_SIGNATURE: GVariantClass = 103;
pub const GVariantClass_G_VARIANT_CLASS_VARIANT: GVariantClass = 118;
pub const GVariantClass_G_VARIANT_CLASS_MAYBE: GVariantClass = 109;
pub const GVariantClass_G_VARIANT_CLASS_ARRAY: GVariantClass = 97;
pub const GVariantClass_G_VARIANT_CLASS_TUPLE: GVariantClass = 40;
pub const GVariantClass_G_VARIANT_CLASS_DICT_ENTRY: GVariantClass = 123;
pub type GVariantClass = ::std::os::raw::c_int;
extern "C" {
    pub fn g_variant_unref(value: *mut GVariant);
}
extern "C" {
    pub fn g_variant_ref(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_ref_sink(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_is_floating(value: *mut GVariant) -> gboolean;
}
extern "C" {
    pub fn g_variant_take_ref(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_type(value: *mut GVariant) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_get_type_string(value: *mut GVariant) -> *const gchar;
}
extern "C" {
    pub fn g_variant_is_of_type(value: *mut GVariant, type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_is_container(value: *mut GVariant) -> gboolean;
}
extern "C" {
    pub fn g_variant_classify(value: *mut GVariant) -> GVariantClass;
}
extern "C" {
    pub fn g_variant_new_boolean(value: gboolean) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_byte(value: guint8) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_int16(value: gint16) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_uint16(value: guint16) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_int32(value: gint32) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_uint32(value: guint32) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_int64(value: gint64) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_uint64(value: guint64) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_handle(value: gint32) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_double(value: gdouble) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_string(string: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_take_string(string: *mut gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_printf(format_string: *const gchar, ...) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_object_path(object_path: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_is_object_path(string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_new_signature(signature: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_is_signature(string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_new_variant(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_strv(strv: *const *const gchar, length: gssize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_objv(strv: *const *const gchar, length: gssize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_bytestring(string: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_bytestring_array(
        strv: *const *const gchar,
        length: gssize,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_fixed_array(
        element_type: *const GVariantType,
        elements: gconstpointer,
        n_elements: gsize,
        element_size: gsize,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_boolean(value: *mut GVariant) -> gboolean;
}
extern "C" {
    pub fn g_variant_get_byte(value: *mut GVariant) -> guint8;
}
extern "C" {
    pub fn g_variant_get_int16(value: *mut GVariant) -> gint16;
}
extern "C" {
    pub fn g_variant_get_uint16(value: *mut GVariant) -> guint16;
}
extern "C" {
    pub fn g_variant_get_int32(value: *mut GVariant) -> gint32;
}
extern "C" {
    pub fn g_variant_get_uint32(value: *mut GVariant) -> guint32;
}
extern "C" {
    pub fn g_variant_get_int64(value: *mut GVariant) -> gint64;
}
extern "C" {
    pub fn g_variant_get_uint64(value: *mut GVariant) -> guint64;
}
extern "C" {
    pub fn g_variant_get_handle(value: *mut GVariant) -> gint32;
}
extern "C" {
    pub fn g_variant_get_double(value: *mut GVariant) -> gdouble;
}
extern "C" {
    pub fn g_variant_get_variant(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_string(value: *mut GVariant, length: *mut gsize) -> *const gchar;
}
extern "C" {
    pub fn g_variant_dup_string(value: *mut GVariant, length: *mut gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_get_strv(value: *mut GVariant, length: *mut gsize) -> *mut *const gchar;
}
extern "C" {
    pub fn g_variant_dup_strv(value: *mut GVariant, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_variant_get_objv(value: *mut GVariant, length: *mut gsize) -> *mut *const gchar;
}
extern "C" {
    pub fn g_variant_dup_objv(value: *mut GVariant, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_variant_get_bytestring(value: *mut GVariant) -> *const gchar;
}
extern "C" {
    pub fn g_variant_dup_bytestring(value: *mut GVariant, length: *mut gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_get_bytestring_array(
        value: *mut GVariant,
        length: *mut gsize,
    ) -> *mut *const gchar;
}
extern "C" {
    pub fn g_variant_dup_bytestring_array(
        value: *mut GVariant,
        length: *mut gsize,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_variant_new_maybe(
        child_type: *const GVariantType,
        child: *mut GVariant,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_array(
        child_type: *const GVariantType,
        children: *const *mut GVariant,
        n_children: gsize,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_tuple(children: *const *mut GVariant, n_children: gsize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_dict_entry(key: *mut GVariant, value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_maybe(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_n_children(value: *mut GVariant) -> gsize;
}
extern "C" {
    pub fn g_variant_get_child(
        value: *mut GVariant,
        index_: gsize,
        format_string: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_variant_get_child_value(value: *mut GVariant, index_: gsize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_lookup(
        dictionary: *mut GVariant,
        key: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_lookup_value(
        dictionary: *mut GVariant,
        key: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_fixed_array(
        value: *mut GVariant,
        n_elements: *mut gsize,
        element_size: gsize,
    ) -> gconstpointer;
}
extern "C" {
    pub fn g_variant_get_size(value: *mut GVariant) -> gsize;
}
extern "C" {
    pub fn g_variant_get_data(value: *mut GVariant) -> gconstpointer;
}
extern "C" {
    pub fn g_variant_get_data_as_bytes(value: *mut GVariant) -> *mut GBytes;
}
extern "C" {
    pub fn g_variant_store(value: *mut GVariant, data: gpointer);
}
extern "C" {
    pub fn g_variant_print(value: *mut GVariant, type_annotate: gboolean) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_print_string(
        value: *mut GVariant,
        string: *mut GString,
        type_annotate: gboolean,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_variant_hash(value: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_variant_equal(one: gconstpointer, two: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_variant_get_normal_form(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_is_normal_form(value: *mut GVariant) -> gboolean;
}
extern "C" {
    pub fn g_variant_byteswap(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_from_bytes(
        type_: *const GVariantType,
        bytes: *mut GBytes,
        trusted: gboolean,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_from_data(
        type_: *const GVariantType,
        data: gconstpointer,
        size: gsize,
        trusted: gboolean,
        notify: GDestroyNotify,
        user_data: gpointer,
    ) -> *mut GVariant;
}
pub type GVariantIter = _GVariantIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantIter {
    pub x: [guintptr; 16usize],
}
#[test]
fn bindgen_test_layout__GVariantIter() {
    const UNINIT: ::std::mem::MaybeUninit<_GVariantIter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVariantIter>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantIter))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantIter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantIter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantIter),
            "::",
            stringify!(x)
        )
    );
}
extern "C" {
    pub fn g_variant_iter_new(value: *mut GVariant) -> *mut GVariantIter;
}
extern "C" {
    pub fn g_variant_iter_init(iter: *mut GVariantIter, value: *mut GVariant) -> gsize;
}
extern "C" {
    pub fn g_variant_iter_copy(iter: *mut GVariantIter) -> *mut GVariantIter;
}
extern "C" {
    pub fn g_variant_iter_n_children(iter: *mut GVariantIter) -> gsize;
}
extern "C" {
    pub fn g_variant_iter_free(iter: *mut GVariantIter);
}
extern "C" {
    pub fn g_variant_iter_next_value(iter: *mut GVariantIter) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_iter_next(
        iter: *mut GVariantIter,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_iter_loop(
        iter: *mut GVariantIter,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
pub type GVariantBuilder = _GVariantBuilder;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GVariantBuilder {
    pub u: _GVariantBuilder__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GVariantBuilder__bindgen_ty_1 {
    pub s: _GVariantBuilder__bindgen_ty_1__bindgen_ty_1,
    pub x: [guintptr; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantBuilder__bindgen_ty_1__bindgen_ty_1 {
    pub partial_magic: gsize,
    pub type_: *const GVariantType,
    pub y: [guintptr; 14usize],
}
#[test]
fn bindgen_test_layout__GVariantBuilder__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partial_magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(partial_magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
}
#[test]
fn bindgen_test_layout__GVariantBuilder__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_GVariantBuilder__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVariantBuilder__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantBuilder__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantBuilder__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantBuilder__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
}
#[test]
fn bindgen_test_layout__GVariantBuilder() {
    const UNINIT: ::std::mem::MaybeUninit<_GVariantBuilder> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVariantBuilder>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantBuilder))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantBuilder>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantBuilder))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder),
            "::",
            stringify!(u)
        )
    );
}
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_FAILED: GVariantParseError = 0;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED: GVariantParseError = 1;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE: GVariantParseError = 2;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED: GVariantParseError = 3;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END: GVariantParseError = 4;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_CHARACTER: GVariantParseError = 5;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING: GVariantParseError = 6;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH: GVariantParseError = 7;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE: GVariantParseError = 8;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING: GVariantParseError = 9;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE: GVariantParseError = 10;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE: GVariantParseError = 11;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG: GVariantParseError = 12;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_TYPE_ERROR: GVariantParseError = 13;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN: GVariantParseError = 14;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD: GVariantParseError = 15;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT:
    GVariantParseError = 16;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_VALUE_EXPECTED: GVariantParseError = 17;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_RECURSION: GVariantParseError = 18;
pub type GVariantParseError = ::std::os::raw::c_int;
extern "C" {
    pub fn g_variant_parser_get_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_variant_parse_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_variant_builder_new(type_: *const GVariantType) -> *mut GVariantBuilder;
}
extern "C" {
    pub fn g_variant_builder_unref(builder: *mut GVariantBuilder);
}
extern "C" {
    pub fn g_variant_builder_ref(builder: *mut GVariantBuilder) -> *mut GVariantBuilder;
}
extern "C" {
    pub fn g_variant_builder_init(builder: *mut GVariantBuilder, type_: *const GVariantType);
}
extern "C" {
    pub fn g_variant_builder_end(builder: *mut GVariantBuilder) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_builder_clear(builder: *mut GVariantBuilder);
}
extern "C" {
    pub fn g_variant_builder_open(builder: *mut GVariantBuilder, type_: *const GVariantType);
}
extern "C" {
    pub fn g_variant_builder_close(builder: *mut GVariantBuilder);
}
extern "C" {
    pub fn g_variant_builder_add_value(builder: *mut GVariantBuilder, value: *mut GVariant);
}
extern "C" {
    pub fn g_variant_builder_add(builder: *mut GVariantBuilder, format_string: *const gchar, ...);
}
extern "C" {
    pub fn g_variant_builder_add_parsed(builder: *mut GVariantBuilder, format: *const gchar, ...);
}
extern "C" {
    pub fn g_variant_new(format_string: *const gchar, ...) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get(value: *mut GVariant, format_string: *const gchar, ...);
}
extern "C" {
    pub fn g_variant_new_va(
        format_string: *const gchar,
        endptr: *mut *const gchar,
        app: *mut va_list,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_va(
        value: *mut GVariant,
        format_string: *const gchar,
        endptr: *mut *const gchar,
        app: *mut va_list,
    );
}
extern "C" {
    pub fn g_variant_check_format_string(
        value: *mut GVariant,
        format_string: *const gchar,
        copy_only: gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_parse(
        type_: *const GVariantType,
        text: *const gchar,
        limit: *const gchar,
        endptr: *mut *const gchar,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_parsed(format: *const gchar, ...) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_parsed_va(format: *const gchar, app: *mut va_list) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_parse_error_print_context(
        error: *mut GError,
        source_str: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_compare(one: gconstpointer, two: gconstpointer) -> gint;
}
pub type GVariantDict = _GVariantDict;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GVariantDict {
    pub u: _GVariantDict__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GVariantDict__bindgen_ty_1 {
    pub s: _GVariantDict__bindgen_ty_1__bindgen_ty_1,
    pub x: [guintptr; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantDict__bindgen_ty_1__bindgen_ty_1 {
    pub asv: *mut GVariant,
    pub partial_magic: gsize,
    pub y: [guintptr; 14usize],
}
#[test]
fn bindgen_test_layout__GVariantDict__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_GVariantDict__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(asv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partial_magic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(partial_magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
}
#[test]
fn bindgen_test_layout__GVariantDict__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_GVariantDict__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVariantDict__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantDict__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantDict__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantDict__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
}
#[test]
fn bindgen_test_layout__GVariantDict() {
    const UNINIT: ::std::mem::MaybeUninit<_GVariantDict> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVariantDict>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantDict))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantDict>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantDict))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict),
            "::",
            stringify!(u)
        )
    );
}
extern "C" {
    pub fn g_variant_dict_new(from_asv: *mut GVariant) -> *mut GVariantDict;
}
extern "C" {
    pub fn g_variant_dict_init(dict: *mut GVariantDict, from_asv: *mut GVariant);
}
extern "C" {
    pub fn g_variant_dict_lookup(
        dict: *mut GVariantDict,
        key: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_dict_lookup_value(
        dict: *mut GVariantDict,
        key: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_dict_contains(dict: *mut GVariantDict, key: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_dict_insert(
        dict: *mut GVariantDict,
        key: *const gchar,
        format_string: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_variant_dict_insert_value(
        dict: *mut GVariantDict,
        key: *const gchar,
        value: *mut GVariant,
    );
}
extern "C" {
    pub fn g_variant_dict_remove(dict: *mut GVariantDict, key: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_dict_clear(dict: *mut GVariantDict);
}
extern "C" {
    pub fn g_variant_dict_end(dict: *mut GVariantDict) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_dict_ref(dict: *mut GVariantDict) -> *mut GVariantDict;
}
extern "C" {
    pub fn g_variant_dict_unref(dict: *mut GVariantDict);
}
extern "C" {
    pub fn g_printf_string_upper_bound(format: *const gchar, args: va_list) -> gsize;
}
pub const GLogLevelFlags_G_LOG_FLAG_RECURSION: GLogLevelFlags = 1;
pub const GLogLevelFlags_G_LOG_FLAG_FATAL: GLogLevelFlags = 2;
pub const GLogLevelFlags_G_LOG_LEVEL_ERROR: GLogLevelFlags = 4;
pub const GLogLevelFlags_G_LOG_LEVEL_CRITICAL: GLogLevelFlags = 8;
pub const GLogLevelFlags_G_LOG_LEVEL_WARNING: GLogLevelFlags = 16;
pub const GLogLevelFlags_G_LOG_LEVEL_MESSAGE: GLogLevelFlags = 32;
pub const GLogLevelFlags_G_LOG_LEVEL_INFO: GLogLevelFlags = 64;
pub const GLogLevelFlags_G_LOG_LEVEL_DEBUG: GLogLevelFlags = 128;
pub const GLogLevelFlags_G_LOG_LEVEL_MASK: GLogLevelFlags = -4;
pub type GLogLevelFlags = ::std::os::raw::c_int;
pub type GLogFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        user_data: gpointer,
    ),
>;
extern "C" {
    pub fn g_log_set_handler(
        log_domain: *const gchar,
        log_levels: GLogLevelFlags,
        log_func: GLogFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_log_set_handler_full(
        log_domain: *const gchar,
        log_levels: GLogLevelFlags,
        log_func: GLogFunc,
        user_data: gpointer,
        destroy: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_log_remove_handler(log_domain: *const gchar, handler_id: guint);
}
extern "C" {
    pub fn g_log_default_handler(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        unused_data: gpointer,
    );
}
extern "C" {
    pub fn g_log_set_default_handler(log_func: GLogFunc, user_data: gpointer) -> GLogFunc;
}
extern "C" {
    pub fn g_log(log_domain: *const gchar, log_level: GLogLevelFlags, format: *const gchar, ...);
}
extern "C" {
    pub fn g_logv(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        format: *const gchar,
        args: va_list,
    );
}
extern "C" {
    pub fn g_log_set_fatal_mask(
        log_domain: *const gchar,
        fatal_mask: GLogLevelFlags,
    ) -> GLogLevelFlags;
}
extern "C" {
    pub fn g_log_set_always_fatal(fatal_mask: GLogLevelFlags) -> GLogLevelFlags;
}
pub const GLogWriterOutput_G_LOG_WRITER_HANDLED: GLogWriterOutput = 1;
pub const GLogWriterOutput_G_LOG_WRITER_UNHANDLED: GLogWriterOutput = 0;
#[doc = " GLogWriterOutput:\n @G_LOG_WRITER_HANDLED: Log writer has handled the log entry.\n @G_LOG_WRITER_UNHANDLED: Log writer could not handle the log entry.\n\n Return values from #GLogWriterFuncs to indicate whether the given log entry\n was successfully handled by the writer, or whether there was an error in\n handling it (and hence a fallback writer should be used).\n\n If a #GLogWriterFunc ignores a log entry, it should return\n %G_LOG_WRITER_HANDLED.\n\n Since: 2.50"]
pub type GLogWriterOutput = ::std::os::raw::c_int;
#[doc = " GLogField:\n @key: field name (UTF-8 string)\n @value: field value (arbitrary bytes)\n @length: length of @value, in bytes, or -1 if it is nul-terminated\n\n Structure representing a single field in a structured log entry. See\n g_log_structured() for details.\n\n Log fields may contain arbitrary values, including binary with embedded nul\n bytes. If the field contains a string, the string must be UTF-8 encoded and\n have a trailing nul byte. Otherwise, @length must be set to a non-negative\n value.\n\n Since: 2.50"]
pub type GLogField = _GLogField;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GLogField {
    pub key: *const gchar,
    pub value: gconstpointer,
    pub length: gssize,
}
#[test]
fn bindgen_test_layout__GLogField() {
    const UNINIT: ::std::mem::MaybeUninit<_GLogField> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GLogField>(),
        24usize,
        concat!("Size of: ", stringify!(_GLogField))
    );
    assert_eq!(
        ::std::mem::align_of::<_GLogField>(),
        8usize,
        concat!("Alignment of ", stringify!(_GLogField))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLogField),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLogField),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLogField),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " GLogWriterFunc:\n @log_level: log level of the message\n @fields: (array length=n_fields): fields forming the message\n @n_fields: number of @fields\n @user_data: user data passed to g_log_set_writer_func()\n\n Writer function for log entries. A log entry is a collection of one or more\n #GLogFields, using the standard [field names from journal\n specification](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html).\n See g_log_structured() for more information.\n\n Writer functions must ignore fields which they do not recognise, unless they\n can write arbitrary binary output, as field values may be arbitrary binary.\n\n @log_level is guaranteed to be included in @fields as the `PRIORITY` field,\n but is provided separately for convenience of deciding whether or where to\n output the log entry.\n\n Writer functions should return %G_LOG_WRITER_HANDLED if they handled the log\n message successfully or if they deliberately ignored it. If there was an\n error handling the message (for example, if the writer function is meant to\n send messages to a remote logging server and there is a network error), it\n should return %G_LOG_WRITER_UNHANDLED. This allows writer functions to be\n chained and fall back to simpler handlers in case of failure.\n\n Returns: %G_LOG_WRITER_HANDLED if the log entry was handled successfully;\n   %G_LOG_WRITER_UNHANDLED otherwise\n\n Since: 2.50"]
pub type GLogWriterFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput,
>;
extern "C" {
    pub fn g_log_structured(log_domain: *const gchar, log_level: GLogLevelFlags, ...);
}
extern "C" {
    pub fn g_log_structured_array(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
    );
}
extern "C" {
    pub fn g_log_variant(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        fields: *mut GVariant,
    );
}
extern "C" {
    pub fn g_log_set_writer_func(
        func: GLogWriterFunc,
        user_data: gpointer,
        user_data_free: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_log_writer_supports_color(output_fd: gint) -> gboolean;
}
extern "C" {
    pub fn g_log_writer_is_journald(output_fd: gint) -> gboolean;
}
extern "C" {
    pub fn g_log_writer_format_fields(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        use_color: gboolean,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_log_writer_journald(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
extern "C" {
    pub fn g_log_writer_standard_streams(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
extern "C" {
    pub fn g_log_writer_default(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
extern "C" {
    pub fn g_log_writer_default_set_use_stderr(use_stderr: gboolean);
}
extern "C" {
    pub fn g_log_writer_default_would_drop(
        log_level: GLogLevelFlags,
        log_domain: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn g_log_get_debug_enabled() -> gboolean;
}
extern "C" {
    pub fn g_log_set_debug_enabled(enabled: gboolean);
}
extern "C" {
    pub fn _g_log_fallback_handler(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        unused_data: gpointer,
    );
}
extern "C" {
    pub fn g_return_if_fail_warning(
        log_domain: *const ::std::os::raw::c_char,
        pretty_function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_warn_message(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        warnexpr: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assert_warning(
        log_domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        pretty_function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn g_log_structured_standard(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        file: *const gchar,
        line: *const gchar,
        func: *const gchar,
        message_format: *const gchar,
        ...
    );
}
#[doc = " GPrintFunc:\n @string: the message to output\n\n Specifies the type of the print handler functions.\n These are called with the complete formatted string to output."]
pub type GPrintFunc = ::std::option::Option<unsafe extern "C" fn(string: *const gchar)>;
extern "C" {
    pub fn g_print(format: *const gchar, ...);
}
extern "C" {
    pub fn g_set_print_handler(func: GPrintFunc) -> GPrintFunc;
}
extern "C" {
    pub fn g_printerr(format: *const gchar, ...);
}
extern "C" {
    pub fn g_set_printerr_handler(func: GPrintFunc) -> GPrintFunc;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionContext {
    _unused: [u8; 0],
}
#[doc = " GOptionContext:\n\n A `GOptionContext` struct defines which options\n are accepted by the commandline option parser. The struct has only private\n fields and should not be directly accessed."]
pub type GOptionContext = _GOptionContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionGroup {
    _unused: [u8; 0],
}
#[doc = " GOptionGroup:\n\n A `GOptionGroup` struct defines the options in a single\n group. The struct has only private fields and should not be directly accessed.\n\n All options in a group share the same translation function. Libraries which\n need to parse commandline options are expected to provide a function for\n getting a `GOptionGroup` holding their options, which\n the application can then add to its #GOptionContext."]
pub type GOptionGroup = _GOptionGroup;
#[doc = " GOptionEntry:\n @long_name: The long name of an option can be used to specify it\n     in a commandline as `--long_name`. Every option must have a\n     long name. To resolve conflicts if multiple option groups contain\n     the same long name, it is also possible to specify the option as\n     `--groupname-long_name`.\n @short_name: If an option has a short name, it can be specified\n     `-short_name` in a commandline. @short_name must be  a printable\n     ASCII character different from '-', or zero if the option has no\n     short name.\n @flags: Flags from #GOptionFlags\n @arg: The type of the option, as a #GOptionArg\n @arg_data: If the @arg type is %G_OPTION_ARG_CALLBACK, then @arg_data\n     must point to a #GOptionArgFunc callback function, which will be\n     called to handle the extra argument. Otherwise, @arg_data is a\n     pointer to a location to store the value, the required type of\n     the location depends on the @arg type:\n      - %G_OPTION_ARG_NONE: %gboolean\n      - %G_OPTION_ARG_STRING: %gchar*\n      - %G_OPTION_ARG_INT: %gint\n      - %G_OPTION_ARG_FILENAME: %gchar*\n      - %G_OPTION_ARG_STRING_ARRAY: %gchar**\n      - %G_OPTION_ARG_FILENAME_ARRAY: %gchar**\n      - %G_OPTION_ARG_DOUBLE: %gdouble\n     If @arg type is %G_OPTION_ARG_STRING or %G_OPTION_ARG_FILENAME,\n     the location will contain a newly allocated string if the option\n     was given. That string needs to be freed by the callee using g_free().\n     Likewise if @arg type is %G_OPTION_ARG_STRING_ARRAY or\n     %G_OPTION_ARG_FILENAME_ARRAY, the data should be freed using g_strfreev().\n @description: the description for the option in `--help`\n     output. The @description is translated using the @translate_func\n     of the group, see g_option_group_set_translation_domain().\n @arg_description: The placeholder to use for the extra argument parsed\n     by the option in `--help` output. The @arg_description is translated\n     using the @translate_func of the group, see\n     g_option_group_set_translation_domain().\n\n A GOptionEntry struct defines a single option. To have an effect, they\n must be added to a #GOptionGroup with g_option_context_add_main_entries()\n or g_option_group_add_entries()."]
pub type GOptionEntry = _GOptionEntry;
pub const GOptionFlags_G_OPTION_FLAG_NONE: GOptionFlags = 0;
pub const GOptionFlags_G_OPTION_FLAG_HIDDEN: GOptionFlags = 1;
pub const GOptionFlags_G_OPTION_FLAG_IN_MAIN: GOptionFlags = 2;
pub const GOptionFlags_G_OPTION_FLAG_REVERSE: GOptionFlags = 4;
pub const GOptionFlags_G_OPTION_FLAG_NO_ARG: GOptionFlags = 8;
pub const GOptionFlags_G_OPTION_FLAG_FILENAME: GOptionFlags = 16;
pub const GOptionFlags_G_OPTION_FLAG_OPTIONAL_ARG: GOptionFlags = 32;
pub const GOptionFlags_G_OPTION_FLAG_NOALIAS: GOptionFlags = 64;
#[doc = " GOptionFlags:\n @G_OPTION_FLAG_NONE: No flags. Since: 2.42.\n @G_OPTION_FLAG_HIDDEN: The option doesn't appear in `--help` output.\n @G_OPTION_FLAG_IN_MAIN: The option appears in the main section of the\n     `--help` output, even if it is defined in a group.\n @G_OPTION_FLAG_REVERSE: For options of the %G_OPTION_ARG_NONE kind, this\n     flag indicates that the sense of the option is reversed. i.e. %FALSE will\n     be stored into the argument rather than %TRUE.\n @G_OPTION_FLAG_NO_ARG: For options of the %G_OPTION_ARG_CALLBACK kind,\n     this flag indicates that the callback does not take any argument\n     (like a %G_OPTION_ARG_NONE option). Since 2.8\n @G_OPTION_FLAG_FILENAME: For options of the %G_OPTION_ARG_CALLBACK\n     kind, this flag indicates that the argument should be passed to the\n     callback in the GLib filename encoding rather than UTF-8. Since 2.8\n @G_OPTION_FLAG_OPTIONAL_ARG: For options of the %G_OPTION_ARG_CALLBACK\n     kind, this flag indicates that the argument supply is optional.\n     If no argument is given then data of %GOptionParseFunc will be\n     set to NULL. Since 2.8\n @G_OPTION_FLAG_NOALIAS: This flag turns off the automatic conflict\n     resolution which prefixes long option names with `groupname-` if\n     there is a conflict. This option should only be used in situations\n     where aliasing is necessary to model some legacy commandline interface.\n     It is not safe to use this option, unless all option groups are under\n     your direct control. Since 2.8.\n\n Flags which modify individual options."]
pub type GOptionFlags = ::std::os::raw::c_int;
pub const GOptionArg_G_OPTION_ARG_NONE: GOptionArg = 0;
pub const GOptionArg_G_OPTION_ARG_STRING: GOptionArg = 1;
pub const GOptionArg_G_OPTION_ARG_INT: GOptionArg = 2;
pub const GOptionArg_G_OPTION_ARG_CALLBACK: GOptionArg = 3;
pub const GOptionArg_G_OPTION_ARG_FILENAME: GOptionArg = 4;
pub const GOptionArg_G_OPTION_ARG_STRING_ARRAY: GOptionArg = 5;
pub const GOptionArg_G_OPTION_ARG_FILENAME_ARRAY: GOptionArg = 6;
pub const GOptionArg_G_OPTION_ARG_DOUBLE: GOptionArg = 7;
pub const GOptionArg_G_OPTION_ARG_INT64: GOptionArg = 8;
#[doc = " GOptionArg:\n @G_OPTION_ARG_NONE: No extra argument. This is useful for simple flags or booleans.\n @G_OPTION_ARG_STRING: The option takes a UTF-8 string argument.\n @G_OPTION_ARG_INT: The option takes an integer argument.\n @G_OPTION_ARG_CALLBACK: The option provides a callback (of type\n     #GOptionArgFunc) to parse the extra argument.\n @G_OPTION_ARG_FILENAME: The option takes a filename as argument, which will\nbe in the GLib filename encoding rather than UTF-8.\n @G_OPTION_ARG_STRING_ARRAY: The option takes a string argument, multiple\n     uses of the option are collected into an array of strings.\n @G_OPTION_ARG_FILENAME_ARRAY: The option takes a filename as argument,\n     multiple uses of the option are collected into an array of strings.\n @G_OPTION_ARG_DOUBLE: The option takes a double argument. The argument\n     can be formatted either for the user's locale or for the \"C\" locale.\n     Since 2.12\n @G_OPTION_ARG_INT64: The option takes a 64-bit integer. Like\n     %G_OPTION_ARG_INT but for larger numbers. The number can be in\n     decimal base, or in hexadecimal (when prefixed with `0x`, for\n     example, `0xffffffff`). Since 2.12\n\n The #GOptionArg enum values determine which type of extra argument the\n options expect to find. If an option expects an extra argument, it can\n be specified in several ways; with a short option: `-x arg`, with a long\n option: `--name arg` or combined in a single argument: `--name=arg`."]
pub type GOptionArg = ::std::os::raw::c_int;
#[doc = " GOptionArgFunc:\n @option_name: The name of the option being parsed. This will be either a\n  single dash followed by a single letter (for a short name) or two dashes\n  followed by a long option name.\n @value: The value to be parsed.\n @data: User data added to the #GOptionGroup containing the option when it\n  was created with g_option_group_new()\n @error: A return location for errors. The error code %G_OPTION_ERROR_FAILED\n  is intended to be used for errors in #GOptionArgFunc callbacks.\n\n The type of function to be passed as callback for %G_OPTION_ARG_CALLBACK\n options.\n\n Returns: %TRUE if the option was successfully parsed, %FALSE if an error\n  occurred, in which case @error should be set with g_set_error()"]
pub type GOptionArgFunc = ::std::option::Option<
    unsafe extern "C" fn(
        option_name: *const gchar,
        value: *const gchar,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean,
>;
#[doc = " GOptionParseFunc:\n @context: The active #GOptionContext\n @group: The group to which the function belongs\n @data: User data added to the #GOptionGroup containing the option when it\n  was created with g_option_group_new()\n @error: A return location for error details\n\n The type of function that can be called before and after parsing.\n\n Returns: %TRUE if the function completed successfully, %FALSE if an error\n  occurred, in which case @error should be set with g_set_error()"]
pub type GOptionParseFunc = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut GOptionContext,
        group: *mut GOptionGroup,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean,
>;
#[doc = " GOptionErrorFunc:\n @context: The active #GOptionContext\n @group: The group to which the function belongs\n @data: User data added to the #GOptionGroup containing the option when it\n  was created with g_option_group_new()\n @error: The #GError containing details about the parse error\n\n The type of function to be used as callback when a parse error occurs."]
pub type GOptionErrorFunc = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut GOptionContext,
        group: *mut GOptionGroup,
        data: gpointer,
        error: *mut *mut GError,
    ),
>;
pub const GOptionError_G_OPTION_ERROR_UNKNOWN_OPTION: GOptionError = 0;
pub const GOptionError_G_OPTION_ERROR_BAD_VALUE: GOptionError = 1;
pub const GOptionError_G_OPTION_ERROR_FAILED: GOptionError = 2;
#[doc = " GOptionError:\n @G_OPTION_ERROR_UNKNOWN_OPTION: An option was not known to the parser.\n  This error will only be reported, if the parser hasn't been instructed\n  to ignore unknown options, see g_option_context_set_ignore_unknown_options().\n @G_OPTION_ERROR_BAD_VALUE: A value couldn't be parsed.\n @G_OPTION_ERROR_FAILED: A #GOptionArgFunc callback failed.\n\n Error codes returned by option parsing."]
pub type GOptionError = ::std::os::raw::c_int;
extern "C" {
    pub fn g_option_error_quark() -> GQuark;
}
#[doc = " GOptionEntry:\n @long_name: The long name of an option can be used to specify it\n     in a commandline as `--long_name`. Every option must have a\n     long name. To resolve conflicts if multiple option groups contain\n     the same long name, it is also possible to specify the option as\n     `--groupname-long_name`.\n @short_name: If an option has a short name, it can be specified\n     `-short_name` in a commandline. @short_name must be  a printable\n     ASCII character different from '-', or zero if the option has no\n     short name.\n @flags: Flags from #GOptionFlags\n @arg: The type of the option, as a #GOptionArg\n @arg_data: If the @arg type is %G_OPTION_ARG_CALLBACK, then @arg_data\n     must point to a #GOptionArgFunc callback function, which will be\n     called to handle the extra argument. Otherwise, @arg_data is a\n     pointer to a location to store the value, the required type of\n     the location depends on the @arg type:\n      - %G_OPTION_ARG_NONE: %gboolean\n      - %G_OPTION_ARG_STRING: %gchar*\n      - %G_OPTION_ARG_INT: %gint\n      - %G_OPTION_ARG_FILENAME: %gchar*\n      - %G_OPTION_ARG_STRING_ARRAY: %gchar**\n      - %G_OPTION_ARG_FILENAME_ARRAY: %gchar**\n      - %G_OPTION_ARG_DOUBLE: %gdouble\n     If @arg type is %G_OPTION_ARG_STRING or %G_OPTION_ARG_FILENAME,\n     the location will contain a newly allocated string if the option\n     was given. That string needs to be freed by the callee using g_free().\n     Likewise if @arg type is %G_OPTION_ARG_STRING_ARRAY or\n     %G_OPTION_ARG_FILENAME_ARRAY, the data should be freed using g_strfreev().\n @description: the description for the option in `--help`\n     output. The @description is translated using the @translate_func\n     of the group, see g_option_group_set_translation_domain().\n @arg_description: The placeholder to use for the extra argument parsed\n     by the option in `--help` output. The @arg_description is translated\n     using the @translate_func of the group, see\n     g_option_group_set_translation_domain().\n\n A GOptionEntry struct defines a single option. To have an effect, they\n must be added to a #GOptionGroup with g_option_context_add_main_entries()\n or g_option_group_add_entries()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionEntry {
    pub long_name: *const gchar,
    pub short_name: gchar,
    pub flags: gint,
    pub arg: GOptionArg,
    pub arg_data: gpointer,
    pub description: *const gchar,
    pub arg_description: *const gchar,
}
#[test]
fn bindgen_test_layout__GOptionEntry() {
    const UNINIT: ::std::mem::MaybeUninit<_GOptionEntry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GOptionEntry>(),
        48usize,
        concat!("Size of: ", stringify!(_GOptionEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<_GOptionEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOptionEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).long_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(long_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).short_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(short_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(arg_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg_description) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(arg_description)
        )
    );
}
extern "C" {
    pub fn g_option_context_new(parameter_string: *const gchar) -> *mut GOptionContext;
}
extern "C" {
    pub fn g_option_context_set_summary(context: *mut GOptionContext, summary: *const gchar);
}
extern "C" {
    pub fn g_option_context_get_summary(context: *mut GOptionContext) -> *const gchar;
}
extern "C" {
    pub fn g_option_context_set_description(
        context: *mut GOptionContext,
        description: *const gchar,
    );
}
extern "C" {
    pub fn g_option_context_get_description(context: *mut GOptionContext) -> *const gchar;
}
extern "C" {
    pub fn g_option_context_free(context: *mut GOptionContext);
}
extern "C" {
    pub fn g_option_context_set_help_enabled(context: *mut GOptionContext, help_enabled: gboolean);
}
extern "C" {
    pub fn g_option_context_get_help_enabled(context: *mut GOptionContext) -> gboolean;
}
extern "C" {
    pub fn g_option_context_set_ignore_unknown_options(
        context: *mut GOptionContext,
        ignore_unknown: gboolean,
    );
}
extern "C" {
    pub fn g_option_context_get_ignore_unknown_options(context: *mut GOptionContext) -> gboolean;
}
extern "C" {
    pub fn g_option_context_set_strict_posix(context: *mut GOptionContext, strict_posix: gboolean);
}
extern "C" {
    pub fn g_option_context_get_strict_posix(context: *mut GOptionContext) -> gboolean;
}
extern "C" {
    pub fn g_option_context_add_main_entries(
        context: *mut GOptionContext,
        entries: *const GOptionEntry,
        translation_domain: *const gchar,
    );
}
extern "C" {
    pub fn g_option_context_parse(
        context: *mut GOptionContext,
        argc: *mut gint,
        argv: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_option_context_parse_strv(
        context: *mut GOptionContext,
        arguments: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_option_context_set_translate_func(
        context: *mut GOptionContext,
        func: GTranslateFunc,
        data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_option_context_set_translation_domain(
        context: *mut GOptionContext,
        domain: *const gchar,
    );
}
extern "C" {
    pub fn g_option_context_add_group(context: *mut GOptionContext, group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_option_context_set_main_group(context: *mut GOptionContext, group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_option_context_get_main_group(context: *mut GOptionContext) -> *mut GOptionGroup;
}
extern "C" {
    pub fn g_option_context_get_help(
        context: *mut GOptionContext,
        main_help: gboolean,
        group: *mut GOptionGroup,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_option_group_new(
        name: *const gchar,
        description: *const gchar,
        help_description: *const gchar,
        user_data: gpointer,
        destroy: GDestroyNotify,
    ) -> *mut GOptionGroup;
}
extern "C" {
    pub fn g_option_group_set_parse_hooks(
        group: *mut GOptionGroup,
        pre_parse_func: GOptionParseFunc,
        post_parse_func: GOptionParseFunc,
    );
}
extern "C" {
    pub fn g_option_group_set_error_hook(group: *mut GOptionGroup, error_func: GOptionErrorFunc);
}
extern "C" {
    pub fn g_option_group_free(group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_option_group_ref(group: *mut GOptionGroup) -> *mut GOptionGroup;
}
extern "C" {
    pub fn g_option_group_unref(group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_option_group_add_entries(group: *mut GOptionGroup, entries: *const GOptionEntry);
}
extern "C" {
    pub fn g_option_group_set_translate_func(
        group: *mut GOptionGroup,
        func: GTranslateFunc,
        data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_option_group_set_translation_domain(group: *mut GOptionGroup, domain: *const gchar);
}
#[doc = " GPathBuf: (copy-func g_path_buf_copy) (free-func g_path_buf_free)\n\n A mutable path builder.\n\n Since: 2.76"]
pub type GPathBuf = _GPathBuf;
#[doc = " GPathBuf: (copy-func g_path_buf_copy) (free-func g_path_buf_free)\n\n A mutable path builder.\n\n Since: 2.76"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPathBuf {
    pub dummy: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GPathBuf() {
    const UNINIT: ::std::mem::MaybeUninit<_GPathBuf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GPathBuf>(),
        64usize,
        concat!("Size of: ", stringify!(_GPathBuf))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPathBuf>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPathBuf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPathBuf),
            "::",
            stringify!(dummy)
        )
    );
}
extern "C" {
    pub fn g_path_buf_new() -> *mut GPathBuf;
}
extern "C" {
    pub fn g_path_buf_new_from_path(path: *const ::std::os::raw::c_char) -> *mut GPathBuf;
}
extern "C" {
    pub fn g_path_buf_init(buf: *mut GPathBuf) -> *mut GPathBuf;
}
extern "C" {
    pub fn g_path_buf_init_from_path(
        buf: *mut GPathBuf,
        path: *const ::std::os::raw::c_char,
    ) -> *mut GPathBuf;
}
extern "C" {
    pub fn g_path_buf_clear(buf: *mut GPathBuf);
}
extern "C" {
    pub fn g_path_buf_clear_to_path(buf: *mut GPathBuf) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_path_buf_free(buf: *mut GPathBuf);
}
extern "C" {
    pub fn g_path_buf_free_to_path(buf: *mut GPathBuf) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_path_buf_copy(buf: *mut GPathBuf) -> *mut GPathBuf;
}
extern "C" {
    pub fn g_path_buf_push(
        buf: *mut GPathBuf,
        path: *const ::std::os::raw::c_char,
    ) -> *mut GPathBuf;
}
extern "C" {
    pub fn g_path_buf_pop(buf: *mut GPathBuf) -> gboolean;
}
extern "C" {
    pub fn g_path_buf_set_filename(
        buf: *mut GPathBuf,
        file_name: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn g_path_buf_set_extension(
        buf: *mut GPathBuf,
        extension: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn g_path_buf_to_path(buf: *mut GPathBuf) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_path_buf_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPatternSpec {
    _unused: [u8; 0],
}
pub type GPatternSpec = _GPatternSpec;
extern "C" {
    pub fn g_pattern_spec_new(pattern: *const gchar) -> *mut GPatternSpec;
}
extern "C" {
    pub fn g_pattern_spec_free(pspec: *mut GPatternSpec);
}
extern "C" {
    pub fn g_pattern_spec_copy(pspec: *mut GPatternSpec) -> *mut GPatternSpec;
}
extern "C" {
    pub fn g_pattern_spec_equal(pspec1: *mut GPatternSpec, pspec2: *mut GPatternSpec) -> gboolean;
}
extern "C" {
    pub fn g_pattern_spec_match(
        pspec: *mut GPatternSpec,
        string_length: gsize,
        string: *const gchar,
        string_reversed: *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_pattern_spec_match_string(pspec: *mut GPatternSpec, string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_pattern_match(
        pspec: *mut GPatternSpec,
        string_length: guint,
        string: *const gchar,
        string_reversed: *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_pattern_match_string(pspec: *mut GPatternSpec, string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_pattern_match_simple(pattern: *const gchar, string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_spaced_primes_closest(num: guint) -> guint;
}
extern "C" {
    pub fn g_qsort_with_data(
        pbase: gconstpointer,
        total_elems: gint,
        size: gsize,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
#[doc = " GQueue:\n @head: a pointer to the first element of the queue\n @tail: a pointer to the last element of the queue\n @length: the number of elements in the queue\n\n Contains the public fields of a\n [Queue][glib-Double-ended-Queues]."]
pub type GQueue = _GQueue;
#[doc = " GQueue:\n @head: a pointer to the first element of the queue\n @tail: a pointer to the last element of the queue\n @length: the number of elements in the queue\n\n Contains the public fields of a\n [Queue][glib-Double-ended-Queues]."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GQueue {
    pub head: *mut GList,
    pub tail: *mut GList,
    pub length: guint,
}
#[test]
fn bindgen_test_layout__GQueue() {
    const UNINIT: ::std::mem::MaybeUninit<_GQueue> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GQueue>(),
        24usize,
        concat!("Size of: ", stringify!(_GQueue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GQueue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GQueue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GQueue),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tail) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GQueue),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GQueue),
            "::",
            stringify!(length)
        )
    );
}
extern "C" {
    pub fn g_queue_new() -> *mut GQueue;
}
extern "C" {
    pub fn g_queue_free(queue: *mut GQueue);
}
extern "C" {
    pub fn g_queue_free_full(queue: *mut GQueue, free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_queue_init(queue: *mut GQueue);
}
extern "C" {
    pub fn g_queue_clear(queue: *mut GQueue);
}
extern "C" {
    pub fn g_queue_is_empty(queue: *mut GQueue) -> gboolean;
}
extern "C" {
    pub fn g_queue_clear_full(queue: *mut GQueue, free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_queue_get_length(queue: *mut GQueue) -> guint;
}
extern "C" {
    pub fn g_queue_reverse(queue: *mut GQueue);
}
extern "C" {
    pub fn g_queue_copy(queue: *mut GQueue) -> *mut GQueue;
}
extern "C" {
    pub fn g_queue_foreach(queue: *mut GQueue, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_queue_find(queue: *mut GQueue, data: gconstpointer) -> *mut GList;
}
extern "C" {
    pub fn g_queue_find_custom(
        queue: *mut GQueue,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_queue_sort(queue: *mut GQueue, compare_func: GCompareDataFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_queue_push_head(queue: *mut GQueue, data: gpointer);
}
extern "C" {
    pub fn g_queue_push_tail(queue: *mut GQueue, data: gpointer);
}
extern "C" {
    pub fn g_queue_push_nth(queue: *mut GQueue, data: gpointer, n: gint);
}
extern "C" {
    pub fn g_queue_pop_head(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    pub fn g_queue_pop_tail(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    pub fn g_queue_pop_nth(queue: *mut GQueue, n: guint) -> gpointer;
}
extern "C" {
    pub fn g_queue_peek_head(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    pub fn g_queue_peek_tail(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    pub fn g_queue_peek_nth(queue: *mut GQueue, n: guint) -> gpointer;
}
extern "C" {
    pub fn g_queue_index(queue: *mut GQueue, data: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_queue_remove(queue: *mut GQueue, data: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_queue_remove_all(queue: *mut GQueue, data: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_queue_insert_before(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
}
extern "C" {
    pub fn g_queue_insert_before_link(queue: *mut GQueue, sibling: *mut GList, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_insert_after(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
}
extern "C" {
    pub fn g_queue_insert_after_link(queue: *mut GQueue, sibling: *mut GList, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_insert_sorted(
        queue: *mut GQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_queue_push_head_link(queue: *mut GQueue, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_push_tail_link(queue: *mut GQueue, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_push_nth_link(queue: *mut GQueue, n: gint, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_pop_head_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    pub fn g_queue_pop_tail_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    pub fn g_queue_pop_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
}
extern "C" {
    pub fn g_queue_peek_head_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    pub fn g_queue_peek_tail_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    pub fn g_queue_peek_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
}
extern "C" {
    pub fn g_queue_link_index(queue: *mut GQueue, link_: *mut GList) -> gint;
}
extern "C" {
    pub fn g_queue_unlink(queue: *mut GQueue, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_delete_link(queue: *mut GQueue, link_: *mut GList);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRand {
    _unused: [u8; 0],
}
pub type GRand = _GRand;
extern "C" {
    pub fn g_rand_new_with_seed(seed: guint32) -> *mut GRand;
}
extern "C" {
    pub fn g_rand_new_with_seed_array(seed: *const guint32, seed_length: guint) -> *mut GRand;
}
extern "C" {
    pub fn g_rand_new() -> *mut GRand;
}
extern "C" {
    pub fn g_rand_free(rand_: *mut GRand);
}
extern "C" {
    pub fn g_rand_copy(rand_: *mut GRand) -> *mut GRand;
}
extern "C" {
    pub fn g_rand_set_seed(rand_: *mut GRand, seed: guint32);
}
extern "C" {
    pub fn g_rand_set_seed_array(rand_: *mut GRand, seed: *const guint32, seed_length: guint);
}
extern "C" {
    pub fn g_rand_int(rand_: *mut GRand) -> guint32;
}
extern "C" {
    pub fn g_rand_int_range(rand_: *mut GRand, begin: gint32, end: gint32) -> gint32;
}
extern "C" {
    pub fn g_rand_double(rand_: *mut GRand) -> gdouble;
}
extern "C" {
    pub fn g_rand_double_range(rand_: *mut GRand, begin: gdouble, end: gdouble) -> gdouble;
}
extern "C" {
    pub fn g_random_set_seed(seed: guint32);
}
extern "C" {
    pub fn g_random_int() -> guint32;
}
extern "C" {
    pub fn g_random_int_range(begin: gint32, end: gint32) -> gint32;
}
extern "C" {
    pub fn g_random_double() -> gdouble;
}
extern "C" {
    pub fn g_random_double_range(begin: gdouble, end: gdouble) -> gdouble;
}
extern "C" {
    pub fn g_rc_box_alloc(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_rc_box_alloc0(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_rc_box_dup(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_rc_box_acquire(mem_block: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_rc_box_release(mem_block: gpointer);
}
extern "C" {
    pub fn g_rc_box_release_full(mem_block: gpointer, clear_func: GDestroyNotify);
}
extern "C" {
    pub fn g_rc_box_get_size(mem_block: gpointer) -> gsize;
}
extern "C" {
    pub fn g_atomic_rc_box_alloc(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_atomic_rc_box_alloc0(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_atomic_rc_box_dup(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_atomic_rc_box_acquire(mem_block: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_atomic_rc_box_release(mem_block: gpointer);
}
extern "C" {
    pub fn g_atomic_rc_box_release_full(mem_block: gpointer, clear_func: GDestroyNotify);
}
extern "C" {
    pub fn g_atomic_rc_box_get_size(mem_block: gpointer) -> gsize;
}
extern "C" {
    pub fn g_ref_count_init(rc: *mut grefcount);
}
extern "C" {
    pub fn g_ref_count_inc(rc: *mut grefcount);
}
extern "C" {
    pub fn g_ref_count_dec(rc: *mut grefcount) -> gboolean;
}
extern "C" {
    pub fn g_ref_count_compare(rc: *mut grefcount, val: gint) -> gboolean;
}
extern "C" {
    pub fn g_atomic_ref_count_init(arc: *mut gatomicrefcount);
}
extern "C" {
    pub fn g_atomic_ref_count_inc(arc: *mut gatomicrefcount);
}
extern "C" {
    pub fn g_atomic_ref_count_dec(arc: *mut gatomicrefcount) -> gboolean;
}
extern "C" {
    pub fn g_atomic_ref_count_compare(arc: *mut gatomicrefcount, val: gint) -> gboolean;
}
extern "C" {
    pub fn g_ref_string_new(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_ref_string_new_len(
        str_: *const ::std::os::raw::c_char,
        len: gssize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_ref_string_new_intern(
        str_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_ref_string_acquire(str_: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_ref_string_release(str_: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_ref_string_length(str_: *mut ::std::os::raw::c_char) -> gsize;
}
#[doc = " GRefString:\n\n A typedef for a reference-counted string. A pointer to a #GRefString can be\n treated like a standard `char*` array by all code, but can additionally have\n `g_ref_string_*()` methods called on it. `g_ref_string_*()` methods cannot be\n called on `char*` arrays not allocated using g_ref_string_new().\n\n If using #GRefString with autocleanups, g_autoptr() must be used rather than\n g_autofree(), so that the reference counting metadata is also freed.\n\n Since: 2.58"]
pub type GRefString = ::std::os::raw::c_char;
pub const GRegexError_G_REGEX_ERROR_COMPILE: GRegexError = 0;
pub const GRegexError_G_REGEX_ERROR_OPTIMIZE: GRegexError = 1;
pub const GRegexError_G_REGEX_ERROR_REPLACE: GRegexError = 2;
pub const GRegexError_G_REGEX_ERROR_MATCH: GRegexError = 3;
pub const GRegexError_G_REGEX_ERROR_INTERNAL: GRegexError = 4;
pub const GRegexError_G_REGEX_ERROR_STRAY_BACKSLASH: GRegexError = 101;
pub const GRegexError_G_REGEX_ERROR_MISSING_CONTROL_CHAR: GRegexError = 102;
pub const GRegexError_G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: GRegexError = 103;
pub const GRegexError_G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: GRegexError = 104;
pub const GRegexError_G_REGEX_ERROR_QUANTIFIER_TOO_BIG: GRegexError = 105;
pub const GRegexError_G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: GRegexError = 106;
pub const GRegexError_G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: GRegexError = 107;
pub const GRegexError_G_REGEX_ERROR_RANGE_OUT_OF_ORDER: GRegexError = 108;
pub const GRegexError_G_REGEX_ERROR_NOTHING_TO_REPEAT: GRegexError = 109;
pub const GRegexError_G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: GRegexError = 112;
pub const GRegexError_G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: GRegexError = 113;
pub const GRegexError_G_REGEX_ERROR_UNMATCHED_PARENTHESIS: GRegexError = 114;
pub const GRegexError_G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: GRegexError = 115;
pub const GRegexError_G_REGEX_ERROR_UNTERMINATED_COMMENT: GRegexError = 118;
pub const GRegexError_G_REGEX_ERROR_EXPRESSION_TOO_LARGE: GRegexError = 120;
pub const GRegexError_G_REGEX_ERROR_MEMORY_ERROR: GRegexError = 121;
pub const GRegexError_G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: GRegexError = 125;
pub const GRegexError_G_REGEX_ERROR_MALFORMED_CONDITION: GRegexError = 126;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: GRegexError = 127;
pub const GRegexError_G_REGEX_ERROR_ASSERTION_EXPECTED: GRegexError = 128;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: GRegexError = 130;
pub const GRegexError_G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: GRegexError = 131;
pub const GRegexError_G_REGEX_ERROR_HEX_CODE_TOO_LARGE: GRegexError = 134;
pub const GRegexError_G_REGEX_ERROR_INVALID_CONDITION: GRegexError = 135;
pub const GRegexError_G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: GRegexError = 136;
pub const GRegexError_G_REGEX_ERROR_INFINITE_LOOP: GRegexError = 140;
pub const GRegexError_G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: GRegexError = 142;
pub const GRegexError_G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: GRegexError = 143;
pub const GRegexError_G_REGEX_ERROR_MALFORMED_PROPERTY: GRegexError = 146;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_PROPERTY: GRegexError = 147;
pub const GRegexError_G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: GRegexError = 148;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: GRegexError = 149;
pub const GRegexError_G_REGEX_ERROR_INVALID_OCTAL_VALUE: GRegexError = 151;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: GRegexError = 154;
pub const GRegexError_G_REGEX_ERROR_DEFINE_REPETION: GRegexError = 155;
pub const GRegexError_G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: GRegexError = 156;
pub const GRegexError_G_REGEX_ERROR_MISSING_BACK_REFERENCE: GRegexError = 157;
pub const GRegexError_G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: GRegexError = 158;
pub const GRegexError_G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: GRegexError = 159;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: GRegexError = 160;
pub const GRegexError_G_REGEX_ERROR_NUMBER_TOO_BIG: GRegexError = 161;
pub const GRegexError_G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: GRegexError = 162;
pub const GRegexError_G_REGEX_ERROR_MISSING_DIGIT: GRegexError = 163;
pub const GRegexError_G_REGEX_ERROR_INVALID_DATA_CHARACTER: GRegexError = 164;
pub const GRegexError_G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: GRegexError = 165;
pub const GRegexError_G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: GRegexError = 166;
pub const GRegexError_G_REGEX_ERROR_INVALID_CONTROL_CHAR: GRegexError = 168;
pub const GRegexError_G_REGEX_ERROR_MISSING_NAME: GRegexError = 169;
pub const GRegexError_G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: GRegexError = 171;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: GRegexError = 172;
pub const GRegexError_G_REGEX_ERROR_NAME_TOO_LONG: GRegexError = 175;
pub const GRegexError_G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: GRegexError = 176;
#[doc = " GRegexError:\n @G_REGEX_ERROR_COMPILE: Compilation of the regular expression failed.\n @G_REGEX_ERROR_OPTIMIZE: Optimization of the regular expression failed.\n @G_REGEX_ERROR_REPLACE: Replacement failed due to an ill-formed replacement\n     string.\n @G_REGEX_ERROR_MATCH: The match process failed.\n @G_REGEX_ERROR_INTERNAL: Internal error of the regular expression engine.\n     Since 2.16\n @G_REGEX_ERROR_STRAY_BACKSLASH: \"\\\\\" at end of pattern. Since 2.16\n @G_REGEX_ERROR_MISSING_CONTROL_CHAR: \"\\\\c\" at end of pattern. Since 2.16\n @G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: Unrecognized character follows \"\\\\\".\n     Since 2.16\n @G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: Numbers out of order in \"{}\"\n     quantifier. Since 2.16\n @G_REGEX_ERROR_QUANTIFIER_TOO_BIG: Number too big in \"{}\" quantifier.\n     Since 2.16\n @G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: Missing terminating \"]\" for\n     character class. Since 2.16\n @G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: Invalid escape sequence\n     in character class. Since 2.16\n @G_REGEX_ERROR_RANGE_OUT_OF_ORDER: Range out of order in character class.\n     Since 2.16\n @G_REGEX_ERROR_NOTHING_TO_REPEAT: Nothing to repeat. Since 2.16\n @G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: Unrecognized character after \"(?\",\n     \"(?<\" or \"(?P\". Since 2.16\n @G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: POSIX named classes are\n     supported only within a class. Since 2.16\n @G_REGEX_ERROR_UNMATCHED_PARENTHESIS: Missing terminating \")\" or \")\"\n     without opening \"(\". Since 2.16\n @G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: Reference to non-existent\n     subpattern. Since 2.16\n @G_REGEX_ERROR_UNTERMINATED_COMMENT: Missing terminating \")\" after comment.\n     Since 2.16\n @G_REGEX_ERROR_EXPRESSION_TOO_LARGE: Regular expression too large.\n     Since 2.16\n @G_REGEX_ERROR_MEMORY_ERROR: Failed to get memory. Since 2.16\n @G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: Lookbehind assertion is not\n     fixed length. Since 2.16\n @G_REGEX_ERROR_MALFORMED_CONDITION: Malformed number or name after \"(?(\".\n     Since 2.16\n @G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: Conditional group contains\n     more than two branches. Since 2.16\n @G_REGEX_ERROR_ASSERTION_EXPECTED: Assertion expected after \"(?(\".\n     Since 2.16\n @G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: Unknown POSIX class name.\n     Since 2.16\n @G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: POSIX collating\n     elements are not supported. Since 2.16\n @G_REGEX_ERROR_HEX_CODE_TOO_LARGE: Character value in \"\\\\x{...}\" sequence\n     is too large. Since 2.16\n @G_REGEX_ERROR_INVALID_CONDITION: Invalid condition \"(?(0)\". Since 2.16\n @G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: \\\\C not allowed in\n     lookbehind assertion. Since 2.16\n @G_REGEX_ERROR_INFINITE_LOOP: Recursive call could loop indefinitely.\n     Since 2.16\n @G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: Missing terminator\n     in subpattern name. Since 2.16\n @G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: Two named subpatterns have\n     the same name. Since 2.16\n @G_REGEX_ERROR_MALFORMED_PROPERTY: Malformed \"\\\\P\" or \"\\\\p\" sequence.\n     Since 2.16\n @G_REGEX_ERROR_UNKNOWN_PROPERTY: Unknown property name after \"\\\\P\" or\n     \"\\\\p\". Since 2.16\n @G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: Subpattern name is too long\n     (maximum 32 characters). Since 2.16\n @G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: Too many named subpatterns (maximum\n     10,000). Since 2.16\n @G_REGEX_ERROR_INVALID_OCTAL_VALUE: Octal value is greater than \"\\\\377\".\n     Since 2.16\n @G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: \"DEFINE\" group contains more\n     than one branch. Since 2.16\n @G_REGEX_ERROR_DEFINE_REPETION: Repeating a \"DEFINE\" group is not allowed.\n     This error is never raised. Since: 2.16 Deprecated: 2.34\n @G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: Inconsistent newline options.\n     Since 2.16\n @G_REGEX_ERROR_MISSING_BACK_REFERENCE: \"\\\\g\" is not followed by a braced,\n      angle-bracketed, or quoted name or number, or by a plain number. Since: 2.16\n @G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: relative reference must not be zero. Since: 2.34\n @G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: the backtracing\n     control verb used does not allow an argument. Since: 2.34\n @G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: unknown backtracing\n     control verb. Since: 2.34\n @G_REGEX_ERROR_NUMBER_TOO_BIG: number is too big in escape sequence. Since: 2.34\n @G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: Missing subpattern name. Since: 2.34\n @G_REGEX_ERROR_MISSING_DIGIT: Missing digit. Since 2.34\n @G_REGEX_ERROR_INVALID_DATA_CHARACTER: In JavaScript compatibility mode,\n     \"[\" is an invalid data character. Since: 2.34\n @G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: different names for subpatterns of the\n     same number are not allowed. Since: 2.34\n @G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: the backtracing control\n     verb requires an argument. Since: 2.34\n @G_REGEX_ERROR_INVALID_CONTROL_CHAR: \"\\\\c\" must be followed by an ASCII\n     character. Since: 2.34\n @G_REGEX_ERROR_MISSING_NAME: \"\\\\k\" is not followed by a braced, angle-bracketed, or\n     quoted name. Since: 2.34\n @G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: \"\\\\N\" is not supported in a class. Since: 2.34\n @G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: too many forward references. Since: 2.34\n @G_REGEX_ERROR_NAME_TOO_LONG: the name is too long in \"(*MARK)\", \"(*PRUNE)\",\n     \"(*SKIP)\", or \"(*THEN)\". Since: 2.34\n @G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: the character value in the \\\\u sequence is\n     too large. Since: 2.34\n\n Error codes returned by regular expressions functions.\n\n Since: 2.14"]
pub type GRegexError = ::std::os::raw::c_int;
extern "C" {
    pub fn g_regex_error_quark() -> GQuark;
}
pub const GRegexCompileFlags_G_REGEX_DEFAULT: GRegexCompileFlags = 0;
pub const GRegexCompileFlags_G_REGEX_CASELESS: GRegexCompileFlags = 1;
pub const GRegexCompileFlags_G_REGEX_MULTILINE: GRegexCompileFlags = 2;
pub const GRegexCompileFlags_G_REGEX_DOTALL: GRegexCompileFlags = 4;
pub const GRegexCompileFlags_G_REGEX_EXTENDED: GRegexCompileFlags = 8;
pub const GRegexCompileFlags_G_REGEX_ANCHORED: GRegexCompileFlags = 16;
pub const GRegexCompileFlags_G_REGEX_DOLLAR_ENDONLY: GRegexCompileFlags = 32;
pub const GRegexCompileFlags_G_REGEX_UNGREEDY: GRegexCompileFlags = 512;
pub const GRegexCompileFlags_G_REGEX_RAW: GRegexCompileFlags = 2048;
pub const GRegexCompileFlags_G_REGEX_NO_AUTO_CAPTURE: GRegexCompileFlags = 4096;
pub const GRegexCompileFlags_G_REGEX_OPTIMIZE: GRegexCompileFlags = 8192;
pub const GRegexCompileFlags_G_REGEX_FIRSTLINE: GRegexCompileFlags = 262144;
pub const GRegexCompileFlags_G_REGEX_DUPNAMES: GRegexCompileFlags = 524288;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_CR: GRegexCompileFlags = 1048576;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_LF: GRegexCompileFlags = 2097152;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_CRLF: GRegexCompileFlags = 3145728;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_ANYCRLF: GRegexCompileFlags = 5242880;
pub const GRegexCompileFlags_G_REGEX_BSR_ANYCRLF: GRegexCompileFlags = 8388608;
pub const GRegexCompileFlags_G_REGEX_JAVASCRIPT_COMPAT: GRegexCompileFlags = 33554432;
#[doc = " GRegexCompileFlags:\n @G_REGEX_DEFAULT: No special options set. Since: 2.74\n @G_REGEX_CASELESS: Letters in the pattern match both upper- and\n     lowercase letters. This option can be changed within a pattern\n     by a \"(?i)\" option setting.\n @G_REGEX_MULTILINE: By default, GRegex treats the strings as consisting\n     of a single line of characters (even if it actually contains\n     newlines). The \"start of line\" metacharacter (\"^\") matches only\n     at the start of the string, while the \"end of line\" metacharacter\n     (\"$\") matches only at the end of the string, or before a terminating\n     newline (unless %G_REGEX_DOLLAR_ENDONLY is set). When\n     %G_REGEX_MULTILINE is set, the \"start of line\" and \"end of line\"\n     constructs match immediately following or immediately before any\n     newline in the string, respectively, as well as at the very start\n     and end. This can be changed within a pattern by a \"(?m)\" option\n     setting.\n @G_REGEX_DOTALL: A dot metacharacter (\".\") in the pattern matches all\n     characters, including newlines. Without it, newlines are excluded.\n     This option can be changed within a pattern by a (\"?s\") option setting.\n @G_REGEX_EXTENDED: Whitespace data characters in the pattern are\n     totally ignored except when escaped or inside a character class.\n     Whitespace does not include the VT character (code 11). In addition,\n     characters between an unescaped \"#\" outside a character class and\n     the next newline character, inclusive, are also ignored. This can\n     be changed within a pattern by a \"(?x)\" option setting.\n @G_REGEX_ANCHORED: The pattern is forced to be \"anchored\", that is,\n     it is constrained to match only at the first matching point in the\n     string that is being searched. This effect can also be achieved by\n     appropriate constructs in the pattern itself such as the \"^\"\n     metacharacter.\n @G_REGEX_DOLLAR_ENDONLY: A dollar metacharacter (\"$\") in the pattern\n     matches only at the end of the string. Without this option, a\n     dollar also matches immediately before the final character if\n     it is a newline (but not before any other newlines). This option\n     is ignored if %G_REGEX_MULTILINE is set.\n @G_REGEX_UNGREEDY: Inverts the \"greediness\" of the quantifiers so that\n     they are not greedy by default, but become greedy if followed by \"?\".\n     It can also be set by a \"(?U)\" option setting within the pattern.\n @G_REGEX_RAW: Usually strings must be valid UTF-8 strings, using this\n     flag they are considered as a raw sequence of bytes.\n @G_REGEX_NO_AUTO_CAPTURE: Disables the use of numbered capturing\n     parentheses in the pattern. Any opening parenthesis that is not\n     followed by \"?\" behaves as if it were followed by \"?:\" but named\n     parentheses can still be used for capturing (and they acquire numbers\n     in the usual way).\n @G_REGEX_OPTIMIZE: Since 2.74 and the port to pcre2, requests JIT\n     compilation, which, if the just-in-time compiler is available, further\n     processes a compiled pattern into machine code that executes much\n     faster. However, it comes at the cost of extra processing before the\n     match is performed, so it is most beneficial to use this when the same\n     compiled pattern is used for matching many times. Before 2.74 this\n     option used the built-in non-JIT optimizations in pcre1.\n @G_REGEX_FIRSTLINE: Limits an unanchored pattern to match before (or at) the\n     first newline. Since: 2.34\n @G_REGEX_DUPNAMES: Names used to identify capturing subpatterns need not\n     be unique. This can be helpful for certain types of pattern when it\n     is known that only one instance of the named subpattern can ever be\n     matched.\n @G_REGEX_NEWLINE_CR: Usually any newline character or character sequence is\n     recognized. If this option is set, the only recognized newline character\n     is '\\r'.\n @G_REGEX_NEWLINE_LF: Usually any newline character or character sequence is\n     recognized. If this option is set, the only recognized newline character\n     is '\\n'.\n @G_REGEX_NEWLINE_CRLF: Usually any newline character or character sequence is\n     recognized. If this option is set, the only recognized newline character\n     sequence is '\\r\\n'.\n @G_REGEX_NEWLINE_ANYCRLF: Usually any newline character or character sequence\n     is recognized. If this option is set, the only recognized newline character\n     sequences are '\\r', '\\n', and '\\r\\n'. Since: 2.34\n @G_REGEX_BSR_ANYCRLF: Usually any newline character or character sequence\n     is recognised. If this option is set, then \"\\R\" only recognizes the newline\n    characters '\\r', '\\n' and '\\r\\n'. Since: 2.34\n @G_REGEX_JAVASCRIPT_COMPAT: Changes behaviour so that it is compatible with\n     JavaScript rather than PCRE. Since GLib 2.74 this is no longer supported,\n     as libpcre2 does not support it. Since: 2.34 Deprecated: 2.74\n\n Flags specifying compile-time options.\n\n Since: 2.14"]
pub type GRegexCompileFlags = ::std::os::raw::c_int;
pub const GRegexMatchFlags_G_REGEX_MATCH_DEFAULT: GRegexMatchFlags = 0;
pub const GRegexMatchFlags_G_REGEX_MATCH_ANCHORED: GRegexMatchFlags = 16;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTBOL: GRegexMatchFlags = 128;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEOL: GRegexMatchFlags = 256;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEMPTY: GRegexMatchFlags = 1024;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL: GRegexMatchFlags = 32768;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_CR: GRegexMatchFlags = 1048576;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_LF: GRegexMatchFlags = 2097152;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_CRLF: GRegexMatchFlags = 3145728;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_ANY: GRegexMatchFlags = 4194304;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_ANYCRLF: GRegexMatchFlags = 5242880;
pub const GRegexMatchFlags_G_REGEX_MATCH_BSR_ANYCRLF: GRegexMatchFlags = 8388608;
pub const GRegexMatchFlags_G_REGEX_MATCH_BSR_ANY: GRegexMatchFlags = 16777216;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL_SOFT: GRegexMatchFlags = 32768;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL_HARD: GRegexMatchFlags = 134217728;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEMPTY_ATSTART: GRegexMatchFlags = 268435456;
#[doc = " GRegexMatchFlags:\n @G_REGEX_MATCH_DEFAULT: No special options set. Since: 2.74\n @G_REGEX_MATCH_ANCHORED: The pattern is forced to be \"anchored\", that is,\n     it is constrained to match only at the first matching point in the\n     string that is being searched. This effect can also be achieved by\n     appropriate constructs in the pattern itself such as the \"^\"\n     metacharacter.\n @G_REGEX_MATCH_NOTBOL: Specifies that first character of the string is\n     not the beginning of a line, so the circumflex metacharacter should\n     not match before it. Setting this without %G_REGEX_MULTILINE (at\n     compile time) causes circumflex never to match. This option affects\n     only the behaviour of the circumflex metacharacter, it does not\n     affect \"\\A\".\n @G_REGEX_MATCH_NOTEOL: Specifies that the end of the subject string is\n     not the end of a line, so the dollar metacharacter should not match\n     it nor (except in multiline mode) a newline immediately before it.\n     Setting this without %G_REGEX_MULTILINE (at compile time) causes\n     dollar never to match. This option affects only the behaviour of\n     the dollar metacharacter, it does not affect \"\\Z\" or \"\\z\".\n @G_REGEX_MATCH_NOTEMPTY: An empty string is not considered to be a valid\n     match if this option is set. If there are alternatives in the pattern,\n     they are tried. If all the alternatives match the empty string, the\n     entire match fails. For example, if the pattern \"a?b?\" is applied to\n     a string not beginning with \"a\" or \"b\", it matches the empty string\n     at the start of the string. With this flag set, this match is not\n     valid, so GRegex searches further into the string for occurrences\n     of \"a\" or \"b\".\n @G_REGEX_MATCH_PARTIAL: Turns on the partial matching feature, for more\n     documentation on partial matching see g_match_info_is_partial_match().\n @G_REGEX_MATCH_NEWLINE_CR: Overrides the newline definition set when\n     creating a new #GRegex, setting the '\\r' character as line terminator.\n @G_REGEX_MATCH_NEWLINE_LF: Overrides the newline definition set when\n     creating a new #GRegex, setting the '\\n' character as line terminator.\n @G_REGEX_MATCH_NEWLINE_CRLF: Overrides the newline definition set when\n     creating a new #GRegex, setting the '\\r\\n' characters sequence as line terminator.\n @G_REGEX_MATCH_NEWLINE_ANY: Overrides the newline definition set when\n     creating a new #GRegex, any Unicode newline sequence\n     is recognised as a newline. These are '\\r', '\\n' and '\\rn', and the\n     single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),\n     U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and\n     U+2029 PARAGRAPH SEPARATOR.\n @G_REGEX_MATCH_NEWLINE_ANYCRLF: Overrides the newline definition set when\n     creating a new #GRegex; any '\\r', '\\n', or '\\r\\n' character sequence\n     is recognized as a newline. Since: 2.34\n @G_REGEX_MATCH_BSR_ANYCRLF: Overrides the newline definition for \"\\R\" set when\n     creating a new #GRegex; only '\\r', '\\n', or '\\r\\n' character sequences\n     are recognized as a newline by \"\\R\". Since: 2.34\n @G_REGEX_MATCH_BSR_ANY: Overrides the newline definition for \"\\R\" set when\n     creating a new #GRegex; any Unicode newline character or character sequence\n     are recognized as a newline by \"\\R\". These are '\\r', '\\n' and '\\rn', and the\n     single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),\n     U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and\n     U+2029 PARAGRAPH SEPARATOR. Since: 2.34\n @G_REGEX_MATCH_PARTIAL_SOFT: An alias for %G_REGEX_MATCH_PARTIAL. Since: 2.34\n @G_REGEX_MATCH_PARTIAL_HARD: Turns on the partial matching feature. In contrast to\n     to %G_REGEX_MATCH_PARTIAL_SOFT, this stops matching as soon as a partial match\n     is found, without continuing to search for a possible complete match. See\n     g_match_info_is_partial_match() for more information. Since: 2.34\n @G_REGEX_MATCH_NOTEMPTY_ATSTART: Like %G_REGEX_MATCH_NOTEMPTY, but only applied to\n     the start of the matched string. For anchored\n     patterns this can only happen for pattern containing \"\\K\". Since: 2.34\n\n Flags specifying match-time options.\n\n Since: 2.14"]
pub type GRegexMatchFlags = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRegex {
    _unused: [u8; 0],
}
#[doc = " GRegex:\n\n A GRegex is the \"compiled\" form of a regular expression pattern.\n This structure is opaque and its fields cannot be accessed directly.\n\n Since: 2.14"]
pub type GRegex = _GRegex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMatchInfo {
    _unused: [u8; 0],
}
#[doc = " GMatchInfo:\n\n A GMatchInfo is an opaque struct used to return information about\n matches."]
pub type GMatchInfo = _GMatchInfo;
#[doc = " GRegexEvalCallback:\n @match_info: the #GMatchInfo generated by the match.\n     Use g_match_info_get_regex() and g_match_info_get_string() if you\n     need the #GRegex or the matched string.\n @result: a #GString containing the new string\n @user_data: user data passed to g_regex_replace_eval()\n\n Specifies the type of the function passed to g_regex_replace_eval().\n It is called for each occurrence of the pattern in the string passed\n to g_regex_replace_eval(), and it should append the replacement to\n @result.\n\n Returns: %FALSE to continue the replacement process, %TRUE to stop it\n\n Since: 2.14"]
pub type GRegexEvalCallback = ::std::option::Option<
    unsafe extern "C" fn(
        match_info: *const GMatchInfo,
        result: *mut GString,
        user_data: gpointer,
    ) -> gboolean,
>;
extern "C" {
    pub fn g_regex_new(
        pattern: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut GRegex;
}
extern "C" {
    pub fn g_regex_ref(regex: *mut GRegex) -> *mut GRegex;
}
extern "C" {
    pub fn g_regex_unref(regex: *mut GRegex);
}
extern "C" {
    pub fn g_regex_get_pattern(regex: *const GRegex) -> *const gchar;
}
extern "C" {
    pub fn g_regex_get_max_backref(regex: *const GRegex) -> gint;
}
extern "C" {
    pub fn g_regex_get_capture_count(regex: *const GRegex) -> gint;
}
extern "C" {
    pub fn g_regex_get_has_cr_or_lf(regex: *const GRegex) -> gboolean;
}
extern "C" {
    pub fn g_regex_get_max_lookbehind(regex: *const GRegex) -> gint;
}
extern "C" {
    pub fn g_regex_get_string_number(regex: *const GRegex, name: *const gchar) -> gint;
}
extern "C" {
    pub fn g_regex_escape_string(string: *const gchar, length: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_escape_nul(string: *const gchar, length: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_get_compile_flags(regex: *const GRegex) -> GRegexCompileFlags;
}
extern "C" {
    pub fn g_regex_get_match_flags(regex: *const GRegex) -> GRegexMatchFlags;
}
extern "C" {
    pub fn g_regex_match_simple(
        pattern: *const gchar,
        string: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_match(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_match_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_match_all(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_match_all_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_split_simple(
        pattern: *const gchar,
        string: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_regex_split(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_regex_split_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        max_tokens: gint,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_regex_replace(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        replacement: *const gchar,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_replace_literal(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        replacement: *const gchar,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_replace_eval(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        eval: GRegexEvalCallback,
        user_data: gpointer,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_check_replacement(
        replacement: *const gchar,
        has_references: *mut gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_match_info_get_regex(match_info: *const GMatchInfo) -> *mut GRegex;
}
extern "C" {
    pub fn g_match_info_get_string(match_info: *const GMatchInfo) -> *const gchar;
}
extern "C" {
    pub fn g_match_info_ref(match_info: *mut GMatchInfo) -> *mut GMatchInfo;
}
extern "C" {
    pub fn g_match_info_unref(match_info: *mut GMatchInfo);
}
extern "C" {
    pub fn g_match_info_free(match_info: *mut GMatchInfo);
}
extern "C" {
    pub fn g_match_info_next(match_info: *mut GMatchInfo, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_match_info_matches(match_info: *const GMatchInfo) -> gboolean;
}
extern "C" {
    pub fn g_match_info_get_match_count(match_info: *const GMatchInfo) -> gint;
}
extern "C" {
    pub fn g_match_info_is_partial_match(match_info: *const GMatchInfo) -> gboolean;
}
extern "C" {
    pub fn g_match_info_expand_references(
        match_info: *const GMatchInfo,
        string_to_expand: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_match_info_fetch(match_info: *const GMatchInfo, match_num: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_match_info_fetch_pos(
        match_info: *const GMatchInfo,
        match_num: gint,
        start_pos: *mut gint,
        end_pos: *mut gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_match_info_fetch_named(
        match_info: *const GMatchInfo,
        name: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_match_info_fetch_named_pos(
        match_info: *const GMatchInfo,
        name: *const gchar,
        start_pos: *mut gint,
        end_pos: *mut gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_match_info_fetch_all(match_info: *const GMatchInfo) -> *mut *mut gchar;
}
pub type GScanner = _GScanner;
pub type GScannerConfig = _GScannerConfig;
pub type GTokenValue = _GTokenValue;
pub type GScannerMsgFunc = ::std::option::Option<
    unsafe extern "C" fn(scanner: *mut GScanner, message: *mut gchar, error: gboolean),
>;
pub const GErrorType_G_ERR_UNKNOWN: GErrorType = 0;
pub const GErrorType_G_ERR_UNEXP_EOF: GErrorType = 1;
pub const GErrorType_G_ERR_UNEXP_EOF_IN_STRING: GErrorType = 2;
pub const GErrorType_G_ERR_UNEXP_EOF_IN_COMMENT: GErrorType = 3;
pub const GErrorType_G_ERR_NON_DIGIT_IN_CONST: GErrorType = 4;
pub const GErrorType_G_ERR_DIGIT_RADIX: GErrorType = 5;
pub const GErrorType_G_ERR_FLOAT_RADIX: GErrorType = 6;
pub const GErrorType_G_ERR_FLOAT_MALFORMED: GErrorType = 7;
pub type GErrorType = ::std::os::raw::c_int;
pub const GTokenType_G_TOKEN_EOF: GTokenType = 0;
pub const GTokenType_G_TOKEN_LEFT_PAREN: GTokenType = 40;
pub const GTokenType_G_TOKEN_RIGHT_PAREN: GTokenType = 41;
pub const GTokenType_G_TOKEN_LEFT_CURLY: GTokenType = 123;
pub const GTokenType_G_TOKEN_RIGHT_CURLY: GTokenType = 125;
pub const GTokenType_G_TOKEN_LEFT_BRACE: GTokenType = 91;
pub const GTokenType_G_TOKEN_RIGHT_BRACE: GTokenType = 93;
pub const GTokenType_G_TOKEN_EQUAL_SIGN: GTokenType = 61;
pub const GTokenType_G_TOKEN_COMMA: GTokenType = 44;
pub const GTokenType_G_TOKEN_NONE: GTokenType = 256;
pub const GTokenType_G_TOKEN_ERROR: GTokenType = 257;
pub const GTokenType_G_TOKEN_CHAR: GTokenType = 258;
pub const GTokenType_G_TOKEN_BINARY: GTokenType = 259;
pub const GTokenType_G_TOKEN_OCTAL: GTokenType = 260;
pub const GTokenType_G_TOKEN_INT: GTokenType = 261;
pub const GTokenType_G_TOKEN_HEX: GTokenType = 262;
pub const GTokenType_G_TOKEN_FLOAT: GTokenType = 263;
pub const GTokenType_G_TOKEN_STRING: GTokenType = 264;
pub const GTokenType_G_TOKEN_SYMBOL: GTokenType = 265;
pub const GTokenType_G_TOKEN_IDENTIFIER: GTokenType = 266;
pub const GTokenType_G_TOKEN_IDENTIFIER_NULL: GTokenType = 267;
pub const GTokenType_G_TOKEN_COMMENT_SINGLE: GTokenType = 268;
pub const GTokenType_G_TOKEN_COMMENT_MULTI: GTokenType = 269;
pub const GTokenType_G_TOKEN_LAST: GTokenType = 270;
pub type GTokenType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GTokenValue {
    pub v_symbol: gpointer,
    pub v_identifier: *mut gchar,
    pub v_binary: gulong,
    pub v_octal: gulong,
    pub v_int: gulong,
    pub v_int64: guint64,
    pub v_float: gdouble,
    pub v_hex: gulong,
    pub v_string: *mut gchar,
    pub v_comment: *mut gchar,
    pub v_char: guchar,
    pub v_error: guint,
}
#[test]
fn bindgen_test_layout__GTokenValue() {
    const UNINIT: ::std::mem::MaybeUninit<_GTokenValue> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTokenValue>(),
        8usize,
        concat!("Size of: ", stringify!(_GTokenValue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTokenValue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTokenValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_symbol) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_symbol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_binary) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_binary)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_octal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_octal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_int64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_int64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_float) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_hex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_hex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_comment) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_comment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_char) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_char)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_error) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_error)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GScannerConfig {
    pub cset_skip_characters: *mut gchar,
    pub cset_identifier_first: *mut gchar,
    pub cset_identifier_nth: *mut gchar,
    pub cpair_comment_single: *mut gchar,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub padding_dummy: guint,
}
#[test]
fn bindgen_test_layout__GScannerConfig() {
    const UNINIT: ::std::mem::MaybeUninit<_GScannerConfig> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GScannerConfig>(),
        40usize,
        concat!("Size of: ", stringify!(_GScannerConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<_GScannerConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(_GScannerConfig))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cset_skip_characters) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cset_skip_characters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cset_identifier_first) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cset_identifier_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cset_identifier_nth) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cset_identifier_nth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpair_comment_single) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cpair_comment_single)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding_dummy) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(padding_dummy)
        )
    );
}
impl _GScannerConfig {
    #[inline]
    pub fn case_sensitive(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_case_sensitive(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_comment_multi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_comment_multi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_comment_single(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_comment_single(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_comment_multi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_comment_multi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier_1char(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier_1char(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier_NULL(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier_NULL(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_symbols(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_symbols(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_binary(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_binary(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_octal(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_octal(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_float(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_float(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_hex(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_hex(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_hex_dollar(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_hex_dollar(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_string_sq(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_string_sq(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_string_dq(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_string_dq(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn numbers_2_int(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_numbers_2_int(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int_2_float(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_int_2_float(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn identifier_2_string(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_identifier_2_string(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn char_2_token(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_char_2_token(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn symbol_2_token(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_symbol_2_token(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scope_0_fallback(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scope_0_fallback(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn store_int64(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_store_int64(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        case_sensitive: guint,
        skip_comment_multi: guint,
        skip_comment_single: guint,
        scan_comment_multi: guint,
        scan_identifier: guint,
        scan_identifier_1char: guint,
        scan_identifier_NULL: guint,
        scan_symbols: guint,
        scan_binary: guint,
        scan_octal: guint,
        scan_float: guint,
        scan_hex: guint,
        scan_hex_dollar: guint,
        scan_string_sq: guint,
        scan_string_dq: guint,
        numbers_2_int: guint,
        int_2_float: guint,
        identifier_2_string: guint,
        char_2_token: guint,
        symbol_2_token: guint,
        scope_0_fallback: guint,
        store_int64: guint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let case_sensitive: u32 = unsafe { ::std::mem::transmute(case_sensitive) };
            case_sensitive as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let skip_comment_multi: u32 = unsafe { ::std::mem::transmute(skip_comment_multi) };
            skip_comment_multi as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let skip_comment_single: u32 = unsafe { ::std::mem::transmute(skip_comment_single) };
            skip_comment_single as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let scan_comment_multi: u32 = unsafe { ::std::mem::transmute(scan_comment_multi) };
            scan_comment_multi as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let scan_identifier: u32 = unsafe { ::std::mem::transmute(scan_identifier) };
            scan_identifier as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let scan_identifier_1char: u32 =
                unsafe { ::std::mem::transmute(scan_identifier_1char) };
            scan_identifier_1char as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let scan_identifier_NULL: u32 = unsafe { ::std::mem::transmute(scan_identifier_NULL) };
            scan_identifier_NULL as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let scan_symbols: u32 = unsafe { ::std::mem::transmute(scan_symbols) };
            scan_symbols as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let scan_binary: u32 = unsafe { ::std::mem::transmute(scan_binary) };
            scan_binary as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let scan_octal: u32 = unsafe { ::std::mem::transmute(scan_octal) };
            scan_octal as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let scan_float: u32 = unsafe { ::std::mem::transmute(scan_float) };
            scan_float as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let scan_hex: u32 = unsafe { ::std::mem::transmute(scan_hex) };
            scan_hex as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let scan_hex_dollar: u32 = unsafe { ::std::mem::transmute(scan_hex_dollar) };
            scan_hex_dollar as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let scan_string_sq: u32 = unsafe { ::std::mem::transmute(scan_string_sq) };
            scan_string_sq as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let scan_string_dq: u32 = unsafe { ::std::mem::transmute(scan_string_dq) };
            scan_string_dq as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let numbers_2_int: u32 = unsafe { ::std::mem::transmute(numbers_2_int) };
            numbers_2_int as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let int_2_float: u32 = unsafe { ::std::mem::transmute(int_2_float) };
            int_2_float as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let identifier_2_string: u32 = unsafe { ::std::mem::transmute(identifier_2_string) };
            identifier_2_string as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let char_2_token: u32 = unsafe { ::std::mem::transmute(char_2_token) };
            char_2_token as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let symbol_2_token: u32 = unsafe { ::std::mem::transmute(symbol_2_token) };
            symbol_2_token as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let scope_0_fallback: u32 = unsafe { ::std::mem::transmute(scope_0_fallback) };
            scope_0_fallback as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let store_int64: u32 = unsafe { ::std::mem::transmute(store_int64) };
            store_int64 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GScanner {
    pub user_data: gpointer,
    pub max_parse_errors: guint,
    pub parse_errors: guint,
    pub input_name: *const gchar,
    pub qdata: *mut GData,
    pub config: *mut GScannerConfig,
    pub token: GTokenType,
    pub value: GTokenValue,
    pub line: guint,
    pub position: guint,
    pub next_token: GTokenType,
    pub next_value: GTokenValue,
    pub next_line: guint,
    pub next_position: guint,
    pub symbol_table: *mut GHashTable,
    pub input_fd: gint,
    pub text: *const gchar,
    pub text_end: *const gchar,
    pub buffer: *mut gchar,
    pub scope_id: guint,
    pub msg_handler: GScannerMsgFunc,
}
#[test]
fn bindgen_test_layout__GScanner() {
    const UNINIT: ::std::mem::MaybeUninit<_GScanner> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GScanner>(),
        144usize,
        concat!("Size of: ", stringify!(_GScanner))
    );
    assert_eq!(
        ::std::mem::align_of::<_GScanner>(),
        8usize,
        concat!("Alignment of ", stringify!(_GScanner))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_parse_errors) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(max_parse_errors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parse_errors) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(parse_errors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(input_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qdata) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(qdata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).config) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_token) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_token)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_value) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_line) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_position) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).symbol_table) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(symbol_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_fd) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(input_fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text_end) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(text_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scope_id) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(scope_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_handler) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(msg_handler)
        )
    );
}
extern "C" {
    pub fn g_scanner_new(config_templ: *const GScannerConfig) -> *mut GScanner;
}
extern "C" {
    pub fn g_scanner_destroy(scanner: *mut GScanner);
}
extern "C" {
    pub fn g_scanner_input_file(scanner: *mut GScanner, input_fd: gint);
}
extern "C" {
    pub fn g_scanner_sync_file_offset(scanner: *mut GScanner);
}
extern "C" {
    pub fn g_scanner_input_text(scanner: *mut GScanner, text: *const gchar, text_len: guint);
}
extern "C" {
    pub fn g_scanner_get_next_token(scanner: *mut GScanner) -> GTokenType;
}
extern "C" {
    pub fn g_scanner_peek_next_token(scanner: *mut GScanner) -> GTokenType;
}
extern "C" {
    pub fn g_scanner_cur_token(scanner: *mut GScanner) -> GTokenType;
}
extern "C" {
    pub fn g_scanner_cur_value(scanner: *mut GScanner) -> GTokenValue;
}
extern "C" {
    pub fn g_scanner_cur_line(scanner: *mut GScanner) -> guint;
}
extern "C" {
    pub fn g_scanner_cur_position(scanner: *mut GScanner) -> guint;
}
extern "C" {
    pub fn g_scanner_eof(scanner: *mut GScanner) -> gboolean;
}
extern "C" {
    pub fn g_scanner_set_scope(scanner: *mut GScanner, scope_id: guint) -> guint;
}
extern "C" {
    pub fn g_scanner_scope_add_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
        value: gpointer,
    );
}
extern "C" {
    pub fn g_scanner_scope_remove_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
    );
}
extern "C" {
    pub fn g_scanner_scope_lookup_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
    ) -> gpointer;
}
extern "C" {
    pub fn g_scanner_scope_foreach_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        func: GHFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_scanner_lookup_symbol(scanner: *mut GScanner, symbol: *const gchar) -> gpointer;
}
extern "C" {
    pub fn g_scanner_unexp_token(
        scanner: *mut GScanner,
        expected_token: GTokenType,
        identifier_spec: *const gchar,
        symbol_spec: *const gchar,
        symbol_name: *const gchar,
        message: *const gchar,
        is_error: gint,
    );
}
extern "C" {
    pub fn g_scanner_error(scanner: *mut GScanner, format: *const gchar, ...);
}
extern "C" {
    pub fn g_scanner_warn(scanner: *mut GScanner, format: *const gchar, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSequence {
    _unused: [u8; 0],
}
pub type GSequence = _GSequence;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSequenceNode {
    _unused: [u8; 0],
}
pub type GSequenceIter = _GSequenceNode;
pub type GSequenceIterCompareFunc = ::std::option::Option<
    unsafe extern "C" fn(a: *mut GSequenceIter, b: *mut GSequenceIter, data: gpointer) -> gint,
>;
extern "C" {
    pub fn g_sequence_new(data_destroy: GDestroyNotify) -> *mut GSequence;
}
extern "C" {
    pub fn g_sequence_free(seq: *mut GSequence);
}
extern "C" {
    pub fn g_sequence_get_length(seq: *mut GSequence) -> gint;
}
extern "C" {
    pub fn g_sequence_foreach(seq: *mut GSequence, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_sequence_foreach_range(
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
        func: GFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_sequence_sort(seq: *mut GSequence, cmp_func: GCompareDataFunc, cmp_data: gpointer);
}
extern "C" {
    pub fn g_sequence_sort_iter(
        seq: *mut GSequence,
        cmp_func: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    );
}
extern "C" {
    pub fn g_sequence_is_empty(seq: *mut GSequence) -> gboolean;
}
extern "C" {
    pub fn g_sequence_get_begin_iter(seq: *mut GSequence) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_get_end_iter(seq: *mut GSequence) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_get_iter_at_pos(seq: *mut GSequence, pos: gint) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_append(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_prepend(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_insert_before(iter: *mut GSequenceIter, data: gpointer)
        -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_move(src: *mut GSequenceIter, dest: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_swap(a: *mut GSequenceIter, b: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_insert_sorted(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_insert_sorted_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_sort_changed(
        iter: *mut GSequenceIter,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    );
}
extern "C" {
    pub fn g_sequence_sort_changed_iter(
        iter: *mut GSequenceIter,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    );
}
extern "C" {
    pub fn g_sequence_remove(iter: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_remove_range(begin: *mut GSequenceIter, end: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_move_range(
        dest: *mut GSequenceIter,
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
    );
}
extern "C" {
    pub fn g_sequence_search(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_search_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_lookup(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_lookup_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_get(iter: *mut GSequenceIter) -> gpointer;
}
extern "C" {
    pub fn g_sequence_set(iter: *mut GSequenceIter, data: gpointer);
}
extern "C" {
    pub fn g_sequence_iter_is_begin(iter: *mut GSequenceIter) -> gboolean;
}
extern "C" {
    pub fn g_sequence_iter_is_end(iter: *mut GSequenceIter) -> gboolean;
}
extern "C" {
    pub fn g_sequence_iter_next(iter: *mut GSequenceIter) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_iter_prev(iter: *mut GSequenceIter) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_iter_get_position(iter: *mut GSequenceIter) -> gint;
}
extern "C" {
    pub fn g_sequence_iter_move(iter: *mut GSequenceIter, delta: gint) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_iter_get_sequence(iter: *mut GSequenceIter) -> *mut GSequence;
}
extern "C" {
    pub fn g_sequence_iter_compare(a: *mut GSequenceIter, b: *mut GSequenceIter) -> gint;
}
extern "C" {
    pub fn g_sequence_range_get_midpoint(
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
    ) -> *mut GSequenceIter;
}
pub const GShellError_G_SHELL_ERROR_BAD_QUOTING: GShellError = 0;
pub const GShellError_G_SHELL_ERROR_EMPTY_STRING: GShellError = 1;
pub const GShellError_G_SHELL_ERROR_FAILED: GShellError = 2;
pub type GShellError = ::std::os::raw::c_int;
extern "C" {
    pub fn g_shell_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_shell_quote(unquoted_string: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_shell_unquote(quoted_string: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    pub fn g_shell_parse_argv(
        command_line: *const gchar,
        argcp: *mut gint,
        argvp: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_slice_alloc(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_slice_alloc0(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_slice_copy(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_slice_free1(block_size: gsize, mem_block: gpointer);
}
extern "C" {
    pub fn g_slice_free_chain_with_offset(
        block_size: gsize,
        mem_chain: gpointer,
        next_offset: gsize,
    );
}
pub const GSliceConfig_G_SLICE_CONFIG_ALWAYS_MALLOC: GSliceConfig = 1;
pub const GSliceConfig_G_SLICE_CONFIG_BYPASS_MAGAZINES: GSliceConfig = 2;
pub const GSliceConfig_G_SLICE_CONFIG_WORKING_SET_MSECS: GSliceConfig = 3;
pub const GSliceConfig_G_SLICE_CONFIG_COLOR_INCREMENT: GSliceConfig = 4;
pub const GSliceConfig_G_SLICE_CONFIG_CHUNK_SIZES: GSliceConfig = 5;
pub const GSliceConfig_G_SLICE_CONFIG_CONTENTION_COUNTER: GSliceConfig = 6;
pub type GSliceConfig = ::std::os::raw::c_int;
extern "C" {
    pub fn g_slice_set_config(ckey: GSliceConfig, value: gint64);
}
extern "C" {
    pub fn g_slice_get_config(ckey: GSliceConfig) -> gint64;
}
extern "C" {
    pub fn g_slice_get_config_state(
        ckey: GSliceConfig,
        address: gint64,
        n_values: *mut guint,
    ) -> *mut gint64;
}
pub const GSpawnError_G_SPAWN_ERROR_FORK: GSpawnError = 0;
pub const GSpawnError_G_SPAWN_ERROR_READ: GSpawnError = 1;
pub const GSpawnError_G_SPAWN_ERROR_CHDIR: GSpawnError = 2;
pub const GSpawnError_G_SPAWN_ERROR_ACCES: GSpawnError = 3;
pub const GSpawnError_G_SPAWN_ERROR_PERM: GSpawnError = 4;
pub const GSpawnError_G_SPAWN_ERROR_TOO_BIG: GSpawnError = 5;
pub const GSpawnError_G_SPAWN_ERROR_2BIG: GSpawnError = 5;
pub const GSpawnError_G_SPAWN_ERROR_NOEXEC: GSpawnError = 6;
pub const GSpawnError_G_SPAWN_ERROR_NAMETOOLONG: GSpawnError = 7;
pub const GSpawnError_G_SPAWN_ERROR_NOENT: GSpawnError = 8;
pub const GSpawnError_G_SPAWN_ERROR_NOMEM: GSpawnError = 9;
pub const GSpawnError_G_SPAWN_ERROR_NOTDIR: GSpawnError = 10;
pub const GSpawnError_G_SPAWN_ERROR_LOOP: GSpawnError = 11;
pub const GSpawnError_G_SPAWN_ERROR_TXTBUSY: GSpawnError = 12;
pub const GSpawnError_G_SPAWN_ERROR_IO: GSpawnError = 13;
pub const GSpawnError_G_SPAWN_ERROR_NFILE: GSpawnError = 14;
pub const GSpawnError_G_SPAWN_ERROR_MFILE: GSpawnError = 15;
pub const GSpawnError_G_SPAWN_ERROR_INVAL: GSpawnError = 16;
pub const GSpawnError_G_SPAWN_ERROR_ISDIR: GSpawnError = 17;
pub const GSpawnError_G_SPAWN_ERROR_LIBBAD: GSpawnError = 18;
pub const GSpawnError_G_SPAWN_ERROR_FAILED: GSpawnError = 19;
#[doc = " GSpawnError:\n @G_SPAWN_ERROR_FORK: Fork failed due to lack of memory.\n @G_SPAWN_ERROR_READ: Read or select on pipes failed.\n @G_SPAWN_ERROR_CHDIR: Changing to working directory failed.\n @G_SPAWN_ERROR_ACCES: execv() returned `EACCES`\n @G_SPAWN_ERROR_PERM: execv() returned `EPERM`\n @G_SPAWN_ERROR_TOO_BIG: execv() returned `E2BIG`\n @G_SPAWN_ERROR_2BIG: deprecated alias for %G_SPAWN_ERROR_TOO_BIG (deprecated since GLib 2.32)\n @G_SPAWN_ERROR_NOEXEC: execv() returned `ENOEXEC`\n @G_SPAWN_ERROR_NAMETOOLONG: execv() returned `ENAMETOOLONG`\n @G_SPAWN_ERROR_NOENT: execv() returned `ENOENT`\n @G_SPAWN_ERROR_NOMEM: execv() returned `ENOMEM`\n @G_SPAWN_ERROR_NOTDIR: execv() returned `ENOTDIR`\n @G_SPAWN_ERROR_LOOP: execv() returned `ELOOP`\n @G_SPAWN_ERROR_TXTBUSY: execv() returned `ETXTBUSY`\n @G_SPAWN_ERROR_IO: execv() returned `EIO`\n @G_SPAWN_ERROR_NFILE: execv() returned `ENFILE`\n @G_SPAWN_ERROR_MFILE: execv() returned `EMFILE`\n @G_SPAWN_ERROR_INVAL: execv() returned `EINVAL`\n @G_SPAWN_ERROR_ISDIR: execv() returned `EISDIR`\n @G_SPAWN_ERROR_LIBBAD: execv() returned `ELIBBAD`\n @G_SPAWN_ERROR_FAILED: Some other fatal failure,\n   `error->message` should explain.\n\n Error codes returned by spawning processes."]
pub type GSpawnError = ::std::os::raw::c_int;
#[doc = " GSpawnChildSetupFunc:\n @data: user data passed to the function.\n\n Specifies the type of the setup function passed to g_spawn_async(),\n g_spawn_sync() and g_spawn_async_with_pipes(), which can, in very\n limited ways, be used to affect the child's execution.\n\n On POSIX platforms, the function is called in the child after GLib\n has performed all the setup it plans to perform, but before calling\n exec(). Actions taken in this function will only affect the child,\n not the parent.\n\n On Windows, the function is called in the parent. Its usefulness on\n Windows is thus questionable. In many cases executing the child setup\n function in the parent can have ill effects, and you should be very\n careful when porting software to Windows that uses child setup\n functions.\n\n However, even on POSIX, you are extremely limited in what you can\n safely do from a #GSpawnChildSetupFunc, because any mutexes that were\n held by other threads in the parent process at the time of the fork()\n will still be locked in the child process, and they will never be\n unlocked (since the threads that held them don't exist in the child).\n POSIX allows only async-signal-safe functions (see signal(7)) to be\n called in the child between fork() and exec(), which drastically limits\n the usefulness of child setup functions.\n\n In particular, it is not safe to call any function which may\n call malloc(), which includes POSIX functions such as setenv().\n If you need to set up the child environment differently from\n the parent, you should use g_get_environ(), g_environ_setenv(),\n and g_environ_unsetenv(), and then pass the complete environment\n list to the `g_spawn...` function."]
pub type GSpawnChildSetupFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub const GSpawnFlags_G_SPAWN_DEFAULT: GSpawnFlags = 0;
pub const GSpawnFlags_G_SPAWN_LEAVE_DESCRIPTORS_OPEN: GSpawnFlags = 1;
pub const GSpawnFlags_G_SPAWN_DO_NOT_REAP_CHILD: GSpawnFlags = 2;
pub const GSpawnFlags_G_SPAWN_SEARCH_PATH: GSpawnFlags = 4;
pub const GSpawnFlags_G_SPAWN_STDOUT_TO_DEV_NULL: GSpawnFlags = 8;
pub const GSpawnFlags_G_SPAWN_STDERR_TO_DEV_NULL: GSpawnFlags = 16;
pub const GSpawnFlags_G_SPAWN_CHILD_INHERITS_STDIN: GSpawnFlags = 32;
pub const GSpawnFlags_G_SPAWN_FILE_AND_ARGV_ZERO: GSpawnFlags = 64;
pub const GSpawnFlags_G_SPAWN_SEARCH_PATH_FROM_ENVP: GSpawnFlags = 128;
pub const GSpawnFlags_G_SPAWN_CLOEXEC_PIPES: GSpawnFlags = 256;
#[doc = " G_SPAWN_CHILD_INHERITS_STDOUT:\n\n The child will inherit the parent's standard output.\n\n Since: 2.74"]
pub const GSpawnFlags_G_SPAWN_CHILD_INHERITS_STDOUT: GSpawnFlags = 512;
#[doc = " G_SPAWN_CHILD_INHERITS_STDERR:\n\n The child will inherit the parent's standard error.\n\n Since: 2.74"]
pub const GSpawnFlags_G_SPAWN_CHILD_INHERITS_STDERR: GSpawnFlags = 1024;
#[doc = " G_SPAWN_STDIN_FROM_DEV_NULL:\n\n The child's standard input is attached to `/dev/null`.\n\n Since: 2.74"]
pub const GSpawnFlags_G_SPAWN_STDIN_FROM_DEV_NULL: GSpawnFlags = 2048;
#[doc = " GSpawnFlags:\n @G_SPAWN_DEFAULT: no flags, default behaviour\n @G_SPAWN_LEAVE_DESCRIPTORS_OPEN: the parent's open file descriptors will\n     be inherited by the child; otherwise all descriptors except stdin,\n     stdout and stderr will be closed before calling exec() in the child.\n @G_SPAWN_DO_NOT_REAP_CHILD: the child will not be automatically reaped;\n     you must use g_child_watch_add() yourself (or call waitpid() or handle\n     `SIGCHLD` yourself), or the child will become a zombie.\n @G_SPAWN_SEARCH_PATH: `argv[0]` need not be an absolute path, it will be\n     looked for in the user's `PATH`.\n @G_SPAWN_STDOUT_TO_DEV_NULL: the child's standard output will be discarded,\n     instead of going to the same location as the parent's standard output.\n @G_SPAWN_STDERR_TO_DEV_NULL: the child's standard error will be discarded.\n @G_SPAWN_CHILD_INHERITS_STDIN: the child will inherit the parent's standard\n     input (by default, the child's standard input is attached to `/dev/null`).\n @G_SPAWN_FILE_AND_ARGV_ZERO: the first element of `argv` is the file to\n     execute, while the remaining elements are the actual argument vector\n     to pass to the file. Normally g_spawn_async_with_pipes() uses `argv[0]`\n     as the file to execute, and passes all of `argv` to the child.\n @G_SPAWN_SEARCH_PATH_FROM_ENVP: if `argv[0]` is not an absolute path,\n     it will be looked for in the `PATH` from the passed child environment.\n     Since: 2.34\n @G_SPAWN_CLOEXEC_PIPES: create all pipes with the `O_CLOEXEC` flag set.\n     Since: 2.40\n @G_SPAWN_CHILD_INHERITS_STDOUT: the child will inherit the parent's standard output.\n     Since: 2.74\n @G_SPAWN_CHILD_INHERITS_STDERR: the child will inherit the parent's standard error.\n     Since: 2.74\n @G_SPAWN_STDIN_FROM_DEV_NULL: the child's standard input is attached to `/dev/null`.\n     Since: 2.74\n\n Flags passed to g_spawn_sync(), g_spawn_async() and g_spawn_async_with_pipes()."]
pub type GSpawnFlags = ::std::os::raw::c_int;
extern "C" {
    pub fn g_spawn_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_spawn_exit_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_spawn_async(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_async_with_pipes(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        standard_input: *mut gint,
        standard_output: *mut gint,
        standard_error: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_async_with_pipes_and_fds(
        working_directory: *const gchar,
        argv: *const *const gchar,
        envp: *const *const gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        stdin_fd: gint,
        stdout_fd: gint,
        stderr_fd: gint,
        source_fds: *const gint,
        target_fds: *const gint,
        n_fds: gsize,
        child_pid_out: *mut GPid,
        stdin_pipe_out: *mut gint,
        stdout_pipe_out: *mut gint,
        stderr_pipe_out: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_async_with_fds(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        stdin_fd: gint,
        stdout_fd: gint,
        stderr_fd: gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_sync(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        standard_output: *mut *mut gchar,
        standard_error: *mut *mut gchar,
        wait_status: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_command_line_sync(
        command_line: *const gchar,
        standard_output: *mut *mut gchar,
        standard_error: *mut *mut gchar,
        wait_status: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_command_line_async(
        command_line: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_check_wait_status(wait_status: gint, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_spawn_check_exit_status(wait_status: gint, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_spawn_close_pid(pid: GPid);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStringChunk {
    _unused: [u8; 0],
}
pub type GStringChunk = _GStringChunk;
extern "C" {
    pub fn g_string_chunk_new(size: gsize) -> *mut GStringChunk;
}
extern "C" {
    pub fn g_string_chunk_free(chunk: *mut GStringChunk);
}
extern "C" {
    pub fn g_string_chunk_clear(chunk: *mut GStringChunk);
}
extern "C" {
    pub fn g_string_chunk_insert(chunk: *mut GStringChunk, string: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_string_chunk_insert_len(
        chunk: *mut GStringChunk,
        string: *const gchar,
        len: gssize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_string_chunk_insert_const(
        chunk: *mut GStringChunk,
        string: *const gchar,
    ) -> *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStrvBuilder {
    _unused: [u8; 0],
}
#[doc = " GStrvBuilder:\n\n A helper object to build a %NULL-terminated string array\n by appending. See g_strv_builder_new().\n\n Since: 2.68"]
pub type GStrvBuilder = _GStrvBuilder;
extern "C" {
    pub fn g_strv_builder_new() -> *mut GStrvBuilder;
}
extern "C" {
    pub fn g_strv_builder_unref(builder: *mut GStrvBuilder);
}
extern "C" {
    pub fn g_strv_builder_ref(builder: *mut GStrvBuilder) -> *mut GStrvBuilder;
}
extern "C" {
    pub fn g_strv_builder_add(builder: *mut GStrvBuilder, value: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_strv_builder_addv(
        builder: *mut GStrvBuilder,
        value: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_strv_builder_add_many(builder: *mut GStrvBuilder, ...);
}
extern "C" {
    pub fn g_strv_builder_end(builder: *mut GStrvBuilder) -> GStrv;
}
pub type _CoreCrtSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type _CoreCrtNonSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort_s(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn bsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    );
}
extern "C" {
    pub fn _lfind_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _itow_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itow(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ltow_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltow(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ultow_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultow(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcstod(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstod_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstol(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wcstol_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoll(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoll_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoul(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _wcstoul_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcstoull(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoull_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcstold(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstold_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstof(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn _wcstof_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn _wtof(_String: *const wchar_t) -> f64;
}
extern "C" {
    pub fn _wtof_l(_String: *const wchar_t, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _wtoi(_String: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtoi_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtol(_String: *const wchar_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtol_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtoll(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoll_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _i64tow_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64tow(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ui64tow_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64tow(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wtoi64(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoi64_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoui64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoui64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wfullpath(
        _Buffer: *mut wchar_t,
        _Path: *const wchar_t,
        _BufferCount: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wmakepath_s(
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wmakepath(
        _Buffer: *mut wchar_t,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    );
}
extern "C" {
    pub fn _wperror(_ErrorMessage: *const wchar_t);
}
extern "C" {
    pub fn _wsplitpath(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _Dir: *mut wchar_t,
        _Filename: *mut wchar_t,
        _Ext: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsplitpath_s(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _DriveCount: usize,
        _Dir: *mut wchar_t,
        _DirCount: usize,
        _Filename: *mut wchar_t,
        _FilenameCount: usize,
        _Ext: *mut wchar_t,
        _ExtCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wdupenv_s(
        _Buffer: *mut *mut wchar_t,
        _BufferCount: *mut usize,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wgetenv(_VarName: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wgetenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wputenv(_EnvString: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wputenv_s(_Name: *const wchar_t, _Value: *const wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv_s(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _ResultPath: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsystem(_Command: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn _set_abort_behavior(
        _Flags: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
pub type _onexit_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
extern "C" {
    pub fn _onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub type _purecall_handler = ::std::option::Option<unsafe extern "C" fn()>;
pub type _invalid_parameter_handler = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const wchar_t,
        arg2: *const wchar_t,
        arg3: *const wchar_t,
        arg4: ::std::os::raw::c_uint,
        arg5: usize,
    ),
>;
extern "C" {
    pub fn _set_purecall_handler(_Handler: _purecall_handler) -> _purecall_handler;
}
extern "C" {
    pub fn _get_purecall_handler() -> _purecall_handler;
}
extern "C" {
    pub fn _set_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_thread_local_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_thread_local_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_error_mode(_Mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sys_errlist() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __sys_nerr() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(_ErrMsg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn __p__pgmptr() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wpgmptr() -> *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__fmode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_pgmptr(_Value: *mut *mut ::std::os::raw::c_char) -> errno_t;
}
extern "C" {
    pub fn _get_wpgmptr(_Value: *mut *mut wchar_t) -> errno_t;
}
extern "C" {
    pub fn _set_fmode(_Mode: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_fmode(_PMode: *mut ::std::os::raw::c_int) -> errno_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__div_t() {
    const UNINIT: ::std::mem::MaybeUninit<_div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_div_t>(),
        8usize,
        concat!("Size of: ", stringify!(_div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_div_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type div_t = _div_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ldiv_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type ldiv_t = _ldiv_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout__lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<_lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(_lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type lldiv_t = _lldiv_t;
extern "C" {
    pub fn abs(_Number: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(_Number: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _abs64(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _byteswap_ushort(_Number: ::std::os::raw::c_ushort) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _byteswap_ulong(_Number: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _byteswap_uint64(_Number: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn div(_Numerator: ::std::os::raw::c_int, _Denominator: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(_Numerator: ::std::os::raw::c_long, _Denominator: ::std::os::raw::c_long)
        -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        _Numerator: ::std::os::raw::c_longlong,
        _Denominator: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn _rotl(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotl(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotl64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _rotr(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotr(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotr64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn srand(_Seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDOUBLE {
    pub ld: [::std::os::raw::c_uchar; 10usize],
}
#[test]
fn bindgen_test_layout__LDOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_LDOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDOUBLE>(),
        10usize,
        concat!("Size of: ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDOUBLE>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ld) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDOUBLE),
            "::",
            stringify!(ld)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_DOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__CRT_DOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_CRT_DOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CRT_DOUBLE),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_FLOAT {
    pub f: f32,
}
#[test]
fn bindgen_test_layout__CRT_FLOAT() {
    const UNINIT: ::std::mem::MaybeUninit<_CRT_FLOAT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Size of: ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Alignment of ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CRT_FLOAT),
            "::",
            stringify!(f)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LONGDOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__LONGDOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_LONGDOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LONGDOUBLE),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDBL12 {
    pub ld12: [::std::os::raw::c_uchar; 12usize],
}
#[test]
fn bindgen_test_layout__LDBL12() {
    const UNINIT: ::std::mem::MaybeUninit<_LDBL12> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDBL12>(),
        12usize,
        concat!("Size of: ", stringify!(_LDBL12))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDBL12>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDBL12))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ld12) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDBL12),
            "::",
            stringify!(ld12)
        )
    );
}
extern "C" {
    pub fn atof(_String: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atof_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _atoi_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atol_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _atoll_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoflt(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoflt_l(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl_l(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl_l(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtof(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn _strtof_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn strtod(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtod_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtold(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtold_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtol(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _strtol_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoll(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoll_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _strtoul_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoi64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoi64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoui64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoui64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _itoa_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ltoa_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ultoa_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _i64toa_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64toa(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ui64toa_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64toa(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ecvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _gcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ___mb_cur_max_func() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ___mb_cur_max_l_func(_Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(_Ch: *const ::std::os::raw::c_char, _MaxCount: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mblen_l(
        _Ch: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbstrlen(_String: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn _mbstrlen_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn _mbstrnlen(_String: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _mbstrnlen_l(
        _String: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn mbtowc(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbtowc_l(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs_s(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn mbstowcs(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _mbstowcs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _mbstowcs_l(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wctomb(_MbCh: *mut ::std::os::raw::c_char, _WCh: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wctomb_l(
        _MbCh: *mut ::std::os::raw::c_char,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb_s(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _WCh: wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wctomb_s_l(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs_s(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _wcstombs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcstombs_l(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn _fullpath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Path: *const ::std::os::raw::c_char,
        _BufferCount: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _makepath_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _makepath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _Dir: *mut ::std::os::raw::c_char,
        _Filename: *mut ::std::os::raw::c_char,
        _Ext: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath_s(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _DriveCount: usize,
        _Dir: *mut ::std::os::raw::c_char,
        _DirCount: usize,
        _Filename: *mut ::std::os::raw::c_char,
        _FilenameCount: usize,
        _Ext: *mut ::std::os::raw::c_char,
        _ExtCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn getenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: rsize_t,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn __p___argc() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p___argv() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p___wargv() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__environ() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wenviron() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn getenv(_VarName: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _dupenv_s(
        _Buffer: *mut *mut ::std::os::raw::c_char,
        _BufferCount: *mut usize,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn system(_Command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv_s(
        _Name: *const ::std::os::raw::c_char,
        _Value: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv_s(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _seterrormode(_Mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _beep(_Frequency: ::std::os::raw::c_uint, _Duration: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _sleep(_Duration: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onexit(_Func: _onexit_t) -> _onexit_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestCase {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestSuite {
    _unused: [u8; 0],
}
pub type GTestFunc = ::std::option::Option<unsafe extern "C" fn()>;
pub type GTestDataFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gconstpointer)>;
pub type GTestFixtureFunc =
    ::std::option::Option<unsafe extern "C" fn(fixture: gpointer, user_data: gconstpointer)>;
extern "C" {
    pub fn g_strcmp0(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_test_minimized_result(
        minimized_quantity: f64,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn g_test_maximized_result(
        maximized_quantity: f64,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn g_test_init(
        argc: *mut ::std::os::raw::c_int,
        argv: *mut *mut *mut ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn g_test_subprocess() -> gboolean;
}
extern "C" {
    pub fn g_test_run() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_test_add_func(testpath: *const ::std::os::raw::c_char, test_func: GTestFunc);
}
extern "C" {
    pub fn g_test_add_data_func(
        testpath: *const ::std::os::raw::c_char,
        test_data: gconstpointer,
        test_func: GTestDataFunc,
    );
}
extern "C" {
    pub fn g_test_add_data_func_full(
        testpath: *const ::std::os::raw::c_char,
        test_data: gpointer,
        test_func: GTestDataFunc,
        data_free_func: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_test_get_path() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_test_fail();
}
extern "C" {
    pub fn g_test_fail_printf(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn g_test_incomplete(msg: *const gchar);
}
extern "C" {
    pub fn g_test_incomplete_printf(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn g_test_skip(msg: *const gchar);
}
extern "C" {
    pub fn g_test_skip_printf(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn g_test_failed() -> gboolean;
}
extern "C" {
    pub fn g_test_set_nonfatal_assertions();
}
extern "C" {
    pub fn g_test_disable_crash_reporting();
}
extern "C" {
    pub fn g_test_message(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn g_test_bug_base(uri_pattern: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_test_bug(bug_uri_snippet: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_test_summary(summary: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_test_timer_start();
}
extern "C" {
    pub fn g_test_timer_elapsed() -> f64;
}
extern "C" {
    pub fn g_test_timer_last() -> f64;
}
extern "C" {
    pub fn g_test_queue_free(gfree_pointer: gpointer);
}
extern "C" {
    pub fn g_test_queue_destroy(destroy_func: GDestroyNotify, destroy_data: gpointer);
}
pub const GTestTrapFlags_G_TEST_TRAP_DEFAULT: GTestTrapFlags = 0;
pub const GTestTrapFlags_G_TEST_TRAP_SILENCE_STDOUT: GTestTrapFlags = 128;
pub const GTestTrapFlags_G_TEST_TRAP_SILENCE_STDERR: GTestTrapFlags = 256;
pub const GTestTrapFlags_G_TEST_TRAP_INHERIT_STDIN: GTestTrapFlags = 512;
#[doc = " GTestTrapFlags:\n @G_TEST_TRAP_DEFAULT: Default behaviour. Since: 2.74\n @G_TEST_TRAP_SILENCE_STDOUT: Redirect stdout of the test child to\n     `/dev/null` so it cannot be observed on the console during test\n     runs. The actual output is still captured though to allow later\n     tests with g_test_trap_assert_stdout().\n @G_TEST_TRAP_SILENCE_STDERR: Redirect stderr of the test child to\n     `/dev/null` so it cannot be observed on the console during test\n     runs. The actual output is still captured though to allow later\n     tests with g_test_trap_assert_stderr().\n @G_TEST_TRAP_INHERIT_STDIN: If this flag is given, stdin of the\n     child process is shared with stdin of its parent process.\n     It is redirected to `/dev/null` otherwise.\n\n Test traps are guards around forked tests.\n These flags determine what traps to set.\n\n Deprecated: 2.38: #GTestTrapFlags is used only with g_test_trap_fork(),\n which is deprecated. g_test_trap_subprocess() uses\n #GTestSubprocessFlags."]
pub type GTestTrapFlags = ::std::os::raw::c_int;
extern "C" {
    pub fn g_test_trap_fork(usec_timeout: guint64, test_trap_flags: GTestTrapFlags) -> gboolean;
}
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_DEFAULT: GTestSubprocessFlags = 0;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDIN: GTestSubprocessFlags = 1;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDOUT: GTestSubprocessFlags = 2;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDERR: GTestSubprocessFlags = 4;
pub type GTestSubprocessFlags = ::std::os::raw::c_int;
extern "C" {
    pub fn g_test_trap_subprocess(
        test_path: *const ::std::os::raw::c_char,
        usec_timeout: guint64,
        test_flags: GTestSubprocessFlags,
    );
}
extern "C" {
    pub fn g_test_trap_has_passed() -> gboolean;
}
extern "C" {
    pub fn g_test_trap_reached_timeout() -> gboolean;
}
extern "C" {
    pub fn g_test_rand_int() -> gint32;
}
extern "C" {
    pub fn g_test_rand_int_range(begin: gint32, end: gint32) -> gint32;
}
extern "C" {
    pub fn g_test_rand_double() -> f64;
}
extern "C" {
    pub fn g_test_rand_double_range(range_start: f64, range_end: f64) -> f64;
}
extern "C" {
    pub fn g_test_create_case(
        test_name: *const ::std::os::raw::c_char,
        data_size: gsize,
        test_data: gconstpointer,
        data_setup: GTestFixtureFunc,
        data_test: GTestFixtureFunc,
        data_teardown: GTestFixtureFunc,
    ) -> *mut GTestCase;
}
extern "C" {
    pub fn g_test_create_suite(suite_name: *const ::std::os::raw::c_char) -> *mut GTestSuite;
}
extern "C" {
    pub fn g_test_get_root() -> *mut GTestSuite;
}
extern "C" {
    pub fn g_test_suite_add(suite: *mut GTestSuite, test_case: *mut GTestCase);
}
extern "C" {
    pub fn g_test_suite_add_suite(suite: *mut GTestSuite, nestedsuite: *mut GTestSuite);
}
extern "C" {
    pub fn g_test_run_suite(suite: *mut GTestSuite) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_test_case_free(test_case: *mut GTestCase);
}
extern "C" {
    pub fn g_test_suite_free(suite: *mut GTestSuite);
}
extern "C" {
    pub fn g_test_trap_assertions(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        assertion_flags: guint64,
        pattern: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message_expr(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn g_assertion_message_cmpstr(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: *const ::std::os::raw::c_char,
        cmp: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message_cmpstrv(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: *const *const ::std::os::raw::c_char,
        arg2: *const *const ::std::os::raw::c_char,
        first_wrong_idx: gsize,
    );
}
extern "C" {
    pub fn g_assertion_message_cmpint(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: guint64,
        cmp: *const ::std::os::raw::c_char,
        arg2: guint64,
        numtype: ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message_cmpnum(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: f64,
        cmp: *const ::std::os::raw::c_char,
        arg2: f64,
        numtype: ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message_error(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        error: *const GError,
        error_domain: GQuark,
        error_code: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn g_test_add_vtable(
        testpath: *const ::std::os::raw::c_char,
        data_size: gsize,
        test_data: gconstpointer,
        data_setup: GTestFixtureFunc,
        data_test: GTestFixtureFunc,
        data_teardown: GTestFixtureFunc,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestConfig {
    pub test_initialized: gboolean,
    pub test_quick: gboolean,
    pub test_perf: gboolean,
    pub test_verbose: gboolean,
    pub test_quiet: gboolean,
    pub test_undefined: gboolean,
}
#[test]
fn bindgen_test_layout_GTestConfig() {
    const UNINIT: ::std::mem::MaybeUninit<GTestConfig> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GTestConfig>(),
        24usize,
        concat!("Size of: ", stringify!(GTestConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<GTestConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(GTestConfig))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).test_initialized) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_initialized)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).test_quick) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_quick)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).test_perf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_perf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).test_verbose) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_verbose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).test_quiet) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_quiet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).test_undefined) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_undefined)
        )
    );
}
extern "C" {
    pub static g_test_config_vars: *const GTestConfig;
}
pub const GTestResult_G_TEST_RUN_SUCCESS: GTestResult = 0;
pub const GTestResult_G_TEST_RUN_SKIPPED: GTestResult = 1;
pub const GTestResult_G_TEST_RUN_FAILURE: GTestResult = 2;
pub const GTestResult_G_TEST_RUN_INCOMPLETE: GTestResult = 3;
pub type GTestResult = ::std::os::raw::c_int;
pub const GTestLogType_G_TEST_LOG_NONE: GTestLogType = 0;
pub const GTestLogType_G_TEST_LOG_ERROR: GTestLogType = 1;
pub const GTestLogType_G_TEST_LOG_START_BINARY: GTestLogType = 2;
pub const GTestLogType_G_TEST_LOG_LIST_CASE: GTestLogType = 3;
pub const GTestLogType_G_TEST_LOG_SKIP_CASE: GTestLogType = 4;
pub const GTestLogType_G_TEST_LOG_START_CASE: GTestLogType = 5;
pub const GTestLogType_G_TEST_LOG_STOP_CASE: GTestLogType = 6;
pub const GTestLogType_G_TEST_LOG_MIN_RESULT: GTestLogType = 7;
pub const GTestLogType_G_TEST_LOG_MAX_RESULT: GTestLogType = 8;
pub const GTestLogType_G_TEST_LOG_MESSAGE: GTestLogType = 9;
pub const GTestLogType_G_TEST_LOG_START_SUITE: GTestLogType = 10;
pub const GTestLogType_G_TEST_LOG_STOP_SUITE: GTestLogType = 11;
pub type GTestLogType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestLogMsg {
    pub log_type: GTestLogType,
    pub n_strings: guint,
    pub strings: *mut *mut gchar,
    pub n_nums: guint,
    pub nums: *mut f64,
}
#[test]
fn bindgen_test_layout_GTestLogMsg() {
    const UNINIT: ::std::mem::MaybeUninit<GTestLogMsg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GTestLogMsg>(),
        32usize,
        concat!("Size of: ", stringify!(GTestLogMsg))
    );
    assert_eq!(
        ::std::mem::align_of::<GTestLogMsg>(),
        8usize,
        concat!("Alignment of ", stringify!(GTestLogMsg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(log_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_strings) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(n_strings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strings) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(strings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_nums) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(n_nums)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nums) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(nums)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestLogBuffer {
    pub data: *mut GString,
    pub msgs: *mut GSList,
}
#[test]
fn bindgen_test_layout_GTestLogBuffer() {
    const UNINIT: ::std::mem::MaybeUninit<GTestLogBuffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GTestLogBuffer>(),
        16usize,
        concat!("Size of: ", stringify!(GTestLogBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<GTestLogBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(GTestLogBuffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogBuffer),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogBuffer),
            "::",
            stringify!(msgs)
        )
    );
}
extern "C" {
    pub fn g_test_log_type_name(log_type: GTestLogType) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_test_log_buffer_new() -> *mut GTestLogBuffer;
}
extern "C" {
    pub fn g_test_log_buffer_free(tbuffer: *mut GTestLogBuffer);
}
extern "C" {
    pub fn g_test_log_buffer_push(
        tbuffer: *mut GTestLogBuffer,
        n_bytes: guint,
        bytes: *const guint8,
    );
}
extern "C" {
    pub fn g_test_log_buffer_pop(tbuffer: *mut GTestLogBuffer) -> *mut GTestLogMsg;
}
extern "C" {
    pub fn g_test_log_msg_free(tmsg: *mut GTestLogMsg);
}
#[doc = " GTestLogFatalFunc:\n @log_domain: the log domain of the message\n @log_level: the log level of the message (including the fatal and recursion flags)\n @message: the message to process\n @user_data: user data, set in g_test_log_set_fatal_handler()\n\n Specifies the prototype of fatal log handler functions.\n\n Returns: %TRUE if the program should abort, %FALSE otherwise\n\n Since: 2.22"]
pub type GTestLogFatalFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        user_data: gpointer,
    ) -> gboolean,
>;
extern "C" {
    pub fn g_test_log_set_fatal_handler(log_func: GTestLogFatalFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_test_expect_message(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        pattern: *const gchar,
    );
}
extern "C" {
    pub fn g_test_assert_expected_messages_internal(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
    );
}
pub const GTestFileType_G_TEST_DIST: GTestFileType = 0;
pub const GTestFileType_G_TEST_BUILT: GTestFileType = 1;
pub type GTestFileType = ::std::os::raw::c_int;
extern "C" {
    pub fn g_test_build_filename(
        file_type: GTestFileType,
        first_path: *const gchar,
        ...
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_test_get_dir(file_type: GTestFileType) -> *const gchar;
}
extern "C" {
    pub fn g_test_get_filename(
        file_type: GTestFileType,
        first_path: *const gchar,
        ...
    ) -> *const gchar;
}
pub type GThreadPool = _GThreadPool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadPool {
    pub func: GFunc,
    pub user_data: gpointer,
    pub exclusive: gboolean,
}
#[test]
fn bindgen_test_layout__GThreadPool() {
    const UNINIT: ::std::mem::MaybeUninit<_GThreadPool> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GThreadPool>(),
        24usize,
        concat!("Size of: ", stringify!(_GThreadPool))
    );
    assert_eq!(
        ::std::mem::align_of::<_GThreadPool>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThreadPool))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadPool),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadPool),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exclusive) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadPool),
            "::",
            stringify!(exclusive)
        )
    );
}
extern "C" {
    pub fn g_thread_pool_new(
        func: GFunc,
        user_data: gpointer,
        max_threads: gint,
        exclusive: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThreadPool;
}
extern "C" {
    pub fn g_thread_pool_new_full(
        func: GFunc,
        user_data: gpointer,
        item_free_func: GDestroyNotify,
        max_threads: gint,
        exclusive: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThreadPool;
}
extern "C" {
    pub fn g_thread_pool_free(pool: *mut GThreadPool, immediate: gboolean, wait_: gboolean);
}
extern "C" {
    pub fn g_thread_pool_push(
        pool: *mut GThreadPool,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_thread_pool_unprocessed(pool: *mut GThreadPool) -> guint;
}
extern "C" {
    pub fn g_thread_pool_set_sort_function(
        pool: *mut GThreadPool,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_thread_pool_move_to_front(pool: *mut GThreadPool, data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_thread_pool_set_max_threads(
        pool: *mut GThreadPool,
        max_threads: gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_thread_pool_get_max_threads(pool: *mut GThreadPool) -> gint;
}
extern "C" {
    pub fn g_thread_pool_get_num_threads(pool: *mut GThreadPool) -> guint;
}
extern "C" {
    pub fn g_thread_pool_set_max_unused_threads(max_threads: gint);
}
extern "C" {
    pub fn g_thread_pool_get_max_unused_threads() -> gint;
}
extern "C" {
    pub fn g_thread_pool_get_num_unused_threads() -> guint;
}
extern "C" {
    pub fn g_thread_pool_stop_unused_threads();
}
extern "C" {
    pub fn g_thread_pool_set_max_idle_time(interval: guint);
}
extern "C" {
    pub fn g_thread_pool_get_max_idle_time() -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimer {
    _unused: [u8; 0],
}
pub type GTimer = _GTimer;
extern "C" {
    pub fn g_timer_new() -> *mut GTimer;
}
extern "C" {
    pub fn g_timer_destroy(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_start(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_stop(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_reset(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_continue(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_elapsed(timer: *mut GTimer, microseconds: *mut gulong) -> gdouble;
}
extern "C" {
    pub fn g_timer_is_active(timer: *mut GTimer) -> gboolean;
}
extern "C" {
    pub fn g_usleep(microseconds: gulong);
}
extern "C" {
    pub fn g_time_val_add(time_: *mut GTimeVal, microseconds: glong);
}
extern "C" {
    pub fn g_time_val_from_iso8601(iso_date: *const gchar, time_: *mut GTimeVal) -> gboolean;
}
extern "C" {
    pub fn g_time_val_to_iso8601(time_: *mut GTimeVal) -> *mut gchar;
}
pub type GTrashStack = _GTrashStack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTrashStack {
    pub next: *mut GTrashStack,
}
#[test]
fn bindgen_test_layout__GTrashStack() {
    const UNINIT: ::std::mem::MaybeUninit<_GTrashStack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTrashStack>(),
        8usize,
        concat!("Size of: ", stringify!(_GTrashStack))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTrashStack>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTrashStack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTrashStack),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn g_trash_stack_push(stack_p: *mut *mut GTrashStack, data_p: gpointer);
}
extern "C" {
    pub fn g_trash_stack_pop(stack_p: *mut *mut GTrashStack) -> gpointer;
}
extern "C" {
    pub fn g_trash_stack_peek(stack_p: *mut *mut GTrashStack) -> gpointer;
}
extern "C" {
    pub fn g_trash_stack_height(stack_p: *mut *mut GTrashStack) -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTree {
    _unused: [u8; 0],
}
pub type GTree = _GTree;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTreeNode {
    _unused: [u8; 0],
}
#[doc = " GTreeNode:\n\n An opaque type which identifies a specific node in a #GTree.\n\n Since: 2.68"]
pub type GTreeNode = _GTreeNode;
pub type GTraverseFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, data: gpointer) -> gboolean,
>;
#[doc = " GTraverseNodeFunc:\n @node: a #GTreeNode\n @data: user data passed to g_tree_foreach_node()\n\n Specifies the type of function passed to g_tree_foreach_node(). It is\n passed each node, together with the @user_data parameter passed to\n g_tree_foreach_node(). If the function returns %TRUE, the traversal is\n stopped.\n\n Returns: %TRUE to stop the traversal\n Since: 2.68"]
pub type GTraverseNodeFunc =
    ::std::option::Option<unsafe extern "C" fn(node: *mut GTreeNode, data: gpointer) -> gboolean>;
extern "C" {
    pub fn g_tree_new(key_compare_func: GCompareFunc) -> *mut GTree;
}
extern "C" {
    pub fn g_tree_new_with_data(
        key_compare_func: GCompareDataFunc,
        key_compare_data: gpointer,
    ) -> *mut GTree;
}
extern "C" {
    pub fn g_tree_new_full(
        key_compare_func: GCompareDataFunc,
        key_compare_data: gpointer,
        key_destroy_func: GDestroyNotify,
        value_destroy_func: GDestroyNotify,
    ) -> *mut GTree;
}
extern "C" {
    pub fn g_tree_node_first(tree: *mut GTree) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_node_last(tree: *mut GTree) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_node_previous(node: *mut GTreeNode) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_node_next(node: *mut GTreeNode) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_ref(tree: *mut GTree) -> *mut GTree;
}
extern "C" {
    pub fn g_tree_unref(tree: *mut GTree);
}
extern "C" {
    pub fn g_tree_destroy(tree: *mut GTree);
}
extern "C" {
    pub fn g_tree_insert_node(tree: *mut GTree, key: gpointer, value: gpointer) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_insert(tree: *mut GTree, key: gpointer, value: gpointer);
}
extern "C" {
    pub fn g_tree_replace_node(tree: *mut GTree, key: gpointer, value: gpointer) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_replace(tree: *mut GTree, key: gpointer, value: gpointer);
}
extern "C" {
    pub fn g_tree_remove(tree: *mut GTree, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_tree_remove_all(tree: *mut GTree);
}
extern "C" {
    pub fn g_tree_steal(tree: *mut GTree, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_tree_node_key(node: *mut GTreeNode) -> gpointer;
}
extern "C" {
    pub fn g_tree_node_value(node: *mut GTreeNode) -> gpointer;
}
extern "C" {
    pub fn g_tree_lookup_node(tree: *mut GTree, key: gconstpointer) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_lookup(tree: *mut GTree, key: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_tree_lookup_extended(
        tree: *mut GTree,
        lookup_key: gconstpointer,
        orig_key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_tree_foreach(tree: *mut GTree, func: GTraverseFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_tree_foreach_node(tree: *mut GTree, func: GTraverseNodeFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_tree_traverse(
        tree: *mut GTree,
        traverse_func: GTraverseFunc,
        traverse_type: GTraverseType,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_tree_search_node(
        tree: *mut GTree,
        search_func: GCompareFunc,
        user_data: gconstpointer,
    ) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_search(
        tree: *mut GTree,
        search_func: GCompareFunc,
        user_data: gconstpointer,
    ) -> gpointer;
}
extern "C" {
    pub fn g_tree_lower_bound(tree: *mut GTree, key: gconstpointer) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_upper_bound(tree: *mut GTree, key: gconstpointer) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_height(tree: *mut GTree) -> gint;
}
extern "C" {
    pub fn g_tree_nnodes(tree: *mut GTree) -> gint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUri {
    _unused: [u8; 0],
}
pub type GUri = _GUri;
extern "C" {
    pub fn g_uri_ref(uri: *mut GUri) -> *mut GUri;
}
extern "C" {
    pub fn g_uri_unref(uri: *mut GUri);
}
pub const GUriFlags_G_URI_FLAGS_NONE: GUriFlags = 0;
pub const GUriFlags_G_URI_FLAGS_PARSE_RELAXED: GUriFlags = 1;
pub const GUriFlags_G_URI_FLAGS_HAS_PASSWORD: GUriFlags = 2;
pub const GUriFlags_G_URI_FLAGS_HAS_AUTH_PARAMS: GUriFlags = 4;
pub const GUriFlags_G_URI_FLAGS_ENCODED: GUriFlags = 8;
pub const GUriFlags_G_URI_FLAGS_NON_DNS: GUriFlags = 16;
pub const GUriFlags_G_URI_FLAGS_ENCODED_QUERY: GUriFlags = 32;
pub const GUriFlags_G_URI_FLAGS_ENCODED_PATH: GUriFlags = 64;
pub const GUriFlags_G_URI_FLAGS_ENCODED_FRAGMENT: GUriFlags = 128;
pub const GUriFlags_G_URI_FLAGS_SCHEME_NORMALIZE: GUriFlags = 256;
#[doc = " GUriFlags:\n @G_URI_FLAGS_NONE: No flags set.\n @G_URI_FLAGS_PARSE_RELAXED: Parse the URI more relaxedly than the\n     [RFC 3986](https://tools.ietf.org/html/rfc3986) grammar specifies,\n     fixing up or ignoring common mistakes in URIs coming from external\n     sources. This is also needed for some obscure URI schemes where `;`\n     separates the host from the path. Dont use this flag unless you need to.\n @G_URI_FLAGS_HAS_PASSWORD: The userinfo field may contain a password,\n     which will be separated from the username by `:`.\n @G_URI_FLAGS_HAS_AUTH_PARAMS: The userinfo may contain additional\n     authentication-related parameters, which will be separated from\n     the username and/or password by `;`.\n @G_URI_FLAGS_NON_DNS: The host component should not be assumed to be a\n     DNS hostname or IP address (for example, for `smb` URIs with NetBIOS\n     hostnames).\n @G_URI_FLAGS_ENCODED: When parsing a URI, this indicates that `%`-encoded\n     characters in the userinfo, path, query, and fragment fields\n     should not be decoded. (And likewise the host field if\n     %G_URI_FLAGS_NON_DNS is also set.) When building a URI, it indicates\n     that you have already `%`-encoded the components, and so #GUri\n     should not do any encoding itself.\n @G_URI_FLAGS_ENCODED_QUERY: Same as %G_URI_FLAGS_ENCODED, for the query\n     field only.\n @G_URI_FLAGS_ENCODED_PATH: Same as %G_URI_FLAGS_ENCODED, for the path only.\n @G_URI_FLAGS_ENCODED_FRAGMENT: Same as %G_URI_FLAGS_ENCODED, for the\n     fragment only.\n @G_URI_FLAGS_SCHEME_NORMALIZE: A scheme-based normalization will be applied.\n     For example, when parsing an HTTP URI changing omitted path to `/` and\n     omitted port to `80`; and when building a URI, changing empty path to `/`\n     and default port `80`). This only supports a subset of known schemes. (Since: 2.68)\n\n Flags that describe a URI.\n\n When parsing a URI, if you need to choose different flags based on\n the type of URI, you can use g_uri_peek_scheme() on the URI string\n to check the scheme first, and use that to decide what flags to\n parse it with.\n\n Since: 2.66"]
pub type GUriFlags = ::std::os::raw::c_int;
extern "C" {
    pub fn g_uri_split(
        uri_ref: *const gchar,
        flags: GUriFlags,
        scheme: *mut *mut gchar,
        userinfo: *mut *mut gchar,
        host: *mut *mut gchar,
        port: *mut gint,
        path: *mut *mut gchar,
        query: *mut *mut gchar,
        fragment: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_uri_split_with_user(
        uri_ref: *const gchar,
        flags: GUriFlags,
        scheme: *mut *mut gchar,
        user: *mut *mut gchar,
        password: *mut *mut gchar,
        auth_params: *mut *mut gchar,
        host: *mut *mut gchar,
        port: *mut gint,
        path: *mut *mut gchar,
        query: *mut *mut gchar,
        fragment: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_uri_split_network(
        uri_string: *const gchar,
        flags: GUriFlags,
        scheme: *mut *mut gchar,
        host: *mut *mut gchar,
        port: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_uri_is_valid(
        uri_string: *const gchar,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_uri_join(
        flags: GUriFlags,
        scheme: *const gchar,
        userinfo: *const gchar,
        host: *const gchar,
        port: gint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_uri_join_with_user(
        flags: GUriFlags,
        scheme: *const gchar,
        user: *const gchar,
        password: *const gchar,
        auth_params: *const gchar,
        host: *const gchar,
        port: gint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_uri_parse(
        uri_string: *const gchar,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> *mut GUri;
}
extern "C" {
    pub fn g_uri_parse_relative(
        base_uri: *mut GUri,
        uri_ref: *const gchar,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> *mut GUri;
}
extern "C" {
    pub fn g_uri_resolve_relative(
        base_uri_string: *const gchar,
        uri_ref: *const gchar,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_uri_build(
        flags: GUriFlags,
        scheme: *const gchar,
        userinfo: *const gchar,
        host: *const gchar,
        port: gint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut GUri;
}
extern "C" {
    pub fn g_uri_build_with_user(
        flags: GUriFlags,
        scheme: *const gchar,
        user: *const gchar,
        password: *const gchar,
        auth_params: *const gchar,
        host: *const gchar,
        port: gint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut GUri;
}
pub const GUriHideFlags_G_URI_HIDE_NONE: GUriHideFlags = 0;
pub const GUriHideFlags_G_URI_HIDE_USERINFO: GUriHideFlags = 1;
pub const GUriHideFlags_G_URI_HIDE_PASSWORD: GUriHideFlags = 2;
pub const GUriHideFlags_G_URI_HIDE_AUTH_PARAMS: GUriHideFlags = 4;
pub const GUriHideFlags_G_URI_HIDE_QUERY: GUriHideFlags = 8;
pub const GUriHideFlags_G_URI_HIDE_FRAGMENT: GUriHideFlags = 16;
#[doc = " GUriHideFlags:\n @G_URI_HIDE_NONE: No flags set.\n @G_URI_HIDE_USERINFO: Hide the userinfo.\n @G_URI_HIDE_PASSWORD: Hide the password.\n @G_URI_HIDE_AUTH_PARAMS: Hide the auth_params.\n @G_URI_HIDE_QUERY: Hide the query.\n @G_URI_HIDE_FRAGMENT: Hide the fragment.\n\n Flags describing what parts of the URI to hide in\n g_uri_to_string_partial(). Note that %G_URI_HIDE_PASSWORD and\n %G_URI_HIDE_AUTH_PARAMS will only work if the #GUri was parsed with\n the corresponding flags.\n\n Since: 2.66"]
pub type GUriHideFlags = ::std::os::raw::c_int;
extern "C" {
    pub fn g_uri_to_string(uri: *mut GUri) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_to_string_partial(
        uri: *mut GUri,
        flags: GUriHideFlags,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_get_scheme(uri: *mut GUri) -> *const gchar;
}
extern "C" {
    pub fn g_uri_get_userinfo(uri: *mut GUri) -> *const gchar;
}
extern "C" {
    pub fn g_uri_get_user(uri: *mut GUri) -> *const gchar;
}
extern "C" {
    pub fn g_uri_get_password(uri: *mut GUri) -> *const gchar;
}
extern "C" {
    pub fn g_uri_get_auth_params(uri: *mut GUri) -> *const gchar;
}
extern "C" {
    pub fn g_uri_get_host(uri: *mut GUri) -> *const gchar;
}
extern "C" {
    pub fn g_uri_get_port(uri: *mut GUri) -> gint;
}
extern "C" {
    pub fn g_uri_get_path(uri: *mut GUri) -> *const gchar;
}
extern "C" {
    pub fn g_uri_get_query(uri: *mut GUri) -> *const gchar;
}
extern "C" {
    pub fn g_uri_get_fragment(uri: *mut GUri) -> *const gchar;
}
extern "C" {
    pub fn g_uri_get_flags(uri: *mut GUri) -> GUriFlags;
}
pub const GUriParamsFlags_G_URI_PARAMS_NONE: GUriParamsFlags = 0;
pub const GUriParamsFlags_G_URI_PARAMS_CASE_INSENSITIVE: GUriParamsFlags = 1;
pub const GUriParamsFlags_G_URI_PARAMS_WWW_FORM: GUriParamsFlags = 2;
pub const GUriParamsFlags_G_URI_PARAMS_PARSE_RELAXED: GUriParamsFlags = 4;
#[doc = " GUriParamsFlags:\n @G_URI_PARAMS_NONE: No flags set.\n @G_URI_PARAMS_CASE_INSENSITIVE: Parameter names are case insensitive.\n @G_URI_PARAMS_WWW_FORM: Replace `+` with space character. Only useful for\n     URLs on the web, using the `https` or `http` schemas.\n @G_URI_PARAMS_PARSE_RELAXED: See %G_URI_FLAGS_PARSE_RELAXED.\n\n Flags modifying the way parameters are handled by g_uri_parse_params() and\n #GUriParamsIter.\n\n Since: 2.66"]
pub type GUriParamsFlags = ::std::os::raw::c_int;
extern "C" {
    pub fn g_uri_parse_params(
        params: *const gchar,
        length: gssize,
        separators: *const gchar,
        flags: GUriParamsFlags,
        error: *mut *mut GError,
    ) -> *mut GHashTable;
}
pub type GUriParamsIter = _GUriParamsIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUriParamsIter {
    pub dummy0: gint,
    pub dummy1: gpointer,
    pub dummy2: gpointer,
    pub dummy3: [guint8; 256usize],
}
#[test]
fn bindgen_test_layout__GUriParamsIter() {
    const UNINIT: ::std::mem::MaybeUninit<_GUriParamsIter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GUriParamsIter>(),
        280usize,
        concat!("Size of: ", stringify!(_GUriParamsIter))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUriParamsIter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GUriParamsIter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUriParamsIter),
            "::",
            stringify!(dummy0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUriParamsIter),
            "::",
            stringify!(dummy1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUriParamsIter),
            "::",
            stringify!(dummy2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy3) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUriParamsIter),
            "::",
            stringify!(dummy3)
        )
    );
}
extern "C" {
    pub fn g_uri_params_iter_init(
        iter: *mut GUriParamsIter,
        params: *const gchar,
        length: gssize,
        separators: *const gchar,
        flags: GUriParamsFlags,
    );
}
extern "C" {
    pub fn g_uri_params_iter_next(
        iter: *mut GUriParamsIter,
        attribute: *mut *mut gchar,
        value: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_uri_error_quark() -> GQuark;
}
pub const GUriError_G_URI_ERROR_FAILED: GUriError = 0;
pub const GUriError_G_URI_ERROR_BAD_SCHEME: GUriError = 1;
pub const GUriError_G_URI_ERROR_BAD_USER: GUriError = 2;
pub const GUriError_G_URI_ERROR_BAD_PASSWORD: GUriError = 3;
pub const GUriError_G_URI_ERROR_BAD_AUTH_PARAMS: GUriError = 4;
pub const GUriError_G_URI_ERROR_BAD_HOST: GUriError = 5;
pub const GUriError_G_URI_ERROR_BAD_PORT: GUriError = 6;
pub const GUriError_G_URI_ERROR_BAD_PATH: GUriError = 7;
pub const GUriError_G_URI_ERROR_BAD_QUERY: GUriError = 8;
pub const GUriError_G_URI_ERROR_BAD_FRAGMENT: GUriError = 9;
#[doc = " GUriError:\n @G_URI_ERROR_FAILED: Generic error if no more specific error is available.\n     See the error message for details.\n @G_URI_ERROR_BAD_SCHEME: The scheme of a URI could not be parsed.\n @G_URI_ERROR_BAD_USER: The user/userinfo of a URI could not be parsed.\n @G_URI_ERROR_BAD_PASSWORD: The password of a URI could not be parsed.\n @G_URI_ERROR_BAD_AUTH_PARAMS: The authentication parameters of a URI could not be parsed.\n @G_URI_ERROR_BAD_HOST: The host of a URI could not be parsed.\n @G_URI_ERROR_BAD_PORT: The port of a URI could not be parsed.\n @G_URI_ERROR_BAD_PATH: The path of a URI could not be parsed.\n @G_URI_ERROR_BAD_QUERY: The query of a URI could not be parsed.\n @G_URI_ERROR_BAD_FRAGMENT: The fragment of a URI could not be parsed.\n\n Error codes returned by #GUri methods.\n\n Since: 2.66"]
pub type GUriError = ::std::os::raw::c_int;
extern "C" {
    pub fn g_uri_unescape_string(
        escaped_string: *const ::std::os::raw::c_char,
        illegal_characters: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_unescape_segment(
        escaped_string: *const ::std::os::raw::c_char,
        escaped_string_end: *const ::std::os::raw::c_char,
        illegal_characters: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_parse_scheme(uri: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_peek_scheme(uri: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_escape_string(
        unescaped: *const ::std::os::raw::c_char,
        reserved_chars_allowed: *const ::std::os::raw::c_char,
        allow_utf8: gboolean,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_unescape_bytes(
        escaped_string: *const ::std::os::raw::c_char,
        length: gssize,
        illegal_characters: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
extern "C" {
    pub fn g_uri_escape_bytes(
        unescaped: *const guint8,
        length: gsize,
        reserved_chars_allowed: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uuid_string_is_valid(str_: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_uuid_string_random() -> *mut gchar;
}
extern "C" {
    pub static glib_major_version: guint;
}
extern "C" {
    pub static glib_minor_version: guint;
}
extern "C" {
    pub static glib_micro_version: guint;
}
extern "C" {
    pub static glib_interface_age: guint;
}
extern "C" {
    pub static glib_binary_age: guint;
}
extern "C" {
    pub fn glib_check_version(
        required_major: guint,
        required_minor: guint,
        required_micro: guint,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_win32_ftruncate(f: gint, size: guint) -> gint;
}
extern "C" {
    pub fn g_win32_getlocale() -> *mut gchar;
}
extern "C" {
    pub fn g_win32_error_message(error: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_win32_get_package_installation_directory(
        package: *const gchar,
        dll_name: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_win32_get_package_installation_subdirectory(
        package: *const gchar,
        dll_name: *const gchar,
        subdir: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_win32_get_package_installation_directory_of_module(hmodule: gpointer) -> *mut gchar;
}
extern "C" {
    pub fn g_win32_get_windows_version() -> guint;
}
extern "C" {
    pub fn g_win32_locale_filename_from_utf8(utf8filename: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_win32_get_command_line() -> *mut *mut gchar;
}
pub const GWin32OSType_G_WIN32_OS_ANY: GWin32OSType = 0;
pub const GWin32OSType_G_WIN32_OS_WORKSTATION: GWin32OSType = 1;
pub const GWin32OSType_G_WIN32_OS_SERVER: GWin32OSType = 2;
#[doc = " GWin32OSType:\n @G_WIN32_OS_ANY: The running system can be a workstation or a server edition of\n  Windows.  The type of the running system is therefore not checked.\n @G_WIN32_OS_WORKSTATION: The running system is a workstation edition of Windows,\n  such as Windows 7 Professional.\n @G_WIN32_OS_SERVER: The running system is a server edition of Windows, such as\n  Windows Server 2008 R2.\n\n Type of Windows edition to check for at run-time."]
pub type GWin32OSType = ::std::os::raw::c_int;
extern "C" {
    pub fn g_win32_check_windows_version(
        major: gint,
        minor: gint,
        spver: gint,
        os_type: GWin32OSType,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAllocator {
    _unused: [u8; 0],
}
pub type GAllocator = _GAllocator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemChunk {
    _unused: [u8; 0],
}
pub type GMemChunk = _GMemChunk;
extern "C" {
    pub fn g_mem_chunk_new(
        name: *const gchar,
        atom_size: gint,
        area_size: gsize,
        type_: gint,
    ) -> *mut GMemChunk;
}
extern "C" {
    pub fn g_mem_chunk_destroy(mem_chunk: *mut GMemChunk);
}
extern "C" {
    pub fn g_mem_chunk_alloc(mem_chunk: *mut GMemChunk) -> gpointer;
}
extern "C" {
    pub fn g_mem_chunk_alloc0(mem_chunk: *mut GMemChunk) -> gpointer;
}
extern "C" {
    pub fn g_mem_chunk_free(mem_chunk: *mut GMemChunk, mem: gpointer);
}
extern "C" {
    pub fn g_mem_chunk_clean(mem_chunk: *mut GMemChunk);
}
extern "C" {
    pub fn g_mem_chunk_reset(mem_chunk: *mut GMemChunk);
}
extern "C" {
    pub fn g_mem_chunk_print(mem_chunk: *mut GMemChunk);
}
extern "C" {
    pub fn g_mem_chunk_info();
}
extern "C" {
    pub fn g_blow_chunks();
}
extern "C" {
    pub fn g_allocator_new(name: *const gchar, n_preallocs: guint) -> *mut GAllocator;
}
extern "C" {
    pub fn g_allocator_free(allocator: *mut GAllocator);
}
extern "C" {
    pub fn g_list_push_allocator(allocator: *mut GAllocator);
}
extern "C" {
    pub fn g_list_pop_allocator();
}
extern "C" {
    pub fn g_slist_push_allocator(allocator: *mut GAllocator);
}
extern "C" {
    pub fn g_slist_pop_allocator();
}
extern "C" {
    pub fn g_node_push_allocator(allocator: *mut GAllocator);
}
extern "C" {
    pub fn g_node_pop_allocator();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCache {
    _unused: [u8; 0],
}
pub type GCache = _GCache;
pub type GCacheNewFunc = ::std::option::Option<unsafe extern "C" fn(key: gpointer) -> gpointer>;
pub type GCacheDupFunc = ::std::option::Option<unsafe extern "C" fn(value: gpointer) -> gpointer>;
pub type GCacheDestroyFunc = ::std::option::Option<unsafe extern "C" fn(value: gpointer)>;
extern "C" {
    pub fn g_cache_new(
        value_new_func: GCacheNewFunc,
        value_destroy_func: GCacheDestroyFunc,
        key_dup_func: GCacheDupFunc,
        key_destroy_func: GCacheDestroyFunc,
        hash_key_func: GHashFunc,
        hash_value_func: GHashFunc,
        key_equal_func: GEqualFunc,
    ) -> *mut GCache;
}
extern "C" {
    pub fn g_cache_destroy(cache: *mut GCache);
}
extern "C" {
    pub fn g_cache_insert(cache: *mut GCache, key: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_cache_remove(cache: *mut GCache, value: gconstpointer);
}
extern "C" {
    pub fn g_cache_key_foreach(cache: *mut GCache, func: GHFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_cache_value_foreach(cache: *mut GCache, func: GHFunc, user_data: gpointer);
}
pub type GCompletion = _GCompletion;
pub type GCompletionFunc =
    ::std::option::Option<unsafe extern "C" fn(arg1: gpointer) -> *mut gchar>;
pub type GCompletionStrncmpFunc = ::std::option::Option<
    unsafe extern "C" fn(s1: *const gchar, s2: *const gchar, n: gsize) -> gint,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCompletion {
    pub items: *mut GList,
    pub func: GCompletionFunc,
    pub prefix: *mut gchar,
    pub cache: *mut GList,
    pub strncmp_func: GCompletionStrncmpFunc,
}
#[test]
fn bindgen_test_layout__GCompletion() {
    const UNINIT: ::std::mem::MaybeUninit<_GCompletion> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GCompletion>(),
        40usize,
        concat!("Size of: ", stringify!(_GCompletion))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCompletion>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCompletion))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).items) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cache) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strncmp_func) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(strncmp_func)
        )
    );
}
extern "C" {
    pub fn g_completion_new(func: GCompletionFunc) -> *mut GCompletion;
}
extern "C" {
    pub fn g_completion_add_items(cmp: *mut GCompletion, items: *mut GList);
}
extern "C" {
    pub fn g_completion_remove_items(cmp: *mut GCompletion, items: *mut GList);
}
extern "C" {
    pub fn g_completion_clear_items(cmp: *mut GCompletion);
}
extern "C" {
    pub fn g_completion_complete(
        cmp: *mut GCompletion,
        prefix: *const gchar,
        new_prefix: *mut *mut gchar,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_completion_complete_utf8(
        cmp: *mut GCompletion,
        prefix: *const gchar,
        new_prefix: *mut *mut gchar,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_completion_set_compare(cmp: *mut GCompletion, strncmp_func: GCompletionStrncmpFunc);
}
extern "C" {
    pub fn g_completion_free(cmp: *mut GCompletion);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRelation {
    _unused: [u8; 0],
}
pub type GRelation = _GRelation;
pub type GTuples = _GTuples;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTuples {
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GTuples() {
    const UNINIT: ::std::mem::MaybeUninit<_GTuples> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTuples>(),
        4usize,
        concat!("Size of: ", stringify!(_GTuples))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTuples>(),
        4usize,
        concat!("Alignment of ", stringify!(_GTuples))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTuples),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    pub fn g_relation_new(fields: gint) -> *mut GRelation;
}
extern "C" {
    pub fn g_relation_destroy(relation: *mut GRelation);
}
extern "C" {
    pub fn g_relation_index(
        relation: *mut GRelation,
        field: gint,
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
    );
}
extern "C" {
    pub fn g_relation_insert(relation: *mut GRelation, ...);
}
extern "C" {
    pub fn g_relation_delete(relation: *mut GRelation, key: gconstpointer, field: gint) -> gint;
}
extern "C" {
    pub fn g_relation_select(
        relation: *mut GRelation,
        key: gconstpointer,
        field: gint,
    ) -> *mut GTuples;
}
extern "C" {
    pub fn g_relation_count(relation: *mut GRelation, key: gconstpointer, field: gint) -> gint;
}
extern "C" {
    pub fn g_relation_exists(relation: *mut GRelation, ...) -> gboolean;
}
extern "C" {
    pub fn g_relation_print(relation: *mut GRelation);
}
extern "C" {
    pub fn g_tuples_destroy(tuples: *mut GTuples);
}
extern "C" {
    pub fn g_tuples_index(tuples: *mut GTuples, index_: gint, field: gint) -> gpointer;
}
pub const GThreadPriority_G_THREAD_PRIORITY_LOW: GThreadPriority = 0;
pub const GThreadPriority_G_THREAD_PRIORITY_NORMAL: GThreadPriority = 1;
pub const GThreadPriority_G_THREAD_PRIORITY_HIGH: GThreadPriority = 2;
pub const GThreadPriority_G_THREAD_PRIORITY_URGENT: GThreadPriority = 3;
pub type GThreadPriority = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThread {
    pub func: GThreadFunc,
    pub data: gpointer,
    pub joinable: gboolean,
    pub priority: GThreadPriority,
}
#[test]
fn bindgen_test_layout__GThread() {
    const UNINIT: ::std::mem::MaybeUninit<_GThread> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GThread>(),
        24usize,
        concat!("Size of: ", stringify!(_GThread))
    );
    assert_eq!(
        ::std::mem::align_of::<_GThread>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThread))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).joinable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(joinable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(priority)
        )
    );
}
pub type GThreadFunctions = _GThreadFunctions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadFunctions {
    pub mutex_new: ::std::option::Option<unsafe extern "C" fn() -> *mut GMutex>,
    pub mutex_lock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub mutex_trylock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex) -> gboolean>,
    pub mutex_unlock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub mutex_free: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub cond_new: ::std::option::Option<unsafe extern "C" fn() -> *mut GCond>,
    pub cond_signal: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub cond_broadcast: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub cond_wait:
        ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond, mutex: *mut GMutex)>,
    pub cond_timed_wait: ::std::option::Option<
        unsafe extern "C" fn(
            cond: *mut GCond,
            mutex: *mut GMutex,
            end_time: *mut GTimeVal,
        ) -> gboolean,
    >,
    pub cond_free: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub private_new:
        ::std::option::Option<unsafe extern "C" fn(destructor: GDestroyNotify) -> *mut GPrivate>,
    pub private_get:
        ::std::option::Option<unsafe extern "C" fn(private_key: *mut GPrivate) -> gpointer>,
    pub private_set:
        ::std::option::Option<unsafe extern "C" fn(private_key: *mut GPrivate, data: gpointer)>,
    pub thread_create: ::std::option::Option<
        unsafe extern "C" fn(
            func: GThreadFunc,
            data: gpointer,
            stack_size: gulong,
            joinable: gboolean,
            bound: gboolean,
            priority: GThreadPriority,
            thread: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub thread_yield: ::std::option::Option<unsafe extern "C" fn()>,
    pub thread_join: ::std::option::Option<unsafe extern "C" fn(thread: gpointer)>,
    pub thread_exit: ::std::option::Option<unsafe extern "C" fn()>,
    pub thread_set_priority:
        ::std::option::Option<unsafe extern "C" fn(thread: gpointer, priority: GThreadPriority)>,
    pub thread_self: ::std::option::Option<unsafe extern "C" fn(thread: gpointer)>,
    pub thread_equal: ::std::option::Option<
        unsafe extern "C" fn(thread1: gpointer, thread2: gpointer) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GThreadFunctions() {
    const UNINIT: ::std::mem::MaybeUninit<_GThreadFunctions> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GThreadFunctions>(),
        168usize,
        concat!("Size of: ", stringify!(_GThreadFunctions))
    );
    assert_eq!(
        ::std::mem::align_of::<_GThreadFunctions>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThreadFunctions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex_new) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_new)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex_lock) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex_trylock) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_trylock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex_unlock) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_unlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex_free) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cond_new) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_new)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cond_signal) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_signal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cond_broadcast) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_broadcast)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cond_wait) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_wait)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cond_timed_wait) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_timed_wait)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cond_free) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_new) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(private_new)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_get) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(private_get)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_set) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(private_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_create) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_yield) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_yield)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_join) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_join)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_exit) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_exit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_set_priority) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_set_priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_self) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_self)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_equal) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_equal)
        )
    );
}
extern "C" {
    pub static mut g_thread_functions_for_glib_use: GThreadFunctions;
}
extern "C" {
    pub static mut g_thread_use_default_impl: gboolean;
}
extern "C" {
    pub static mut g_thread_gettime: ::std::option::Option<unsafe extern "C" fn() -> guint64>;
}
extern "C" {
    pub fn g_thread_create(
        func: GThreadFunc,
        data: gpointer,
        joinable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_create_full(
        func: GThreadFunc,
        data: gpointer,
        stack_size: gulong,
        joinable: gboolean,
        bound: gboolean,
        priority: GThreadPriority,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_set_priority(thread: *mut GThread, priority: GThreadPriority);
}
extern "C" {
    pub fn g_thread_foreach(thread_func: GFunc, user_data: gpointer);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GStaticMutex {
    pub mutex: *mut GMutex,
}
#[test]
fn bindgen_test_layout_GStaticMutex() {
    const UNINIT: ::std::mem::MaybeUninit<GStaticMutex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GStaticMutex>(),
        8usize,
        concat!("Size of: ", stringify!(GStaticMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<GStaticMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(GStaticMutex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GStaticMutex),
            "::",
            stringify!(mutex)
        )
    );
}
extern "C" {
    pub fn g_static_mutex_init(mutex: *mut GStaticMutex);
}
extern "C" {
    pub fn g_static_mutex_free(mutex: *mut GStaticMutex);
}
extern "C" {
    pub fn g_static_mutex_get_mutex_impl(mutex: *mut GStaticMutex) -> *mut GMutex;
}
pub type GStaticRecMutex = _GStaticRecMutex;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GStaticRecMutex {
    pub mutex: GStaticMutex,
    pub depth: guint,
    pub unused: _GStaticRecMutex__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GStaticRecMutex__bindgen_ty_1 {
    pub owner: *mut ::std::os::raw::c_void,
    pub dummy: gdouble,
}
#[test]
fn bindgen_test_layout__GStaticRecMutex__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_GStaticRecMutex__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GStaticRecMutex__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_GStaticRecMutex__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticRecMutex__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticRecMutex__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex__bindgen_ty_1),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex__bindgen_ty_1),
            "::",
            stringify!(dummy)
        )
    );
}
#[test]
fn bindgen_test_layout__GStaticRecMutex() {
    const UNINIT: ::std::mem::MaybeUninit<_GStaticRecMutex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GStaticRecMutex>(),
        24usize,
        concat!("Size of: ", stringify!(_GStaticRecMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticRecMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticRecMutex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex),
            "::",
            stringify!(unused)
        )
    );
}
extern "C" {
    pub fn g_static_rec_mutex_init(mutex: *mut GStaticRecMutex);
}
extern "C" {
    pub fn g_static_rec_mutex_lock(mutex: *mut GStaticRecMutex);
}
extern "C" {
    pub fn g_static_rec_mutex_trylock(mutex: *mut GStaticRecMutex) -> gboolean;
}
extern "C" {
    pub fn g_static_rec_mutex_unlock(mutex: *mut GStaticRecMutex);
}
extern "C" {
    pub fn g_static_rec_mutex_lock_full(mutex: *mut GStaticRecMutex, depth: guint);
}
extern "C" {
    pub fn g_static_rec_mutex_unlock_full(mutex: *mut GStaticRecMutex) -> guint;
}
extern "C" {
    pub fn g_static_rec_mutex_free(mutex: *mut GStaticRecMutex);
}
pub type GStaticRWLock = _GStaticRWLock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStaticRWLock {
    pub mutex: GStaticMutex,
    pub read_cond: *mut GCond,
    pub write_cond: *mut GCond,
    pub read_counter: guint,
    pub have_writer: gboolean,
    pub want_to_read: guint,
    pub want_to_write: guint,
}
#[test]
fn bindgen_test_layout__GStaticRWLock() {
    const UNINIT: ::std::mem::MaybeUninit<_GStaticRWLock> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GStaticRWLock>(),
        40usize,
        concat!("Size of: ", stringify!(_GStaticRWLock))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticRWLock>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticRWLock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_cond) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(read_cond)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_cond) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(write_cond)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_counter) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(read_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).have_writer) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(have_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).want_to_read) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(want_to_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).want_to_write) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(want_to_write)
        )
    );
}
extern "C" {
    pub fn g_static_rw_lock_init(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_reader_lock(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_reader_trylock(lock: *mut GStaticRWLock) -> gboolean;
}
extern "C" {
    pub fn g_static_rw_lock_reader_unlock(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_writer_lock(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_writer_trylock(lock: *mut GStaticRWLock) -> gboolean;
}
extern "C" {
    pub fn g_static_rw_lock_writer_unlock(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_free(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_private_new(notify: GDestroyNotify) -> *mut GPrivate;
}
pub type GStaticPrivate = _GStaticPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStaticPrivate {
    pub index: guint,
}
#[test]
fn bindgen_test_layout__GStaticPrivate() {
    const UNINIT: ::std::mem::MaybeUninit<_GStaticPrivate> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GStaticPrivate>(),
        4usize,
        concat!("Size of: ", stringify!(_GStaticPrivate))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticPrivate>(),
        4usize,
        concat!("Alignment of ", stringify!(_GStaticPrivate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticPrivate),
            "::",
            stringify!(index)
        )
    );
}
extern "C" {
    pub fn g_static_private_init(private_key: *mut GStaticPrivate);
}
extern "C" {
    pub fn g_static_private_get(private_key: *mut GStaticPrivate) -> gpointer;
}
extern "C" {
    pub fn g_static_private_set(
        private_key: *mut GStaticPrivate,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_static_private_free(private_key: *mut GStaticPrivate);
}
extern "C" {
    pub fn g_once_init_enter_impl(location: *mut gsize) -> gboolean;
}
extern "C" {
    pub fn g_thread_init(vtable: gpointer);
}
extern "C" {
    pub fn g_thread_init_with_errorcheck_mutexes(vtable: gpointer);
}
extern "C" {
    pub fn g_thread_get_initialized() -> gboolean;
}
extern "C" {
    pub static mut g_threads_got_initialized: gboolean;
}
extern "C" {
    pub fn g_mutex_new() -> *mut GMutex;
}
extern "C" {
    pub fn g_mutex_free(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_cond_new() -> *mut GCond;
}
extern "C" {
    pub fn g_cond_free(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_timed_wait(
        cond: *mut GCond,
        mutex: *mut GMutex,
        timeval: *mut GTimeVal,
    ) -> gboolean;
}
pub type GAsyncQueue_autoptr = *mut GAsyncQueue;
pub type GAsyncQueue_listautoptr = *mut GList;
pub type GAsyncQueue_slistautoptr = *mut GSList;
pub type GAsyncQueue_queueautoptr = *mut GQueue;
pub type GBookmarkFile_autoptr = *mut GBookmarkFile;
pub type GBookmarkFile_listautoptr = *mut GList;
pub type GBookmarkFile_slistautoptr = *mut GSList;
pub type GBookmarkFile_queueautoptr = *mut GQueue;
pub type GBytes_autoptr = *mut GBytes;
pub type GBytes_listautoptr = *mut GList;
pub type GBytes_slistautoptr = *mut GSList;
pub type GBytes_queueautoptr = *mut GQueue;
pub type GChecksum_autoptr = *mut GChecksum;
pub type GChecksum_listautoptr = *mut GList;
pub type GChecksum_slistautoptr = *mut GSList;
pub type GChecksum_queueautoptr = *mut GQueue;
pub type GDateTime_autoptr = *mut GDateTime;
pub type GDateTime_listautoptr = *mut GList;
pub type GDateTime_slistautoptr = *mut GSList;
pub type GDateTime_queueautoptr = *mut GQueue;
pub type GDate_autoptr = *mut GDate;
pub type GDate_listautoptr = *mut GList;
pub type GDate_slistautoptr = *mut GSList;
pub type GDate_queueautoptr = *mut GQueue;
pub type GDir_autoptr = *mut GDir;
pub type GDir_listautoptr = *mut GList;
pub type GDir_slistautoptr = *mut GSList;
pub type GDir_queueautoptr = *mut GQueue;
pub type GError_autoptr = *mut GError;
pub type GError_listautoptr = *mut GList;
pub type GError_slistautoptr = *mut GSList;
pub type GError_queueautoptr = *mut GQueue;
pub type GHashTable_autoptr = *mut GHashTable;
pub type GHashTable_listautoptr = *mut GList;
pub type GHashTable_slistautoptr = *mut GSList;
pub type GHashTable_queueautoptr = *mut GQueue;
pub type GHmac_autoptr = *mut GHmac;
pub type GHmac_listautoptr = *mut GList;
pub type GHmac_slistautoptr = *mut GSList;
pub type GHmac_queueautoptr = *mut GQueue;
pub type GIOChannel_autoptr = *mut GIOChannel;
pub type GIOChannel_listautoptr = *mut GList;
pub type GIOChannel_slistautoptr = *mut GSList;
pub type GIOChannel_queueautoptr = *mut GQueue;
pub type GKeyFile_autoptr = *mut GKeyFile;
pub type GKeyFile_listautoptr = *mut GList;
pub type GKeyFile_slistautoptr = *mut GSList;
pub type GKeyFile_queueautoptr = *mut GQueue;
pub type GList_autoptr = *mut GList;
pub type GList_listautoptr = *mut GList;
pub type GList_slistautoptr = *mut GSList;
pub type GList_queueautoptr = *mut GQueue;
pub type GArray_autoptr = *mut GArray;
pub type GArray_listautoptr = *mut GList;
pub type GArray_slistautoptr = *mut GSList;
pub type GArray_queueautoptr = *mut GQueue;
pub type GPtrArray_autoptr = *mut GPtrArray;
pub type GPtrArray_listautoptr = *mut GList;
pub type GPtrArray_slistautoptr = *mut GSList;
pub type GPtrArray_queueautoptr = *mut GQueue;
pub type GByteArray_autoptr = *mut GByteArray;
pub type GByteArray_listautoptr = *mut GList;
pub type GByteArray_slistautoptr = *mut GSList;
pub type GByteArray_queueautoptr = *mut GQueue;
pub type GMainContext_autoptr = *mut GMainContext;
pub type GMainContext_listautoptr = *mut GList;
pub type GMainContext_slistautoptr = *mut GSList;
pub type GMainContext_queueautoptr = *mut GQueue;
pub type GMainContextPusher_autoptr = *mut GMainContextPusher;
pub type GMainContextPusher_listautoptr = *mut GList;
pub type GMainContextPusher_slistautoptr = *mut GSList;
pub type GMainContextPusher_queueautoptr = *mut GQueue;
pub type GMainLoop_autoptr = *mut GMainLoop;
pub type GMainLoop_listautoptr = *mut GList;
pub type GMainLoop_slistautoptr = *mut GSList;
pub type GMainLoop_queueautoptr = *mut GQueue;
pub type GSource_autoptr = *mut GSource;
pub type GSource_listautoptr = *mut GList;
pub type GSource_slistautoptr = *mut GSList;
pub type GSource_queueautoptr = *mut GQueue;
pub type GMappedFile_autoptr = *mut GMappedFile;
pub type GMappedFile_listautoptr = *mut GList;
pub type GMappedFile_slistautoptr = *mut GSList;
pub type GMappedFile_queueautoptr = *mut GQueue;
pub type GMarkupParseContext_autoptr = *mut GMarkupParseContext;
pub type GMarkupParseContext_listautoptr = *mut GList;
pub type GMarkupParseContext_slistautoptr = *mut GSList;
pub type GMarkupParseContext_queueautoptr = *mut GQueue;
pub type GNode_autoptr = *mut GNode;
pub type GNode_listautoptr = *mut GList;
pub type GNode_slistautoptr = *mut GSList;
pub type GNode_queueautoptr = *mut GQueue;
pub type GOptionContext_autoptr = *mut GOptionContext;
pub type GOptionContext_listautoptr = *mut GList;
pub type GOptionContext_slistautoptr = *mut GSList;
pub type GOptionContext_queueautoptr = *mut GQueue;
pub type GOptionGroup_autoptr = *mut GOptionGroup;
pub type GOptionGroup_listautoptr = *mut GList;
pub type GOptionGroup_slistautoptr = *mut GSList;
pub type GOptionGroup_queueautoptr = *mut GQueue;
pub type GPatternSpec_autoptr = *mut GPatternSpec;
pub type GPatternSpec_listautoptr = *mut GList;
pub type GPatternSpec_slistautoptr = *mut GSList;
pub type GPatternSpec_queueautoptr = *mut GQueue;
pub type GQueue_autoptr = *mut GQueue;
pub type GQueue_listautoptr = *mut GList;
pub type GQueue_slistautoptr = *mut GSList;
pub type GQueue_queueautoptr = *mut GQueue;
pub type GRand_autoptr = *mut GRand;
pub type GRand_listautoptr = *mut GList;
pub type GRand_slistautoptr = *mut GSList;
pub type GRand_queueautoptr = *mut GQueue;
pub type GRegex_autoptr = *mut GRegex;
pub type GRegex_listautoptr = *mut GList;
pub type GRegex_slistautoptr = *mut GSList;
pub type GRegex_queueautoptr = *mut GQueue;
pub type GMatchInfo_autoptr = *mut GMatchInfo;
pub type GMatchInfo_listautoptr = *mut GList;
pub type GMatchInfo_slistautoptr = *mut GSList;
pub type GMatchInfo_queueautoptr = *mut GQueue;
pub type GScanner_autoptr = *mut GScanner;
pub type GScanner_listautoptr = *mut GList;
pub type GScanner_slistautoptr = *mut GSList;
pub type GScanner_queueautoptr = *mut GQueue;
pub type GSequence_autoptr = *mut GSequence;
pub type GSequence_listautoptr = *mut GList;
pub type GSequence_slistautoptr = *mut GSList;
pub type GSequence_queueautoptr = *mut GQueue;
pub type GSList_autoptr = *mut GSList;
pub type GSList_listautoptr = *mut GList;
pub type GSList_slistautoptr = *mut GSList;
pub type GSList_queueautoptr = *mut GQueue;
pub type GString_autoptr = *mut GString;
pub type GString_listautoptr = *mut GList;
pub type GString_slistautoptr = *mut GSList;
pub type GString_queueautoptr = *mut GQueue;
pub type GStringChunk_autoptr = *mut GStringChunk;
pub type GStringChunk_listautoptr = *mut GList;
pub type GStringChunk_slistautoptr = *mut GSList;
pub type GStringChunk_queueautoptr = *mut GQueue;
pub type GStrvBuilder_autoptr = *mut GStrvBuilder;
pub type GStrvBuilder_listautoptr = *mut GList;
pub type GStrvBuilder_slistautoptr = *mut GSList;
pub type GStrvBuilder_queueautoptr = *mut GQueue;
pub type GThread_autoptr = *mut GThread;
pub type GThread_listautoptr = *mut GList;
pub type GThread_slistautoptr = *mut GSList;
pub type GThread_queueautoptr = *mut GQueue;
pub type GMutexLocker_autoptr = *mut GMutexLocker;
pub type GMutexLocker_listautoptr = *mut GList;
pub type GMutexLocker_slistautoptr = *mut GSList;
pub type GMutexLocker_queueautoptr = *mut GQueue;
pub type GRecMutexLocker_autoptr = *mut GRecMutexLocker;
pub type GRecMutexLocker_listautoptr = *mut GList;
pub type GRecMutexLocker_slistautoptr = *mut GSList;
pub type GRecMutexLocker_queueautoptr = *mut GQueue;
pub type GRWLockWriterLocker_autoptr = *mut GRWLockWriterLocker;
pub type GRWLockWriterLocker_listautoptr = *mut GList;
pub type GRWLockWriterLocker_slistautoptr = *mut GSList;
pub type GRWLockWriterLocker_queueautoptr = *mut GQueue;
pub type GRWLockReaderLocker_autoptr = *mut GRWLockReaderLocker;
pub type GRWLockReaderLocker_listautoptr = *mut GList;
pub type GRWLockReaderLocker_slistautoptr = *mut GSList;
pub type GRWLockReaderLocker_queueautoptr = *mut GQueue;
pub type GTimer_autoptr = *mut GTimer;
pub type GTimer_listautoptr = *mut GList;
pub type GTimer_slistautoptr = *mut GSList;
pub type GTimer_queueautoptr = *mut GQueue;
pub type GTimeZone_autoptr = *mut GTimeZone;
pub type GTimeZone_listautoptr = *mut GList;
pub type GTimeZone_slistautoptr = *mut GSList;
pub type GTimeZone_queueautoptr = *mut GQueue;
pub type GTree_autoptr = *mut GTree;
pub type GTree_listautoptr = *mut GList;
pub type GTree_slistautoptr = *mut GSList;
pub type GTree_queueautoptr = *mut GQueue;
pub type GVariant_autoptr = *mut GVariant;
pub type GVariant_listautoptr = *mut GList;
pub type GVariant_slistautoptr = *mut GSList;
pub type GVariant_queueautoptr = *mut GQueue;
pub type GVariantBuilder_autoptr = *mut GVariantBuilder;
pub type GVariantBuilder_listautoptr = *mut GList;
pub type GVariantBuilder_slistautoptr = *mut GSList;
pub type GVariantBuilder_queueautoptr = *mut GQueue;
pub type GVariantIter_autoptr = *mut GVariantIter;
pub type GVariantIter_listautoptr = *mut GList;
pub type GVariantIter_slistautoptr = *mut GSList;
pub type GVariantIter_queueautoptr = *mut GQueue;
pub type GVariantDict_autoptr = *mut GVariantDict;
pub type GVariantDict_listautoptr = *mut GList;
pub type GVariantDict_slistautoptr = *mut GSList;
pub type GVariantDict_queueautoptr = *mut GQueue;
pub type GVariantType_autoptr = *mut GVariantType;
pub type GVariantType_listautoptr = *mut GList;
pub type GVariantType_slistautoptr = *mut GSList;
pub type GVariantType_queueautoptr = *mut GQueue;
pub type GRefString_autoptr = *mut GRefString;
pub type GRefString_listautoptr = *mut GList;
pub type GRefString_slistautoptr = *mut GSList;
pub type GRefString_queueautoptr = *mut GQueue;
pub type GUri_autoptr = *mut GUri;
pub type GUri_listautoptr = *mut GList;
pub type GUri_slistautoptr = *mut GSList;
pub type GUri_queueautoptr = *mut GQueue;
pub type GPathBuf_autoptr = *mut GPathBuf;
pub type GPathBuf_listautoptr = *mut GList;
pub type GPathBuf_slistautoptr = *mut GSList;
pub type GPathBuf_queueautoptr = *mut GQueue;
pub type POINTER_64_INT = ::std::os::raw::c_ulonglong;
pub type INT8 = ::std::os::raw::c_schar;
pub type PINT8 = *mut ::std::os::raw::c_schar;
pub type INT16 = ::std::os::raw::c_short;
pub type PINT16 = *mut ::std::os::raw::c_short;
pub type INT32 = ::std::os::raw::c_int;
pub type PINT32 = *mut ::std::os::raw::c_int;
pub type INT64 = ::std::os::raw::c_longlong;
pub type PINT64 = *mut ::std::os::raw::c_longlong;
pub type UINT8 = ::std::os::raw::c_uchar;
pub type PUINT8 = *mut ::std::os::raw::c_uchar;
pub type UINT16 = ::std::os::raw::c_ushort;
pub type PUINT16 = *mut ::std::os::raw::c_ushort;
pub type UINT32 = ::std::os::raw::c_uint;
pub type PUINT32 = *mut ::std::os::raw::c_uint;
pub type UINT64 = ::std::os::raw::c_ulonglong;
pub type PUINT64 = *mut ::std::os::raw::c_ulonglong;
pub type LONG32 = ::std::os::raw::c_int;
pub type PLONG32 = *mut ::std::os::raw::c_int;
pub type ULONG32 = ::std::os::raw::c_uint;
pub type PULONG32 = *mut ::std::os::raw::c_uint;
pub type DWORD32 = ::std::os::raw::c_uint;
pub type PDWORD32 = *mut ::std::os::raw::c_uint;
pub type INT_PTR = ::std::os::raw::c_longlong;
pub type PINT_PTR = *mut ::std::os::raw::c_longlong;
pub type UINT_PTR = ::std::os::raw::c_ulonglong;
pub type PUINT_PTR = *mut ::std::os::raw::c_ulonglong;
pub type LONG_PTR = ::std::os::raw::c_longlong;
pub type PLONG_PTR = *mut ::std::os::raw::c_longlong;
pub type ULONG_PTR = ::std::os::raw::c_ulonglong;
pub type PULONG_PTR = *mut ::std::os::raw::c_ulonglong;
pub type PHANDLE64 = *mut *mut ::std::os::raw::c_void;
pub type SHANDLE_PTR = ::std::os::raw::c_longlong;
pub type HANDLE_PTR = ::std::os::raw::c_ulonglong;
pub type UHALF_PTR = ::std::os::raw::c_uint;
pub type PUHALF_PTR = *mut ::std::os::raw::c_uint;
pub type HALF_PTR = ::std::os::raw::c_int;
pub type PHALF_PTR = *mut ::std::os::raw::c_int;
pub type SIZE_T = ULONG_PTR;
pub type PSIZE_T = *mut ULONG_PTR;
pub type SSIZE_T = LONG_PTR;
pub type PSSIZE_T = *mut LONG_PTR;
pub type DWORD_PTR = ULONG_PTR;
pub type PDWORD_PTR = *mut ULONG_PTR;
pub type LONG64 = ::std::os::raw::c_longlong;
pub type PLONG64 = *mut ::std::os::raw::c_longlong;
pub type ULONG64 = ::std::os::raw::c_ulonglong;
pub type PULONG64 = *mut ::std::os::raw::c_ulonglong;
pub type DWORD64 = ::std::os::raw::c_ulonglong;
pub type PDWORD64 = *mut ::std::os::raw::c_ulonglong;
pub type KAFFINITY = ULONG_PTR;
pub type PKAFFINITY = *mut KAFFINITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _iobuf {
    pub _Placeholder: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__iobuf() {
    const UNINIT: ::std::mem::MaybeUninit<_iobuf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_iobuf>(),
        8usize,
        concat!("Size of: ", stringify!(_iobuf))
    );
    assert_eq!(
        ::std::mem::align_of::<_iobuf>(),
        8usize,
        concat!("Alignment of ", stringify!(_iobuf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Placeholder) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_iobuf),
            "::",
            stringify!(_Placeholder)
        )
    );
}
pub type FILE = _iobuf;
extern "C" {
    pub fn __acrt_iob_func(_Ix: ::std::os::raw::c_uint) -> *mut FILE;
}
extern "C" {
    pub fn fgetwc(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fgetwchar() -> wint_t;
}
extern "C" {
    pub fn fputwc(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwchar(_Character: wchar_t) -> wint_t;
}
extern "C" {
    pub fn getwc(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn fgetws(
        _Buffer: *mut wchar_t,
        _BufferCount: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn fputws(_Buffer: *const wchar_t, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getws_s(_Buffer: *mut wchar_t, _BufferCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn putwc(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(_Character: wchar_t) -> wint_t;
}
extern "C" {
    pub fn _putws(_Buffer: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetwc(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _wfdopen(_FileHandle: ::std::os::raw::c_int, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wfopen(_FileName: *const wchar_t, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wfopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wfreopen(
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _OldStream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _wfreopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _OldStream: *mut FILE,
    ) -> errno_t;
}
extern "C" {
    pub fn _wfsopen(
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _ShFlag: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _wpopen(_Command: *const wchar_t, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wremove(_FileName: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtempnam(_Directory: *const wchar_t, _FilePrefix: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wtmpnam_s(_Buffer: *mut wchar_t, _BufferCount: usize) -> errno_t;
}
extern "C" {
    pub fn _wtmpnam(_Buffer: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _fgetwc_nolock(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwc_nolock(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _getwc_nolock(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _putwc_nolock(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _ungetwc_nolock(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn __stdio_common_vfwprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsnwprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *const wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = ::std::os::raw::c_longlong;
extern "C" {
    pub fn _get_stream_buffer_pointers(
        _Stream: *mut FILE,
        _Base: *mut *mut *mut ::std::os::raw::c_char,
        _Pointer: *mut *mut *mut ::std::os::raw::c_char,
        _Count: *mut *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn clearerr_s(_Stream: *mut FILE) -> errno_t;
}
extern "C" {
    pub fn fopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn fread_s(
        _Buffer: *mut ::std::os::raw::c_void,
        _BufferSize: usize,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn freopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _OldStream: *mut FILE,
    ) -> errno_t;
}
extern "C" {
    pub fn gets_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _Size: rsize_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpfile_s(_Stream: *mut *mut FILE) -> errno_t;
}
extern "C" {
    pub fn tmpnam_s(_Buffer: *mut ::std::os::raw::c_char, _Size: rsize_t) -> errno_t;
}
extern "C" {
    pub fn clearerr(_Stream: *mut FILE);
}
extern "C" {
    pub fn fclose(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fdopen(
        _FileHandle: ::std::os::raw::c_int,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn feof(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(_Stream: *mut FILE, _Position: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        _Buffer: *mut ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fileno(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _flushall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fputc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputchar(_Character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(
        _Buffer: *const ::std::os::raw::c_char,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        _Buffer: *mut ::std::os::raw::c_void,
        _ElementSize: ::std::os::raw::c_ulonglong,
        _ElementCount: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn freopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _Stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fsopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _ShFlag: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fsetpos(_Stream: *mut FILE, _Position: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_long,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fseeki64(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_longlong,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(_Stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _ftelli64(_Stream: *mut FILE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fwrite(
        _Buffer: *const ::std::os::raw::c_void,
        _ElementSize: ::std::os::raw::c_ulonglong,
        _ElementCount: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn getc(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getmaxstdio() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getw(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _pclose(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _popen(
        _Command: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn putc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(_Character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(_Buffer: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putw(_Word: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        _OldFileName: *const ::std::os::raw::c_char,
        _NewFileName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _unlink(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlink(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(_Stream: *mut FILE);
}
extern "C" {
    pub fn _rmtmp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(_Stream: *mut FILE, _Buffer: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn _setmaxstdio(_Maximum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setvbuf(
        _Stream: *mut FILE,
        _Buffer: *mut ::std::os::raw::c_char,
        _Mode: ::std::os::raw::c_int,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tempnam(
        _DirectoryName: *const ::std::os::raw::c_char,
        _FilePrefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _lock_file(_Stream: *mut FILE);
}
extern "C" {
    pub fn _unlock_file(_Stream: *mut FILE);
}
extern "C" {
    pub fn _fclose_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fflush_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetc_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fread_nolock(
        _Buffer: *mut ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fread_nolock_s(
        _Buffer: *mut ::std::os::raw::c_void,
        _BufferSize: usize,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fseek_nolock(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_long,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fseeki64_nolock(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_longlong,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ftell_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _ftelli64_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _fwrite_nolock(
        _Buffer: *const ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _getc_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ungetc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p__commode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_printf_count_output(_Value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_printf_count_output() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _Arglist: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsnprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *const ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        _Directory: *const ::std::os::raw::c_char,
        _FilePrefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdopen(
        _FileHandle: ::std::os::raw::c_int,
        _Format: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flushall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputchar(_Ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(_Ch: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmtmp() -> ::std::os::raw::c_int;
}
pub const ws_log_level_LOG_LEVEL_NONE: ws_log_level = 0;
pub const ws_log_level_LOG_LEVEL_NOISY: ws_log_level = 1;
pub const ws_log_level_LOG_LEVEL_DEBUG: ws_log_level = 2;
pub const ws_log_level_LOG_LEVEL_INFO: ws_log_level = 3;
pub const ws_log_level_LOG_LEVEL_MESSAGE: ws_log_level = 4;
pub const ws_log_level_LOG_LEVEL_WARNING: ws_log_level = 5;
pub const ws_log_level_LOG_LEVEL_CRITICAL: ws_log_level = 6;
pub const ws_log_level_LOG_LEVEL_ERROR: ws_log_level = 7;
pub const ws_log_level_LOG_LEVEL_ECHO: ws_log_level = 8;
pub const ws_log_level__LOG_LEVEL_LAST: ws_log_level = 9;
pub type ws_log_level = ::std::os::raw::c_int;
pub const ws_log_console_open_pref_LOG_CONSOLE_OPEN_NEVER: ws_log_console_open_pref = 0;
pub const ws_log_console_open_pref_LOG_CONSOLE_OPEN_AUTO: ws_log_console_open_pref = 1;
pub const ws_log_console_open_pref_LOG_CONSOLE_OPEN_ALWAYS: ws_log_console_open_pref = 2;
pub type ws_log_console_open_pref = ::std::os::raw::c_int;
extern "C" {
    pub static mut ws_log_console_open: ws_log_console_open_pref;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ws_log_manifest_t {
    pub tstamp_secs: tm,
    pub nanosecs: ::std::os::raw::c_long,
    pub pid: intmax_t,
}
#[test]
fn bindgen_test_layout_ws_log_manifest_t() {
    const UNINIT: ::std::mem::MaybeUninit<ws_log_manifest_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ws_log_manifest_t>(),
        48usize,
        concat!("Size of: ", stringify!(ws_log_manifest_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ws_log_manifest_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ws_log_manifest_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tstamp_secs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ws_log_manifest_t),
            "::",
            stringify!(tstamp_secs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nanosecs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ws_log_manifest_t),
            "::",
            stringify!(nanosecs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pid) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ws_log_manifest_t),
            "::",
            stringify!(pid)
        )
    );
}
#[doc = " Callback for registering a log writer."]
pub type ws_log_writer_cb = ::std::option::Option<
    unsafe extern "C" fn(
        domain: *const ::std::os::raw::c_char,
        level: ws_log_level,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_long,
        func: *const ::std::os::raw::c_char,
        fatal_msg: *const ::std::os::raw::c_char,
        mft: *mut ws_log_manifest_t,
        user_format: *const ::std::os::raw::c_char,
        user_ap: va_list,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Callback for freeing a user data pointer."]
pub type ws_log_writer_free_data_cb =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn ws_log_file_writer(
        fp: *mut FILE,
        domain: *const ::std::os::raw::c_char,
        level: ws_log_level,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_long,
        func: *const ::std::os::raw::c_char,
        mft: *mut ws_log_manifest_t,
        user_format: *const ::std::os::raw::c_char,
        user_ap: va_list,
    );
}
extern "C" {
    pub fn ws_log_console_writer(
        domain: *const ::std::os::raw::c_char,
        level: ws_log_level,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_long,
        func: *const ::std::os::raw::c_char,
        mft: *mut ws_log_manifest_t,
        user_format: *const ::std::os::raw::c_char,
        user_ap: va_list,
    );
}
extern "C" {
    #[doc = " Configure log levels \"info\" and below to use stdout.\n\n Normally all log messages are written to stderr. For backward compatibility\n with GLib calling this function with true configures log levels \"info\",\n \"debug\" and \"noisy\" to be written to stdout."]
    pub fn ws_log_console_writer_set_use_stdout(use_stdout: bool);
}
extern "C" {
    #[doc = " Convert a numerical level to its string representation."]
    pub fn ws_log_level_to_string(level: ws_log_level) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Checks if a domain and level combination generate output.\n\n Returns true if a message will be printed for the domain/level combo."]
    pub fn ws_log_msg_is_active(domain: *const ::std::os::raw::c_char, level: ws_log_level)
        -> bool;
}
extern "C" {
    #[doc = " Return the currently active log level."]
    pub fn ws_log_get_level() -> ws_log_level;
}
extern "C" {
    #[doc = " Set the active log level. Returns the active level or LOG_LEVEL_NONE\n if level is invalid."]
    pub fn ws_log_set_level(level: ws_log_level) -> ws_log_level;
}
extern "C" {
    #[doc = " Set the active log level from a string.\n\n String levels are \"error\", \"critical\", \"warning\", \"message\", \"info\",\n \"debug\" and \"noisy\" (case insensitive).\n Returns the new log level or LOG_LEVEL NONE if the string representation\n is invalid."]
    pub fn ws_log_set_level_str(str_level: *const ::std::os::raw::c_char) -> ws_log_level;
}
extern "C" {
    #[doc = " Set a domain filter from a string.\n\n Domain filter is a case insensitive list separated by ',' or ';'. Only\n the domains in the filter will generate output; the others will be muted.\n Filter expressions can be preceded by '!' to invert the sense of the match.\n In this case only non-matching domains will generate output."]
    pub fn ws_log_set_domain_filter(domain_filter: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Set a fatal domain filter from a string.\n\n Domain filter is a case insensitive list separated by ',' or ';'. Domains\n in the filter will cause the program to abort."]
    pub fn ws_log_set_fatal_domain_filter(domain_filter: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Set a debug filter from a string.\n\n A debug filter lists all domains that should have debug level output turned\n on, regardless of the global log level and domain filter. If negated\n then debug (and below) will be disabled and the others unaffected by\n the filter."]
    pub fn ws_log_set_debug_filter(str_filter: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Set a noisy filter from a string.\n\n Same as ws_log_set_debug_filter() for \"noisy\" level."]
    pub fn ws_log_set_noisy_filter(str_filter: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Set the fatal log level.\n\n Sets the log level at which calls to ws_log() will abort the program. The\n argument can be LOG_LEVEL_ERROR, LOG_LEVEL_CRITICAL or LOG_LEVEL_WARNING.\n Level LOG_LEVEL_ERROR is always fatal."]
    pub fn ws_log_set_fatal_level(level: ws_log_level) -> ws_log_level;
}
extern "C" {
    #[doc = " Set the fatal log level from a string.\n\n Same as ws_log_set_fatal(), but accepts the strings \"error\", critical\" or\n \"warning\" instead as arguments."]
    pub fn ws_log_set_fatal_level_str(str_level: *const ::std::os::raw::c_char) -> ws_log_level;
}
extern "C" {
    #[doc = " Set the active log writer.\n\n The parameter 'writer' can be NULL to use the default writer."]
    pub fn ws_log_set_writer(writer: ws_log_writer_cb);
}
extern "C" {
    #[doc = " Set the active log writer.\n\n The parameter 'writer' can be NULL to use the default writer.\n Accepts an extra user_data parameter that will be passed to\n the log writer."]
    pub fn ws_log_set_writer_with_data(
        writer: ws_log_writer_cb,
        user_data: *mut ::std::os::raw::c_void,
        free_user_data: ws_log_writer_free_data_cb,
    );
}
extern "C" {
    #[doc = " Parses the command line arguments for log options.\n\n Returns zero for no error, non-zero for one or more invalid options."]
    pub fn ws_log_parse_args(
        argc_ptr: *mut ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        vcmdarg_err: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char, ap: va_list),
        >,
        exit_failure: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initializes the logging code.\n\n Must be called at startup before using the log API. If provided\n vcmdarg_err is used to print initialization errors. This usually means\n a misconfigured environment variable."]
    pub fn ws_log_init(
        progname: *const ::std::os::raw::c_char,
        vcmdarg_err: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char, ap: va_list),
        >,
    );
}
extern "C" {
    #[doc = " Initializes the logging code.\n\n Can be used instead of wslog_init(). Takes an extra writer argument.\n If provided this callback will be used instead of the default writer."]
    pub fn ws_log_init_with_writer(
        progname: *const ::std::os::raw::c_char,
        writer: ws_log_writer_cb,
        vcmdarg_err: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char, ap: va_list),
        >,
    );
}
extern "C" {
    #[doc = " Initializes the logging code.\n\n Accepts a user data pointer in addition to the writer. This pointer will\n be provided to the writer with every invocation. If provided\n free_user_data will be called during cleanup."]
    pub fn ws_log_init_with_writer_and_data(
        progname: *const ::std::os::raw::c_char,
        writer: ws_log_writer_cb,
        user_data: *mut ::std::os::raw::c_void,
        free_user_data: ws_log_writer_free_data_cb,
        vcmdarg_err: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char, ap: va_list),
        >,
    );
}
extern "C" {
    #[doc = " This function is called to output a message to the log.\n\n Takes a format string and a variable number of arguments."]
    pub fn ws_log(
        domain: *const ::std::os::raw::c_char,
        level: ws_log_level,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " This function is called to output a message to the log.\n\n Takes a format string and a 'va_list'."]
    pub fn ws_logv(
        domain: *const ::std::os::raw::c_char,
        level: ws_log_level,
        format: *const ::std::os::raw::c_char,
        ap: va_list,
    );
}
extern "C" {
    #[doc = " This function is called to output a message to the log.\n\n In addition to the message this function accepts file/line/function\n information."]
    pub fn ws_log_full(
        domain: *const ::std::os::raw::c_char,
        level: ws_log_level,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_long,
        func: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " This function is called to output a message to the log.\n\n In addition to the message this function accepts file/line/function\n information."]
    pub fn ws_logv_full(
        domain: *const ::std::os::raw::c_char,
        level: ws_log_level,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_long,
        func: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ap: va_list,
    );
}
extern "C" {
    pub fn ws_log_fatal_full(
        domain: *const ::std::os::raw::c_char,
        level: ws_log_level,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_long,
        func: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn ws_log_utf8_full(
        domain: *const ::std::os::raw::c_char,
        level: ws_log_level,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_long,
        func: *const ::std::os::raw::c_char,
        string: *const ::std::os::raw::c_char,
        length: isize,
        endptr: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " This function is called to log a buffer (bytes array).\n\n Accepts an optional 'msg' argument to provide a description."]
    pub fn ws_log_buffer_full(
        domain: *const ::std::os::raw::c_char,
        level: ws_log_level,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_long,
        func: *const ::std::os::raw::c_char,
        buffer: *const u8,
        size: usize,
        max_bytes_len: usize,
        msg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Auxiliary function to write custom logging functions.\n\n This function is the same as ws_log_full() but does not perform any\n domain/level filtering to avoid a useless double activation check.\n It should only be used in conjunction with a pre-check using\n ws_log_msg_is_active()."]
    pub fn ws_log_write_always_full(
        domain: *const ::std::os::raw::c_char,
        level: ws_log_level,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_long,
        func: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " Define an auxiliary file pointer where messages should be written.\n\n This file, if set, functions in addition to the registered or\n default log writer."]
    pub fn ws_log_add_custom_file(fp: *mut FILE);
}
extern "C" {
    pub fn ws_log_print_usage(fp: *mut FILE);
}
#[doc = " @defgroup wmem Wireshark Memory Manager\n\n Wmem is a memory management framework for Wireshark that makes it simple to\n write dissectors (and other 'user-space' code) that doesn't leak memory. The\n core module provides basic functions like malloc, realloc and free, but\n many other functions are available (see the \"Modules\" list at the top of\n the generated doxygen HTML).\n\n Any wmem functions which allocate memory are guaranteed to either succeed or\n abort the program. However, they *can* still legally return NULL when the\n amount of requested memory is zero.\n\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_allocator_t {
    _unused: [u8; 0],
}
#[doc = " A public opaque type representing one wmem allocation pool."]
pub type wmem_allocator_t = _wmem_allocator_t;
#[doc = "< A trivial allocator that mallocs requested\nmemory and tracks allocations via a hash table. As simple as\npossible, intended more as a demo than for practical usage. Also\nhas the benefit of being friendly to tools like valgrind."]
pub const _wmem_allocator_type_t_WMEM_ALLOCATOR_SIMPLE: _wmem_allocator_type_t = 0;
#[doc = "< A block allocator that grabs large chunks of\nmemory at a time (8 MB currently) and serves allocations out of\nthose chunks. Designed for efficiency, especially in the\nfree_all operation."]
pub const _wmem_allocator_type_t_WMEM_ALLOCATOR_BLOCK: _wmem_allocator_type_t = 1;
#[doc = "< An allocator that does its best to find invalid\nmemory usage via things like canaries and scrubbing freed\nmemory. Valgrind is the better choice on platforms that support\nit."]
pub const _wmem_allocator_type_t_WMEM_ALLOCATOR_STRICT: _wmem_allocator_type_t = 2;
#[doc = "< A block allocator like WMEM_ALLOCATOR_BLOCK\nbut even faster by tracking absolutely minimal metadata and\nmaking 'free' a no-op. Useful only for very short-lived scopes\nwhere there's no reason to free individual allocations because\nthe next free_all is always just around the corner."]
pub const _wmem_allocator_type_t_WMEM_ALLOCATOR_BLOCK_FAST: _wmem_allocator_type_t = 3;
#[doc = " An enumeration of the different types of available allocators."]
pub type _wmem_allocator_type_t = ::std::os::raw::c_int;
#[doc = " An enumeration of the different types of available allocators."]
pub use self::_wmem_allocator_type_t as wmem_allocator_type_t;
extern "C" {
    #[doc = " Allocate the requested amount of memory in the given pool.\n\n @param allocator The allocator object to use to allocate the memory.\n @param size The amount of memory to allocate.\n @return A void pointer to the newly allocated memory."]
    pub fn wmem_alloc(allocator: *mut wmem_allocator_t, size: usize)
        -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate the requested amount of memory in the given pool. Initializes the\n allocated memory with zeroes.\n\n @param allocator The allocator object to use to allocate the memory.\n @param size The amount of memory to allocate.\n @return A void pointer to the newly allocated and zeroed memory."]
    pub fn wmem_alloc0(
        allocator: *mut wmem_allocator_t,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Returns the allocated memory to the allocator. This function should only\n be called directly by allocators when the allocated block is sufficiently\n large that the reduced memory usage is worth the cost of the extra function\n call. It's usually easier to just let it get cleaned up when wmem_free_all()\n is called.\n\n @param allocator The allocator object used to originally allocate the memory.\n @param ptr The pointer to the memory block to free. After this function\n returns it no longer points to valid memory."]
    pub fn wmem_free(allocator: *mut wmem_allocator_t, ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Resizes a block of memory, potentially moving it if resizing it in place\n is not possible.\n\n @param allocator The allocator object used to originally allocate the memory.\n @param ptr The pointer to the memory block to resize.\n @param size The new size for the memory block.\n @return The new location of the memory block. If this is different from ptr\n then ptr no longer points to valid memory."]
    pub fn wmem_realloc(
        allocator: *mut wmem_allocator_t,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Frees all the memory allocated in a pool. Depending on the allocator\n implementation used this can be significantly cheaper than calling\n wmem_free() on all the individual blocks. It also doesn't require you to have\n external pointers to those blocks.\n\n @param allocator The allocator to free the memory from."]
    pub fn wmem_free_all(allocator: *mut wmem_allocator_t);
}
extern "C" {
    #[doc = " Triggers a garbage-collection in the allocator. This does not free any\n memory, but it can return unused blocks to the operating system or perform\n other optimizations.\n\n @param allocator The allocator in which to trigger the garbage collection."]
    pub fn wmem_gc(allocator: *mut wmem_allocator_t);
}
extern "C" {
    #[doc = " Destroy the given allocator, freeing all memory allocated in it. Once this\n function has been called, no memory allocated with the allocator is valid.\n\n @param allocator The allocator to destroy."]
    pub fn wmem_destroy_allocator(allocator: *mut wmem_allocator_t);
}
extern "C" {
    #[doc = " Create a new allocator of the given type. The type may be overridden by the\n WIRESHARK_DEBUG_WMEM_OVERRIDE environment variable.\n\n @param type The type of allocator to create.\n @return The new allocator."]
    pub fn wmem_allocator_new(type_: wmem_allocator_type_t) -> *mut wmem_allocator_t;
}
extern "C" {
    #[doc = " Initialize the wmem subsystem. This must be called before any other wmem\n function, usually at the very beginning of your program."]
    pub fn wmem_init();
}
extern "C" {
    #[doc = " Teardown the wmem subsystem. This must be called after all other wmem\n functions, usually at the very end of your program. This function will not\n destroy outstanding allocators, you must do that yourself."]
    pub fn wmem_cleanup();
}
extern "C" {
    pub fn wmem_enter_scope(allocator: *mut wmem_allocator_t);
}
extern "C" {
    pub fn wmem_leave_scope(allocator: *mut wmem_allocator_t);
}
extern "C" {
    pub fn wmem_in_scope(allocator: *mut wmem_allocator_t) -> bool;
}
#[doc = " @addtogroup wmem\n  @{\n    @defgroup wmem-array Array\n\n    A resizable array implementation on top of wmem.\n\n    @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_array_t {
    _unused: [u8; 0],
}
pub type wmem_array_t = _wmem_array_t;
extern "C" {
    pub fn wmem_array_sized_new(
        allocator: *mut wmem_allocator_t,
        elem_size: usize,
        alloc_count: ::std::os::raw::c_uint,
    ) -> *mut wmem_array_t;
}
extern "C" {
    pub fn wmem_array_new(allocator: *mut wmem_allocator_t, elem_size: usize) -> *mut wmem_array_t;
}
extern "C" {
    pub fn wmem_array_grow(array: *mut wmem_array_t, to_add: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn wmem_array_set_null_terminator(array: *mut wmem_array_t);
}
extern "C" {
    pub fn wmem_array_bzero(array: *mut wmem_array_t);
}
extern "C" {
    pub fn wmem_array_append(
        array: *mut wmem_array_t,
        in_: *const ::std::os::raw::c_void,
        count: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn wmem_array_index(
        array: *mut wmem_array_t,
        array_index: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn wmem_array_try_index(
        array: *mut wmem_array_t,
        array_index: ::std::os::raw::c_uint,
        val: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmem_array_sort(
        array: *mut wmem_array_t,
        compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn wmem_array_get_raw(array: *mut wmem_array_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn wmem_array_get_count(array: *mut wmem_array_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn wmem_array_finalize(array: *mut wmem_array_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn wmem_destroy_array(array: *mut wmem_array_t);
}
#[doc = " @addtogroup wmem\n  @{\n    @defgroup wmem-list Doubly-Linked List\n\n    A doubly-linked list implementation on top of wmem.\n\n    @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_list_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_list_frame_t {
    _unused: [u8; 0],
}
pub type wmem_list_t = _wmem_list_t;
pub type wmem_list_frame_t = _wmem_list_frame_t;
extern "C" {
    pub fn wmem_list_count(list: *const wmem_list_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn wmem_list_head(list: *const wmem_list_t) -> *mut wmem_list_frame_t;
}
extern "C" {
    pub fn wmem_list_tail(list: *const wmem_list_t) -> *mut wmem_list_frame_t;
}
extern "C" {
    pub fn wmem_list_frame_next(frame: *const wmem_list_frame_t) -> *mut wmem_list_frame_t;
}
extern "C" {
    pub fn wmem_list_frame_prev(frame: *const wmem_list_frame_t) -> *mut wmem_list_frame_t;
}
extern "C" {
    pub fn wmem_list_frame_data(frame: *const wmem_list_frame_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn wmem_list_remove(list: *mut wmem_list_t, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn wmem_list_remove_frame(list: *mut wmem_list_t, frame: *mut wmem_list_frame_t);
}
extern "C" {
    pub fn wmem_list_find(
        list: *mut wmem_list_t,
        data: *const ::std::os::raw::c_void,
    ) -> *mut wmem_list_frame_t;
}
extern "C" {
    pub fn wmem_list_find_custom(
        list: *mut wmem_list_t,
        data: *const ::std::os::raw::c_void,
        func: GCompareFunc,
    ) -> *mut wmem_list_frame_t;
}
extern "C" {
    pub fn wmem_list_prepend(list: *mut wmem_list_t, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn wmem_list_append(list: *mut wmem_list_t, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn wmem_list_insert_sorted(
        list: *mut wmem_list_t,
        data: *mut ::std::os::raw::c_void,
        func: GCompareFunc,
    );
}
extern "C" {
    pub fn wmem_list_new(allocator: *mut wmem_allocator_t) -> *mut wmem_list_t;
}
extern "C" {
    pub fn wmem_list_foreach(
        list: *mut wmem_list_t,
        foreach_func: GFunc,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn wmem_destroy_list(list: *mut wmem_list_t);
}
#[doc = " @addtogroup wmem\n  @{\n    @defgroup wmem-map Hash Map\n\n    A hash map implementation on top of wmem. Provides insertion, deletion and\n    lookup in expected amortized constant time. Uses universal hashing to map\n    keys into buckets, and provides a generic strong hash function that makes\n    it secure against algorithmic complexity attacks, and suitable for use\n    even with untrusted data.\n\n    @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_map_t {
    _unused: [u8; 0],
}
pub type wmem_map_t = _wmem_map_t;
extern "C" {
    #[doc = " Creates a map with the given allocator scope. When the scope is emptied,\n the map is fully destroyed. Items stored in it will not be freed unless they\n were allocated from the same scope. For details on the GHashFunc and\n GEqualFunc parameters, see the glib documentation at:\n https://developer-old.gnome.org/glib/stable/glib-Hash-Tables.html\n\n If the keys are coming from untrusted data, do *not* use glib's default hash\n functions for strings, int64s or doubles. Wmem provides stronger equivalents\n below. Feel free to use the g_direct_hash, g_int_hash, and any of the\n g_*_equal functions though, as they should be safe.\n\n @param allocator The allocator scope with which to create the map.\n @param hash_func The hash function used to place inserted keys.\n @param eql_func  The equality function used to compare inserted keys.\n @return The newly-allocated map."]
    pub fn wmem_map_new(
        allocator: *mut wmem_allocator_t,
        hash_func: GHashFunc,
        eql_func: GEqualFunc,
    ) -> *mut wmem_map_t;
}
extern "C" {
    #[doc = " Creates a map with two allocator scopes. The base structure lives in the\n metadata scope, and the map data lives in the data scope. Every time free_all\n occurs in the data scope the map is transparently emptied without affecting\n the location of the base / metadata structure.\n\n WARNING: None of the map (even the part in the metadata scope) can be used\n after the data scope has been *destroyed*.\n\n The primary use for this function is to create maps that reset for each new\n capture file that is loaded. This can be done by specifying wmem_epan_scope()\n as the metadata scope and wmem_file_scope() as the data scope."]
    pub fn wmem_map_new_autoreset(
        metadata_scope: *mut wmem_allocator_t,
        data_scope: *mut wmem_allocator_t,
        hash_func: GHashFunc,
        eql_func: GEqualFunc,
    ) -> *mut wmem_map_t;
}
extern "C" {
    #[doc = " Inserts a value into the map.\n\n @param map The map to insert into. Must not be NULL.\n @param key The key to insert by.\n @param value The value to insert.\n @return The previous value stored at this key if any, or NULL."]
    pub fn wmem_map_insert(
        map: *mut wmem_map_t,
        key: *const ::std::os::raw::c_void,
        value: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Check if a value is in the map.\n\n @param map The map to search in. May be NULL.\n @param key The key to lookup.\n @return true if the key is in the map, otherwise false."]
    pub fn wmem_map_contains(map: *mut wmem_map_t, key: *const ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " Lookup a value in the map.\n\n @param map The map to search in. May be NULL.\n @param key The key to lookup.\n @return The value stored at the key if any, or NULL."]
    pub fn wmem_map_lookup(
        map: *mut wmem_map_t,
        key: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Lookup a value in the map, returning the key, value, and a boolean which\n is true if the key is found.\n\n @param map The map to search in. May be NULL.\n @param key The key to lookup.\n @param orig_key (optional) The key that was determined to be a match, if any.\n @param value (optional) The value stored at the key, if any.\n @return true if the key is in the map, otherwise false."]
    pub fn wmem_map_lookup_extended(
        map: *mut wmem_map_t,
        key: *const ::std::os::raw::c_void,
        orig_key: *mut *const ::std::os::raw::c_void,
        value: *mut *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Remove a value from the map. If no value is stored at that key, nothing\n happens.\n\n @param map The map to remove from. May be NULL.\n @param key The key of the value to remove.\n @return The (removed) value stored at the key if any, or NULL."]
    pub fn wmem_map_remove(
        map: *mut wmem_map_t,
        key: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Remove a key and value from the map but does not destroy (free) them. If no\n value is stored at that key, nothing happens.\n\n @param map The map to remove from. May be NULL.\n @param key The key of the value to remove.\n @return true if key is found false if not."]
    pub fn wmem_map_steal(map: *mut wmem_map_t, key: *const ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " Retrieves a list of keys inside the map\n\n @param list_allocator The allocator scope for the returned list.\n @param map The map to extract keys from\n @return list of keys in the map"]
    pub fn wmem_map_get_keys(
        list_allocator: *mut wmem_allocator_t,
        map: *mut wmem_map_t,
    ) -> *mut wmem_list_t;
}
extern "C" {
    #[doc = " Run a function against all key/value pairs in the map. The order\n of the calls is unpredictable, since it is based on the internal\n storage of data.\n\n @param map The map to use. May be NULL.\n @param foreach_func the function to call for each key/value pair\n @param user_data user data to pass to the function"]
    pub fn wmem_map_foreach(
        map: *mut wmem_map_t,
        foreach_func: GHFunc,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Run a function against all key/value pairs in the map. If the\n function returns true, then the key/value pair is removed from\n the map. The order of the calls is unpredictable, since it is\n based on the internal storage of data.\n\n @param map The map to use. May be NULL.\n @param foreach_func the function to call for each key/value pair\n @param user_data user data to pass to the function\n @return The number of items removed"]
    pub fn wmem_map_foreach_remove(
        map: *mut wmem_map_t,
        foreach_func: GHRFunc,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return the number of elements of the map.\n\n @param map The map to use\n @return the number of elements"]
    pub fn wmem_map_size(map: *mut wmem_map_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Compute a strong hash value for an arbitrary sequence of bytes. Use of this\n hash value should be secure against algorithmic complexity attacks, even for\n short keys. The computation uses a random seed which is generated on wmem\n initialization, so the same key will hash to different values on different\n runs of the application.\n\n @param buf The buffer of bytes (does not have to be aligned).\n @param len The length of buf to use for the hash computation.\n @return The hash value."]
    pub fn wmem_strong_hash(buf: *const u8, len: usize) -> u32;
}
extern "C" {
    #[doc = " An implementation of GHashFunc using wmem_strong_hash. Prefer this over\n g_str_hash when the data comes from an untrusted source."]
    pub fn wmem_str_hash(key: gconstpointer) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " An implementation of GHashFunc using wmem_strong_hash. Prefer this over\n g_int64_hash when the data comes from an untrusted source."]
    pub fn wmem_int64_hash(key: gconstpointer) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " An implementation of GHashFunc using wmem_strong_hash. Prefer this over\n g_double_hash when the data comes from an untrusted source."]
    pub fn wmem_double_hash(key: gconstpointer) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Copies a block of memory.\n\n @param allocator The allocator object to use to allocate memory to copy into.\n @param source The pointer to the memory block to copy.\n @param size The amount of memory to copy.\n @return The location of the memory copy or NULL if size is 0."]
    pub fn wmem_memdup(
        allocator: *mut wmem_allocator_t,
        source: *const ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Generic GCompareFunc implementations to compare signed/unsigned integer"]
    pub fn wmem_compare_int(a: gconstpointer, b: gconstpointer) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmem_compare_uint(a: gconstpointer, b: gconstpointer) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_multimap_t {
    _unused: [u8; 0],
}
#[doc = " @addtogroup wmem\n  @{\n    @defgroup wmem-multimap Hash Multimap\n\n    A hash multimap implementation on top of wmem_map and wmem_tree, storing\n    multiple values at each hash key in a tree indexed by a 32 bit integer.\n\n    The primary use case is a protocol with an ID used as the hash lookup\n    key that can be reused in a capture, and the frame number used as the\n    tree key. We often want to find the most recent frame that had a certain\n    ID, e.g. for request/response matching, and wmem_multimap_lookup32_le()\n    serves that purpose.\n\n    Since the tree implementation is a self-balancing red-black tree, lookup\n    time is still O(log(n)) even though elements with equivalent hash keys\n    are usually added in increasing order of frame number.\n\n    NOTE: The multimap does not yet support inserting items without\n    specifying the tree key, because the total capacity of individual trees\n    (including deleted nodes) is not tracked.\n\n    @{"]
pub type wmem_multimap_t = _wmem_multimap_t;
extern "C" {
    #[doc = " Creates a multimap with the given allocator scope. When the scope is emptied,\n the map is fully destroyed. Items stored in it will not be freed unless they\n were allocated from the same scope.\n\n @param allocator The allocator scope with which to create the map.\n @param hash_func The hash function used to place inserted keys.\n @param eql_func  The equality function used to compare inserted keys.\n @return The newly-allocated map."]
    pub fn wmem_multimap_new(
        allocator: *mut wmem_allocator_t,
        hash_func: GHashFunc,
        eql_func: GEqualFunc,
    ) -> *mut wmem_multimap_t;
}
extern "C" {
    #[doc = " Creates a multimap with two allocator scopes. The base structure lives in the\n metadata scope, and the map data lives in the data scope. Every time free_all\n occurs in the data scope the map is transparently emptied without affecting\n the location of the base / metadata structure.\n\n WARNING: None of the map (even the part in the metadata scope) can be used\n after the data scope has been *destroyed*.\n\n The primary use for this function is to create maps that reset for each new\n capture file that is loaded. This can be done by specifying wmem_epan_scope()\n as the metadata scope and wmem_file_scope() as the data scope."]
    pub fn wmem_multimap_new_autoreset(
        metadata_scope: *mut wmem_allocator_t,
        data_scope: *mut wmem_allocator_t,
        hash_func: GHashFunc,
        eql_func: GEqualFunc,
    ) -> *mut wmem_multimap_t;
}
extern "C" {
    #[doc = " Retrieves a list of the keys inside the multimap\n\n @param list_allocator The allocator scope for the returned list.\n @param map The multimap to extract keys from\n @return list of keys in the multimap"]
    pub fn wmem_multimap_get_keys(
        list_allocator: *mut wmem_allocator_t,
        map: *mut wmem_multimap_t,
    ) -> *mut wmem_list_t;
}
extern "C" {
    #[doc = " Return the total number of elements in the multimap.\n\n @param map The multimap to use\n @return the number of elements"]
    pub fn wmem_multimap_size(map: *mut wmem_multimap_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns the number of values in the multimap with a certain hash key.\n (Note: This is the number of current elements, so this can only be used to\n safely generate unique tree keys prior to insertion if no values have been\n removed, due to how the tree implementation works.)\n\n @param map The multimap to search in.\n @param key The primary key to lookup in the map.\n @return The number of values in the tree stored at map key, or zero if no\n tree exists at that key."]
    pub fn wmem_multimap_count(
        map: *mut wmem_multimap_t,
        key: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Insert a value in the multimap.\n\n @param map The multimap to insert into.\n @param key The key to insert by in the map.\n @param frame_num The key to insert by in the tree.\n @param value The value to insert.\n @return true if there was already a tree mapped at key, in which case the\n caller may safely free key. (This is not necessary if key is allocated with\n a wmem pool.)\n\n Note: as with wmem_tree, if there is already a node with the same pair\n of keys, then the existing value will simply be overwritten. This is not\n a problem if the value is wmem allocated, but if it is manually managed,\n then you must ensure that the pair is unique or do a lookup before inserting."]
    pub fn wmem_multimap_insert32(
        map: *mut wmem_multimap_t,
        key: *const ::std::os::raw::c_void,
        frame_num: u32,
        value: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Lookup a value in the multimap combination with an exact match.\n\n @param map The multimap to search in.\n @param key The primary key to lookup in the map.\n @param frame_num The secondary key to lookup in the tree.\n @return The value stored at the keys if any, or NULL."]
    pub fn wmem_multimap_lookup32(
        map: *mut wmem_multimap_t,
        key: *const ::std::os::raw::c_void,
        frame_num: u32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Lookup a value in the multimap with an exact match for the map key\n and the largest value less than or equal to the tree key. This is\n useful for request/response matching where IDs can be reused.\n\n @param map The multimap to search in.\n @param key The primary key to lookup in the map.\n @param frame_num The secondary key to lookup in the tree.\n @return The value stored at the primary key in the map and with the largest\n key in the tree that is less than or equal to the second key if any, or NULL."]
    pub fn wmem_multimap_lookup32_le(
        map: *mut wmem_multimap_t,
        key: *const ::std::os::raw::c_void,
        frame_num: u32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Remove a value from the multimap. If no value is stored at that key pair,\n nothing happens. As with wmem_tree, this is not really a remove, but the\n value is set to NULL so that wmem_multimap_lookup32 not will find it.\n\n @param map The multimap to remove from.\n @param key The map key of the value to remove.\n @param frame_num The tree key of the value to remove.\n @return The (removed) value stored at the key if any, or NULL."]
    pub fn wmem_multimap_remove32(
        map: *mut wmem_multimap_t,
        key: *const ::std::os::raw::c_void,
        frame_num: u32,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " @addtogroup wmem\n  @{\n    @defgroup wmem-queue Queue\n\n    A queue implementation on top of wmem.\n\n    @{"]
pub type wmem_queue_t = wmem_list_t;
#[doc = " @addtogroup wmem\n  @{\n    @defgroup wmem-stack Stack\n\n    A stack implementation on top of wmem.\n\n    @{"]
pub type wmem_stack_t = wmem_list_t;
extern "C" {
    pub fn wmem_stack_peek(stack: *const wmem_stack_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn wmem_stack_pop(stack: *mut wmem_stack_t) -> *mut ::std::os::raw::c_void;
}
#[doc = " @addtogroup wmem\n  @{\n    @defgroup wmem-strbuf String Buffer\n\n    A string object implementation on top of wmem.\n\n    @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_strbuf_t {
    pub allocator: *mut wmem_allocator_t,
    pub str_: *mut ::std::os::raw::c_char,
    pub len: usize,
    pub alloc_size: usize,
}
#[test]
fn bindgen_test_layout__wmem_strbuf_t() {
    const UNINIT: ::std::mem::MaybeUninit<_wmem_strbuf_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_wmem_strbuf_t>(),
        32usize,
        concat!("Size of: ", stringify!(_wmem_strbuf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_wmem_strbuf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_wmem_strbuf_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_wmem_strbuf_t),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_wmem_strbuf_t),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_wmem_strbuf_t),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_wmem_strbuf_t),
            "::",
            stringify!(alloc_size)
        )
    );
}
#[doc = " @addtogroup wmem\n  @{\n    @defgroup wmem-strbuf String Buffer\n\n    A string object implementation on top of wmem.\n\n    @{"]
pub type wmem_strbuf_t = _wmem_strbuf_t;
extern "C" {
    pub fn wmem_strbuf_new_sized(
        allocator: *mut wmem_allocator_t,
        alloc_size: usize,
    ) -> *mut wmem_strbuf_t;
}
extern "C" {
    pub fn wmem_strbuf_new(
        allocator: *mut wmem_allocator_t,
        str_: *const ::std::os::raw::c_char,
    ) -> *mut wmem_strbuf_t;
}
extern "C" {
    pub fn wmem_strbuf_new_len(
        allocator: *mut wmem_allocator_t,
        str_: *const ::std::os::raw::c_char,
        len: usize,
    ) -> *mut wmem_strbuf_t;
}
extern "C" {
    pub fn wmem_strbuf_dup(
        allocator: *mut wmem_allocator_t,
        strbuf: *const wmem_strbuf_t,
    ) -> *mut wmem_strbuf_t;
}
extern "C" {
    pub fn wmem_strbuf_append(strbuf: *mut wmem_strbuf_t, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn wmem_strbuf_append_len(
        strbuf: *mut wmem_strbuf_t,
        str_: *const ::std::os::raw::c_char,
        append_len: usize,
    );
}
extern "C" {
    pub fn wmem_strbuf_append_printf(
        strbuf: *mut wmem_strbuf_t,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn wmem_strbuf_append_vprintf(
        strbuf: *mut wmem_strbuf_t,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    );
}
extern "C" {
    pub fn wmem_strbuf_append_c(strbuf: *mut wmem_strbuf_t, c: ::std::os::raw::c_char);
}
extern "C" {
    pub fn wmem_strbuf_append_c_count(
        strbuf: *mut wmem_strbuf_t,
        c: ::std::os::raw::c_char,
        count: usize,
    );
}
extern "C" {
    pub fn wmem_strbuf_append_unichar(strbuf: *mut wmem_strbuf_t, c: gunichar);
}
extern "C" {
    pub fn wmem_strbuf_append_unichar_validated(strbuf: *mut wmem_strbuf_t, c: gunichar);
}
extern "C" {
    pub fn wmem_strbuf_append_hex(strbuf: *mut wmem_strbuf_t, arg1: u8);
}
extern "C" {
    pub fn wmem_strbuf_append_hex_unichar(strbuf: *mut wmem_strbuf_t, arg1: gunichar) -> usize;
}
extern "C" {
    pub fn wmem_strbuf_truncate(strbuf: *mut wmem_strbuf_t, len: usize);
}
extern "C" {
    pub fn wmem_strbuf_get_str(strbuf: *const wmem_strbuf_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wmem_strbuf_get_len(strbuf: *const wmem_strbuf_t) -> usize;
}
extern "C" {
    pub fn wmem_strbuf_strcmp(
        sb1: *const wmem_strbuf_t,
        sb2: *const wmem_strbuf_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmem_strbuf_strstr(
        haystack: *const wmem_strbuf_t,
        needle: *const wmem_strbuf_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Truncates the allocated memory down to the minimal amount, frees the header\n  structure, and returns a non-const pointer to the raw string. The\n  wmem_strbuf_t structure cannot be used after this is called. Basically a\n  destructor for when you still need the underlying C-string."]
    pub fn wmem_strbuf_finalize(strbuf: *mut wmem_strbuf_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn wmem_strbuf_destroy(strbuf: *mut wmem_strbuf_t);
}
extern "C" {
    pub fn wmem_strbuf_utf8_validate(
        strbuf: *mut wmem_strbuf_t,
        endptr: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn wmem_strbuf_utf8_make_valid(strbuf: *mut wmem_strbuf_t);
}
extern "C" {
    #[doc = " @addtogroup wmem\n  @{\n    @defgroup wmem-strutl String Utilities\n\n    A collection of utility function for operating on C strings with wmem.\n\n    @{"]
    pub fn wmem_strdup(
        allocator: *mut wmem_allocator_t,
        src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn wmem_strndup(
        allocator: *mut wmem_allocator_t,
        src: *const ::std::os::raw::c_char,
        len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn wmem_strdup_printf(
        allocator: *mut wmem_allocator_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn wmem_strdup_vprintf(
        allocator: *mut wmem_allocator_t,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the first occurrence of needle in haystack.\n\n @param haystack The data to search\n @param haystack_len The length of the search data\n @param needle The string to look for\n @param needle_len The length of the search string\n @return A pointer to the first occurrence of \"needle\" in\n         \"haystack\".  If \"needle\" isn't found or is NULL, or if\n         \"needle_len\" is 0, NULL is returned."]
    pub fn ws_memmem(
        haystack: *const ::std::os::raw::c_void,
        haystack_len: usize,
        needle: *const ::std::os::raw::c_void,
        needle_len: usize,
    ) -> *const u8;
}
#[doc = " @addtogroup wmem\n  @{\n    @defgroup wmem-tree Red/Black Tree\n\n    Binary trees are a well-known and popular device in computer science to\n    handle storage of objects based on a search key or identity. The\n    particular binary tree style implemented here is the red/black tree, which\n    has the nice property of being self-balancing. This guarantees O(log(n))\n    time for lookups, compared to linked lists that are O(n). This means\n    red/black trees scale very well when many objects are being stored.\n\n    @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_tree_t {
    _unused: [u8; 0],
}
pub type wmem_tree_t = _wmem_tree_t;
extern "C" {
    #[doc = " Creates a tree with the given allocator scope. When the scope is emptied,\n the tree is fully destroyed."]
    pub fn wmem_tree_new(allocator: *mut wmem_allocator_t) -> *mut wmem_tree_t;
}
extern "C" {
    #[doc = " Creates a tree with two allocator scopes. The base structure lives in the\n metadata scope, and the tree data lives in the data scope. Every time free_all\n occurs in the data scope the tree is transparently emptied without affecting\n the location of the base / metadata structure.\n\n WARNING: None of the tree (even the part in the metadata scope) can be used\n after the data scope has been *destroyed*.\n\n The primary use for this function is to create trees that reset for each new\n capture file that is loaded. This can be done by specifying wmem_epan_scope()\n as the metadata scope and wmem_file_scope() as the data scope."]
    pub fn wmem_tree_new_autoreset(
        metadata_scope: *mut wmem_allocator_t,
        data_scope: *mut wmem_allocator_t,
    ) -> *mut wmem_tree_t;
}
extern "C" {
    #[doc = " Cleanup memory used by tree.  Intended for NULL scope allocated trees"]
    pub fn wmem_tree_destroy(tree: *mut wmem_tree_t, free_keys: bool, free_values: bool);
}
extern "C" {
    #[doc = " Returns true if the tree is empty (has no nodes)."]
    pub fn wmem_tree_is_empty(tree: *mut wmem_tree_t) -> bool;
}
extern "C" {
    #[doc = " Returns number of nodes in tree"]
    pub fn wmem_tree_count(tree: *mut wmem_tree_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Insert a node indexed by a uint32_t key value.\n\n Data is a pointer to the structure you want to be able to retrieve by\n searching for the same key later.\n\n NOTE: If you insert a node to a key that already exists in the tree this\n function will simply overwrite the old value. If the structures you are\n storing are allocated in a wmem pool this is not a problem as they will still\n be freed with the pool. If you are managing them manually however, you must\n either ensure the key is unique, or do a lookup before each insert."]
    pub fn wmem_tree_insert32(tree: *mut wmem_tree_t, key: u32, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Look up a node in the tree indexed by a uint32_t integer value. Return true\n if present."]
    pub fn wmem_tree_contains32(tree: *mut wmem_tree_t, key: u32) -> bool;
}
extern "C" {
    #[doc = " Look up a node in the tree indexed by a uint32_t integer value. If no node is\n found the function will return NULL."]
    pub fn wmem_tree_lookup32(tree: *mut wmem_tree_t, key: u32) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Look up a node in the tree indexed by a uint32_t integer value.\n Returns the node that has the largest key that is less than or equal\n to the search key, or NULL if no such key exists."]
    pub fn wmem_tree_lookup32_le(tree: *mut wmem_tree_t, key: u32) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Remove a node in the tree indexed by a uint32_t integer value. This is not\n really a remove, but the value is set to NULL so that wmem_tree_lookup32\n not will find it."]
    pub fn wmem_tree_remove32(tree: *mut wmem_tree_t, key: u32) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Insert a new value under a string key. Like wmem_tree_insert32 but where the\n key is a null-terminated string instead of a uint32_t. You may pass\n WMEM_TREE_STRING_NOCASE to the flags argument in order to make it store the\n key in a case-insensitive way.  (Note that \"case-insensitive\" refers\n only to the ASCII letters A-Z and a-z; it is locale-independent.\n Do not expect it to honor the rules of your language; for example, \"I\"\n will always be mapped to \"i\"."]
    pub fn wmem_tree_insert_string(
        tree: *mut wmem_tree_t,
        key: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
        flags: u32,
    );
}
extern "C" {
    #[doc = " Lookup the value under a string key, like wmem_tree_lookup32 but where the\n keye is a null-terminated string instead of a uint32_t. See\n wmem_tree_insert_string for an explanation of flags."]
    pub fn wmem_tree_lookup_string(
        tree: *mut wmem_tree_t,
        key: *const ::std::os::raw::c_char,
        flags: u32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Remove the value under a string key.  This is not really a remove, but the\n value is set to NULL so that wmem_tree_lookup_string not will find it.\n See wmem_tree_insert_string for an explanation of flags."]
    pub fn wmem_tree_remove_string(
        tree: *mut wmem_tree_t,
        key: *const ::std::os::raw::c_char,
        flags: u32,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_tree_key_t {
    #[doc = "< length in uint32_t words"]
    pub length: u32,
    pub key: *mut u32,
}
#[test]
fn bindgen_test_layout__wmem_tree_key_t() {
    const UNINIT: ::std::mem::MaybeUninit<_wmem_tree_key_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_wmem_tree_key_t>(),
        16usize,
        concat!("Size of: ", stringify!(_wmem_tree_key_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_wmem_tree_key_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_wmem_tree_key_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_wmem_tree_key_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_wmem_tree_key_t),
            "::",
            stringify!(key)
        )
    );
}
pub type wmem_tree_key_t = _wmem_tree_key_t;
extern "C" {
    #[doc = " Insert a node indexed by a sequence of uint32_t key values.\n\n Takes as key an array of uint32_t vectors of type wmem_tree_key_t. It will\n iterate through each key to search further down the tree until it reaches an\n element where length==0, indicating the end of the array. You MUST terminate\n the key array by {0, NULL} or this will crash.\n\n NOTE: length indicates the number of uint32_t values in the vector, not the\n number of bytes.\n\n NOTE: all the \"key\" members of the \"key\" argument MUST be aligned on\n 32-bit boundaries; otherwise, this code will crash on platforms such\n as SPARC that require aligned pointers.\n\n If you use ...32_array() calls you MUST make sure that every single node\n you add to a specific tree always has a key of exactly the same number of\n keylen words or it will crash. Or at least that every single item that sits\n behind the same top level node always has exactly the same number of words.\n\n One way to guarantee this is the way that NFS does this for the\n nfs_name_snoop_known tree which holds filehandles for both v2 and v3.\n v2 filehandles are always 32 bytes (8 words) while v3 filehandles can have\n any length (though 32 bytes are most common).\n The NFS dissector handles this by providing a uint32_t containing the length\n as the very first item in this vector :\n\n                      wmem_tree_key_t fhkey[3];\n\n                      fhlen=nns->fh_length;\n                      fhkey[0].length=1;\n                      fhkey[0].key=&fhlen;\n                      fhkey[1].length=fhlen/4;\n                      fhkey[1].key=nns->fh;\n                      fhkey[2].length=0;"]
    pub fn wmem_tree_insert32_array(
        tree: *mut wmem_tree_t,
        key: *mut wmem_tree_key_t,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Look up a node in the tree indexed by a sequence of uint32_t integer values.\n See wmem_tree_insert32_array for details on the key."]
    pub fn wmem_tree_lookup32_array(
        tree: *mut wmem_tree_t,
        key: *mut wmem_tree_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Look up a node in the tree indexed by a multi-part tree value.\n The function will return the node that has the largest key that is\n equal to or smaller than the search key, or NULL if no such key was\n found.\n\n NOTE:  The key returned will be \"less\" in key order.  The usefulness\n of the returned node must be verified prior to use.\n\n See wmem_tree_insert32_array for details on the key."]
    pub fn wmem_tree_lookup32_array_le(
        tree: *mut wmem_tree_t,
        key: *mut wmem_tree_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " Function type for processing one node of a tree during a traversal. Value is\n the value of the node, userdata is whatever was passed to the traversal\n function. If the function returns true the traversal will end prematurely."]
pub type wmem_foreach_func = ::std::option::Option<
    unsafe extern "C" fn(
        key: *const ::std::os::raw::c_void,
        value: *mut ::std::os::raw::c_void,
        userdata: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = " Function type to print key/data of nodes in wmem_print_tree_verbose"]
pub type wmem_printer_func =
    ::std::option::Option<unsafe extern "C" fn(data: *const ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Inorder traversal (left/parent/right) of the tree and call\n callback(value, userdata) for each value found.\n\n Returns true if the traversal was ended prematurely by the callback."]
    pub fn wmem_tree_foreach(
        tree: *mut wmem_tree_t,
        callback: wmem_foreach_func,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn wmem_print_tree(
        tree: *mut wmem_tree_t,
        key_printer: wmem_printer_func,
        data_printer: wmem_printer_func,
    );
}
pub type wmem_itree_t = _wmem_tree_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_range_t {
    pub low: u64,
    pub high: u64,
    pub max_edge: u64,
}
#[test]
fn bindgen_test_layout__wmem_range_t() {
    const UNINIT: ::std::mem::MaybeUninit<_wmem_range_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_wmem_range_t>(),
        24usize,
        concat!("Size of: ", stringify!(_wmem_range_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_wmem_range_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_wmem_range_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_wmem_range_t),
            "::",
            stringify!(low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).high) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_wmem_range_t),
            "::",
            stringify!(high)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_edge) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_wmem_range_t),
            "::",
            stringify!(max_edge)
        )
    );
}
extern "C" {
    pub fn wmem_itree_new(allocator: *mut wmem_allocator_t) -> *mut wmem_itree_t;
}
extern "C" {
    #[doc = " Returns true if the tree is empty (has no nodes)."]
    pub fn wmem_itree_is_empty(tree: *mut wmem_itree_t) -> bool;
}
extern "C" {
    #[doc = " Inserts a range low-high indexed by \"low\" in O(log(n)).\n As in wmem_tree, if a key \"low\" already exists, it will be overwritten with the new data\n"]
    pub fn wmem_itree_insert(
        tree: *mut wmem_itree_t,
        low: u64,
        high: u64,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn wmem_itree_find_intervals(
        tree: *mut wmem_itree_t,
        allocator: *mut wmem_allocator_t,
        low: u64,
        high: u64,
    ) -> *mut wmem_list_t;
}
extern "C" {
    #[doc = " Print ranges along the tree"]
    pub fn wmem_print_itree(tree: *mut wmem_itree_t);
}
#[doc = "< wmem_free_all()"]
pub const _wmem_cb_event_t_WMEM_CB_FREE_EVENT: _wmem_cb_event_t = 0;
#[doc = "< wmem_destroy_allocator()"]
pub const _wmem_cb_event_t_WMEM_CB_DESTROY_EVENT: _wmem_cb_event_t = 1;
#[doc = " The events that can trigger a callback."]
pub type _wmem_cb_event_t = ::std::os::raw::c_int;
#[doc = " The events that can trigger a callback."]
pub use self::_wmem_cb_event_t as wmem_cb_event_t;
#[doc = " Function signature for registered user callbacks.\n\n allocator The allocator that triggered this callback.\n event     The event type that triggered this callback.\n user_data Whatever user_data was originally passed to the call to\n                  wmem_register_callback().\n @return          false to unregister the callback, true otherwise."]
pub type wmem_user_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut wmem_allocator_t,
        arg2: wmem_cb_event_t,
        arg3: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
extern "C" {
    #[doc = " Register a callback function with the given allocator pool.\n\n @param allocator The allocator with which to register the callback.\n @param callback  The function to be called as the callback.\n @param user_data An arbitrary data pointer that is passed to the callback as\n                  a way to specify extra parameters or store extra data. Note\n                  that this pointer is not freed when a callback is finished,\n                  you have to do that yourself in the callback, or just\n                  allocate it in the appropriate wmem pool.\n @return          ID of this callback that can be passed back to\n                  wmem_unregister_callback()."]
    pub fn wmem_register_callback(
        allocator: *mut wmem_allocator_t,
        callback: wmem_user_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Unregister the callback function with the given ID.\n\n @param allocator The allocator from which to unregister the callback.\n @param id        The callback id as returned from wmem_register_callback()."]
    pub fn wmem_unregister_callback(allocator: *mut wmem_allocator_t, id: ::std::os::raw::c_uint);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Buffer {
    pub data: *mut u8,
    pub allocated: usize,
    pub start: usize,
    pub first_free: usize,
}
#[test]
fn bindgen_test_layout_Buffer() {
    const UNINIT: ::std::mem::MaybeUninit<Buffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Buffer>(),
        32usize,
        concat!("Size of: ", stringify!(Buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<Buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(Buffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Buffer),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocated) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Buffer),
            "::",
            stringify!(allocated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Buffer),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_free) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Buffer),
            "::",
            stringify!(first_free)
        )
    );
}
extern "C" {
    pub fn ws_buffer_init(buffer: *mut Buffer, space: usize);
}
extern "C" {
    pub fn ws_buffer_free(buffer: *mut Buffer);
}
extern "C" {
    pub fn ws_buffer_assure_space(buffer: *mut Buffer, space: usize);
}
extern "C" {
    pub fn ws_buffer_append(buffer: *mut Buffer, from: *mut u8, bytes: usize);
}
extern "C" {
    pub fn ws_buffer_remove_start(buffer: *mut Buffer, bytes: usize);
}
extern "C" {
    pub fn ws_buffer_cleanup();
}
#[doc = " data structure to hold time values with nanosecond resolution"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nstime_t {
    pub secs: time_t,
    pub nsecs: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_nstime_t() {
    const UNINIT: ::std::mem::MaybeUninit<nstime_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nstime_t>(),
        16usize,
        concat!("Size of: ", stringify!(nstime_t))
    );
    assert_eq!(
        ::std::mem::align_of::<nstime_t>(),
        8usize,
        concat!("Alignment of ", stringify!(nstime_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).secs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nstime_t),
            "::",
            stringify!(secs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nsecs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nstime_t),
            "::",
            stringify!(nsecs)
        )
    );
}
extern "C" {
    #[doc = " set the given nstime_t to zero"]
    pub fn nstime_set_zero(nstime: *mut nstime_t);
}
extern "C" {
    #[doc = " is the given nstime_t currently zero?"]
    pub fn nstime_is_zero(nstime: *const nstime_t) -> bool;
}
extern "C" {
    #[doc = " set the given nstime_t to (0,maxint) to mark it as \"unset\"\n That way we can find the first frame even when a timestamp\n is zero (fix for bug 1056)"]
    pub fn nstime_set_unset(nstime: *mut nstime_t);
}
extern "C" {
    pub fn nstime_is_unset(nstime: *const nstime_t) -> bool;
}
extern "C" {
    #[doc = " duplicate the current time\n\n a = b"]
    pub fn nstime_copy(a: *mut nstime_t, b: *const nstime_t);
}
extern "C" {
    #[doc = " calculate the delta between two times (can be negative!)\n\n delta = b-a\n\n Note that it is acceptable for two or more of the arguments to point at the\n same structure."]
    pub fn nstime_delta(delta: *mut nstime_t, b: *const nstime_t, a: *const nstime_t);
}
extern "C" {
    #[doc = " calculate the sum of two times\n\n sum = a+b\n\n Note that it is acceptable for two or more of the arguments to point at the\n same structure."]
    pub fn nstime_sum(sum: *mut nstime_t, a: *const nstime_t, b: *const nstime_t);
}
extern "C" {
    #[doc = " compare two times are return a value similar to memcmp() or strcmp().\n\n a > b : > 0\n a = b : 0\n a < b : < 0"]
    pub fn nstime_cmp(a: *const nstime_t, b: *const nstime_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nstime_hash(nstime: *const nstime_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " converts nstime to double, time base is milli seconds"]
    pub fn nstime_to_msec(nstime: *const nstime_t) -> f64;
}
extern "C" {
    #[doc = " converts nstime to double, time base is seconds"]
    pub fn nstime_to_sec(nstime: *const nstime_t) -> f64;
}
extern "C" {
    #[doc = " converts Windows FILETIME to nstime, returns true on success,\nfalse on failure"]
    pub fn filetime_to_nstime(nstime: *mut nstime_t, filetime: u64) -> bool;
}
extern "C" {
    #[doc = " converts time like Windows FILETIME, but expressed in nanoseconds\nrather than tenths of microseconds, to nstime, returns true on success,\nfalse on failure"]
    pub fn nsfiletime_to_nstime(nstime: *mut nstime_t, nsfiletime: u64) -> bool;
}
pub const iso8601_fmt_e_ISO8601_DATETIME: iso8601_fmt_e = 0;
#[doc = " e.g. 2014-07-04T12:34:56.789+00:00"]
pub const iso8601_fmt_e_ISO8601_DATETIME_BASIC: iso8601_fmt_e = 1;
#[doc = " ISO8601 Basic format, i.e. no - : separators"]
pub const iso8601_fmt_e_ISO8601_DATETIME_AUTO: iso8601_fmt_e = 2;
pub type iso8601_fmt_e = ::std::os::raw::c_int;
extern "C" {
    #[doc = " parse an ISO 8601 format datetime string to nstime, returns pointer\nto the first character after the last character, NULL on failure\nNote that nstime is set to unset in the case of failure"]
    pub fn iso8601_to_nstime(
        nstime: *mut nstime_t,
        ptr: *const ::std::os::raw::c_char,
        format: iso8601_fmt_e,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " parse an Unix epoch timestamp format datetime string to nstime, returns\npointer to the first character after the last character, NULL on failure\nNote that nstime is set to unset in the case of failure"]
    pub fn unix_epoch_to_nstime(
        nstime: *mut nstime_t,
        ptr: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nstime_to_iso8601(
        buf: *mut ::std::os::raw::c_char,
        buf_size: usize,
        nstime: *const nstime_t,
    ) -> usize;
}
extern "C" {
    pub fn nstime_to_unix(
        buf: *mut ::std::os::raw::c_char,
        buf_size: usize,
        nstime: *const nstime_t,
    );
}
pub const ws_tsprec_e_WS_TSPREC_SEC: ws_tsprec_e = 0;
pub const ws_tsprec_e_WS_TSPREC_100_MSEC: ws_tsprec_e = 1;
pub const ws_tsprec_e_WS_TSPREC_10_MSEC: ws_tsprec_e = 2;
pub const ws_tsprec_e_WS_TSPREC_MSEC: ws_tsprec_e = 3;
pub const ws_tsprec_e_WS_TSPREC_100_USEC: ws_tsprec_e = 4;
pub const ws_tsprec_e_WS_TSPREC_10_USEC: ws_tsprec_e = 5;
pub const ws_tsprec_e_WS_TSPREC_USEC: ws_tsprec_e = 6;
pub const ws_tsprec_e_WS_TSPREC_100_NSEC: ws_tsprec_e = 7;
pub const ws_tsprec_e_WS_TSPREC_10_NSEC: ws_tsprec_e = 8;
pub const ws_tsprec_e_WS_TSPREC_NSEC: ws_tsprec_e = 9;
pub type ws_tsprec_e = ::std::os::raw::c_int;
pub type ws_in4_addr = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct e_in6_addr {
    pub bytes: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_e_in6_addr() {
    const UNINIT: ::std::mem::MaybeUninit<e_in6_addr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<e_in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(e_in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<e_in6_addr>(),
        1usize,
        concat!("Alignment of ", stringify!(e_in6_addr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(e_in6_addr),
            "::",
            stringify!(bytes)
        )
    );
}
pub type ws_in6_addr = e_in6_addr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ws_ip6_hdr {
    pub ip6h_vc_flow: u32,
    pub ip6h_plen: u16,
    pub ip6h_nxt: u8,
    pub ip6h_hlim: u8,
    pub ip6h_src: ws_in6_addr,
    pub ip6h_dst: ws_in6_addr,
}
#[test]
fn bindgen_test_layout_ws_ip6_hdr() {
    const UNINIT: ::std::mem::MaybeUninit<ws_ip6_hdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ws_ip6_hdr>(),
        40usize,
        concat!("Size of: ", stringify!(ws_ip6_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<ws_ip6_hdr>(),
        4usize,
        concat!("Alignment of ", stringify!(ws_ip6_hdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6h_vc_flow) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ws_ip6_hdr),
            "::",
            stringify!(ip6h_vc_flow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6h_plen) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ws_ip6_hdr),
            "::",
            stringify!(ip6h_plen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6h_nxt) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ws_ip6_hdr),
            "::",
            stringify!(ip6h_nxt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6h_hlim) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(ws_ip6_hdr),
            "::",
            stringify!(ip6h_hlim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6h_src) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ws_ip6_hdr),
            "::",
            stringify!(ip6h_src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6h_dst) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ws_ip6_hdr),
            "::",
            stringify!(ip6h_dst)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_ext {
    pub ip6e_nxt: ::std::os::raw::c_uchar,
    pub ip6e_len: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_ip6_ext() {
    const UNINIT: ::std::mem::MaybeUninit<ip6_ext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip6_ext>(),
        2usize,
        concat!("Size of: ", stringify!(ip6_ext))
    );
    assert_eq!(
        ::std::mem::align_of::<ip6_ext>(),
        1usize,
        concat!("Alignment of ", stringify!(ip6_ext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6e_nxt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_ext),
            "::",
            stringify!(ip6e_nxt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6e_len) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_ext),
            "::",
            stringify!(ip6e_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_rthdr {
    pub ip6r_nxt: u8,
    pub ip6r_len: u8,
    pub ip6r_type: u8,
    pub ip6r_segleft: u8,
}
#[test]
fn bindgen_test_layout_ip6_rthdr() {
    const UNINIT: ::std::mem::MaybeUninit<ip6_rthdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip6_rthdr>(),
        4usize,
        concat!("Size of: ", stringify!(ip6_rthdr))
    );
    assert_eq!(
        ::std::mem::align_of::<ip6_rthdr>(),
        1usize,
        concat!("Alignment of ", stringify!(ip6_rthdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6r_nxt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_rthdr),
            "::",
            stringify!(ip6r_nxt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6r_len) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_rthdr),
            "::",
            stringify!(ip6r_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6r_type) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_rthdr),
            "::",
            stringify!(ip6r_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6r_segleft) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_rthdr),
            "::",
            stringify!(ip6r_segleft)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_rthdr0 {
    pub ip6r0_nxt: u8,
    pub ip6r0_len: u8,
    pub ip6r0_type: u8,
    pub ip6r0_segleft: u8,
    pub ip6r0_reserved: u8,
    pub ip6r0_slmap: [u8; 3usize],
    pub ip6r0_addr: [ws_in6_addr; 1usize],
}
#[test]
fn bindgen_test_layout_ip6_rthdr0() {
    const UNINIT: ::std::mem::MaybeUninit<ip6_rthdr0> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip6_rthdr0>(),
        24usize,
        concat!("Size of: ", stringify!(ip6_rthdr0))
    );
    assert_eq!(
        ::std::mem::align_of::<ip6_rthdr0>(),
        1usize,
        concat!("Alignment of ", stringify!(ip6_rthdr0))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6r0_nxt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_rthdr0),
            "::",
            stringify!(ip6r0_nxt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6r0_len) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_rthdr0),
            "::",
            stringify!(ip6r0_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6r0_type) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_rthdr0),
            "::",
            stringify!(ip6r0_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6r0_segleft) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_rthdr0),
            "::",
            stringify!(ip6r0_segleft)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6r0_reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_rthdr0),
            "::",
            stringify!(ip6r0_reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6r0_slmap) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_rthdr0),
            "::",
            stringify!(ip6r0_slmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6r0_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_rthdr0),
            "::",
            stringify!(ip6r0_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_frag {
    pub ip6f_nxt: u8,
    pub ip6f_reserved: u8,
    pub ip6f_offlg: u16,
    pub ip6f_ident: u32,
}
#[test]
fn bindgen_test_layout_ip6_frag() {
    const UNINIT: ::std::mem::MaybeUninit<ip6_frag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip6_frag>(),
        8usize,
        concat!("Size of: ", stringify!(ip6_frag))
    );
    assert_eq!(
        ::std::mem::align_of::<ip6_frag>(),
        4usize,
        concat!("Alignment of ", stringify!(ip6_frag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6f_nxt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_frag),
            "::",
            stringify!(ip6f_nxt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6f_reserved) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_frag),
            "::",
            stringify!(ip6f_reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6f_offlg) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_frag),
            "::",
            stringify!(ip6f_offlg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6f_ident) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_frag),
            "::",
            stringify!(ip6f_ident)
        )
    );
}
extern "C" {
    pub fn ws_inet_ntop4(
        src: *const ::std::os::raw::c_void,
        dst: *mut ::std::os::raw::c_char,
        dst_size: usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ws_inet_ntop6(
        src: *const ::std::os::raw::c_void,
        dst: *mut ::std::os::raw::c_char,
        dst_size: usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ws_inet_pton4(src: *const ::std::os::raw::c_char, dst: *mut ws_in4_addr) -> bool;
}
extern "C" {
    pub fn ws_inet_pton6(src: *const ::std::os::raw::c_char, dst: *mut ws_in6_addr) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_block {
    _unused: [u8; 0],
}
pub type wtap_block_t = *mut wtap_block;
pub const wtap_block_type_t_WTAP_BLOCK_SECTION: wtap_block_type_t = 0;
pub const wtap_block_type_t_WTAP_BLOCK_IF_ID_AND_INFO: wtap_block_type_t = 1;
pub const wtap_block_type_t_WTAP_BLOCK_NAME_RESOLUTION: wtap_block_type_t = 2;
pub const wtap_block_type_t_WTAP_BLOCK_IF_STATISTICS: wtap_block_type_t = 3;
pub const wtap_block_type_t_WTAP_BLOCK_DECRYPTION_SECRETS: wtap_block_type_t = 4;
pub const wtap_block_type_t_WTAP_BLOCK_PACKET: wtap_block_type_t = 5;
pub const wtap_block_type_t_WTAP_BLOCK_FT_SPECIFIC_REPORT: wtap_block_type_t = 6;
pub const wtap_block_type_t_WTAP_BLOCK_FT_SPECIFIC_EVENT: wtap_block_type_t = 7;
pub const wtap_block_type_t_WTAP_BLOCK_SYSDIG_EVENT: wtap_block_type_t = 8;
pub const wtap_block_type_t_WTAP_BLOCK_SYSDIG_META_EVENT: wtap_block_type_t = 9;
pub const wtap_block_type_t_WTAP_BLOCK_SYSTEMD_JOURNAL_EXPORT: wtap_block_type_t = 10;
pub const wtap_block_type_t_WTAP_BLOCK_CUSTOM: wtap_block_type_t = 11;
pub const wtap_block_type_t_MAX_WTAP_BLOCK_TYPE_VALUE: wtap_block_type_t = 12;
pub type wtap_block_type_t = ::std::os::raw::c_int;
#[doc = " Holds the required data from a WTAP_BLOCK_SECTION."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtapng_section_mandatory_s {
    #[doc = "< 64-bit value specifying the length in bytes of the\n     following section.\n     Section Length equal -1 (0xFFFFFFFFFFFFFFFF) means\n     that the size of the section is not specified\n   Note: if writing to a new file, this length will\n     be invalid if anything changes, such as the other\n     members of this struct, or the packets written."]
    pub section_length: guint64,
}
#[test]
fn bindgen_test_layout_wtapng_section_mandatory_s() {
    const UNINIT: ::std::mem::MaybeUninit<wtapng_section_mandatory_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wtapng_section_mandatory_s>(),
        8usize,
        concat!("Size of: ", stringify!(wtapng_section_mandatory_s))
    );
    assert_eq!(
        ::std::mem::align_of::<wtapng_section_mandatory_s>(),
        8usize,
        concat!("Alignment of ", stringify!(wtapng_section_mandatory_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).section_length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtapng_section_mandatory_s),
            "::",
            stringify!(section_length)
        )
    );
}
#[doc = " Holds the required data from a WTAP_BLOCK_SECTION."]
pub type wtapng_section_mandatory_t = wtapng_section_mandatory_s;
#[doc = " struct holding the information to build a WTAP_BLOCK_IF_ID_AND_INFO.\n  the interface_data array holds an array of wtap_block_t\n  representing interfacs, one per interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtapng_iface_descriptions_s {
    pub interface_data: *mut GArray,
}
#[test]
fn bindgen_test_layout_wtapng_iface_descriptions_s() {
    const UNINIT: ::std::mem::MaybeUninit<wtapng_iface_descriptions_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wtapng_iface_descriptions_s>(),
        8usize,
        concat!("Size of: ", stringify!(wtapng_iface_descriptions_s))
    );
    assert_eq!(
        ::std::mem::align_of::<wtapng_iface_descriptions_s>(),
        8usize,
        concat!("Alignment of ", stringify!(wtapng_iface_descriptions_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtapng_iface_descriptions_s),
            "::",
            stringify!(interface_data)
        )
    );
}
#[doc = " struct holding the information to build a WTAP_BLOCK_IF_ID_AND_INFO.\n  the interface_data array holds an array of wtap_block_t\n  representing interfacs, one per interface."]
pub type wtapng_iface_descriptions_t = wtapng_iface_descriptions_s;
#[doc = " Holds the required data from a WTAP_BLOCK_IF_ID_AND_INFO."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtapng_if_descr_mandatory_s {
    #[doc = "< link_type translated to wtap_encap"]
    pub wtap_encap: ::std::os::raw::c_int,
    pub time_units_per_second: guint64,
    #[doc = "< WTAP_TSPREC_ value for this interface"]
    pub tsprecision: ::std::os::raw::c_int,
    pub snap_len: guint32,
    pub num_stat_entries: guint8,
    #[doc = "< An array holding the interface statistics from\n     pcapng ISB:s or equivalent(?)"]
    pub interface_statistics: *mut GArray,
}
#[test]
fn bindgen_test_layout_wtapng_if_descr_mandatory_s() {
    const UNINIT: ::std::mem::MaybeUninit<wtapng_if_descr_mandatory_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wtapng_if_descr_mandatory_s>(),
        40usize,
        concat!("Size of: ", stringify!(wtapng_if_descr_mandatory_s))
    );
    assert_eq!(
        ::std::mem::align_of::<wtapng_if_descr_mandatory_s>(),
        8usize,
        concat!("Alignment of ", stringify!(wtapng_if_descr_mandatory_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wtap_encap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtapng_if_descr_mandatory_s),
            "::",
            stringify!(wtap_encap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_units_per_second) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wtapng_if_descr_mandatory_s),
            "::",
            stringify!(time_units_per_second)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tsprecision) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wtapng_if_descr_mandatory_s),
            "::",
            stringify!(tsprecision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).snap_len) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(wtapng_if_descr_mandatory_s),
            "::",
            stringify!(snap_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_stat_entries) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wtapng_if_descr_mandatory_s),
            "::",
            stringify!(num_stat_entries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_statistics) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wtapng_if_descr_mandatory_s),
            "::",
            stringify!(interface_statistics)
        )
    );
}
#[doc = " Holds the required data from a WTAP_BLOCK_IF_ID_AND_INFO."]
pub type wtapng_if_descr_mandatory_t = wtapng_if_descr_mandatory_s;
#[doc = " Holds the required data from a WTAP_BLOCK_NAME_RESOLUTION."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtapng_nrb_mandatory_s {
    pub ipv4_addr_list: *mut GList,
    pub ipv6_addr_list: *mut GList,
}
#[test]
fn bindgen_test_layout_wtapng_nrb_mandatory_s() {
    const UNINIT: ::std::mem::MaybeUninit<wtapng_nrb_mandatory_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wtapng_nrb_mandatory_s>(),
        16usize,
        concat!("Size of: ", stringify!(wtapng_nrb_mandatory_s))
    );
    assert_eq!(
        ::std::mem::align_of::<wtapng_nrb_mandatory_s>(),
        8usize,
        concat!("Alignment of ", stringify!(wtapng_nrb_mandatory_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipv4_addr_list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtapng_nrb_mandatory_s),
            "::",
            stringify!(ipv4_addr_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipv6_addr_list) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wtapng_nrb_mandatory_s),
            "::",
            stringify!(ipv6_addr_list)
        )
    );
}
#[doc = " Holds the required data from a WTAP_BLOCK_NAME_RESOLUTION."]
pub type wtapng_nrb_mandatory_t = wtapng_nrb_mandatory_s;
#[doc = " Holds the required data from a WTAP_BLOCK_IF_STATISTICS."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtapng_if_stats_mandatory_s {
    pub interface_id: guint32,
    pub ts_high: guint32,
    pub ts_low: guint32,
}
#[test]
fn bindgen_test_layout_wtapng_if_stats_mandatory_s() {
    const UNINIT: ::std::mem::MaybeUninit<wtapng_if_stats_mandatory_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wtapng_if_stats_mandatory_s>(),
        12usize,
        concat!("Size of: ", stringify!(wtapng_if_stats_mandatory_s))
    );
    assert_eq!(
        ::std::mem::align_of::<wtapng_if_stats_mandatory_s>(),
        4usize,
        concat!("Alignment of ", stringify!(wtapng_if_stats_mandatory_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtapng_if_stats_mandatory_s),
            "::",
            stringify!(interface_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ts_high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wtapng_if_stats_mandatory_s),
            "::",
            stringify!(ts_high)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ts_low) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wtapng_if_stats_mandatory_s),
            "::",
            stringify!(ts_low)
        )
    );
}
#[doc = " Holds the required data from a WTAP_BLOCK_IF_STATISTICS."]
pub type wtapng_if_stats_mandatory_t = wtapng_if_stats_mandatory_s;
#[doc = " Holds the required data from a WTAP_BLOCK_DECRYPTION_SECRETS."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtapng_dsb_mandatory_s {
    pub secrets_type: guint32,
    #[doc = " Type of secrets stored in data (see secrets-types.h)"]
    pub secrets_len: guint32,
    #[doc = " Length of the secrets data in bytes"]
    pub secrets_data: *mut guint8,
}
#[test]
fn bindgen_test_layout_wtapng_dsb_mandatory_s() {
    const UNINIT: ::std::mem::MaybeUninit<wtapng_dsb_mandatory_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wtapng_dsb_mandatory_s>(),
        16usize,
        concat!("Size of: ", stringify!(wtapng_dsb_mandatory_s))
    );
    assert_eq!(
        ::std::mem::align_of::<wtapng_dsb_mandatory_s>(),
        8usize,
        concat!("Alignment of ", stringify!(wtapng_dsb_mandatory_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).secrets_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtapng_dsb_mandatory_s),
            "::",
            stringify!(secrets_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).secrets_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wtapng_dsb_mandatory_s),
            "::",
            stringify!(secrets_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).secrets_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wtapng_dsb_mandatory_s),
            "::",
            stringify!(secrets_data)
        )
    );
}
#[doc = " Holds the required data from a WTAP_BLOCK_DECRYPTION_SECRETS."]
pub type wtapng_dsb_mandatory_t = wtapng_dsb_mandatory_s;
#[doc = " Holds the required data from a WTAP_BLOCK_SYSDIG_META_EVENT."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtapng_sysdig_mev_mandatory_s {
    pub mev_type: u32,
    #[doc = " pcapng block type of the event, e.g. BLOCK_TYPE_SYSDIG_MI"]
    pub mev_data_len: u32,
    #[doc = " Length of the mev data in bytes"]
    pub mev_data: *mut u8,
}
#[test]
fn bindgen_test_layout_wtapng_sysdig_mev_mandatory_s() {
    const UNINIT: ::std::mem::MaybeUninit<wtapng_sysdig_mev_mandatory_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wtapng_sysdig_mev_mandatory_s>(),
        16usize,
        concat!("Size of: ", stringify!(wtapng_sysdig_mev_mandatory_s))
    );
    assert_eq!(
        ::std::mem::align_of::<wtapng_sysdig_mev_mandatory_s>(),
        8usize,
        concat!("Alignment of ", stringify!(wtapng_sysdig_mev_mandatory_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mev_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtapng_sysdig_mev_mandatory_s),
            "::",
            stringify!(mev_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mev_data_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wtapng_sysdig_mev_mandatory_s),
            "::",
            stringify!(mev_data_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mev_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wtapng_sysdig_mev_mandatory_s),
            "::",
            stringify!(mev_data)
        )
    );
}
#[doc = " Holds the required data from a WTAP_BLOCK_SYSDIG_META_EVENT."]
pub type wtapng_sysdig_mev_mandatory_t = wtapng_sysdig_mev_mandatory_s;
#[doc = " Holds the required data from a WTAP_BLOCK_FT_SPECIFIC_REPORT."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtapng_ft_specific_mandatory_s {
    pub record_type: guint,
}
#[test]
fn bindgen_test_layout_wtapng_ft_specific_mandatory_s() {
    const UNINIT: ::std::mem::MaybeUninit<wtapng_ft_specific_mandatory_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wtapng_ft_specific_mandatory_s>(),
        4usize,
        concat!("Size of: ", stringify!(wtapng_ft_specific_mandatory_s))
    );
    assert_eq!(
        ::std::mem::align_of::<wtapng_ft_specific_mandatory_s>(),
        4usize,
        concat!("Alignment of ", stringify!(wtapng_ft_specific_mandatory_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).record_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtapng_ft_specific_mandatory_s),
            "::",
            stringify!(record_type)
        )
    );
}
#[doc = " Holds the required data from a WTAP_BLOCK_FT_SPECIFIC_REPORT."]
pub type wtapng_ft_specific_mandatory_t = wtapng_ft_specific_mandatory_s;
pub const wtap_opttype_e_WTAP_OPTTYPE_UINT8: wtap_opttype_e = 0;
pub const wtap_opttype_e_WTAP_OPTTYPE_UINT32: wtap_opttype_e = 1;
pub const wtap_opttype_e_WTAP_OPTTYPE_UINT64: wtap_opttype_e = 2;
pub const wtap_opttype_e_WTAP_OPTTYPE_STRING: wtap_opttype_e = 3;
pub const wtap_opttype_e_WTAP_OPTTYPE_BYTES: wtap_opttype_e = 4;
pub const wtap_opttype_e_WTAP_OPTTYPE_IPv4: wtap_opttype_e = 5;
pub const wtap_opttype_e_WTAP_OPTTYPE_IPv6: wtap_opttype_e = 6;
pub const wtap_opttype_e_WTAP_OPTTYPE_CUSTOM: wtap_opttype_e = 7;
pub const wtap_opttype_e_WTAP_OPTTYPE_IF_FILTER: wtap_opttype_e = 8;
pub const wtap_opttype_e_WTAP_OPTTYPE_PACKET_VERDICT: wtap_opttype_e = 9;
pub const wtap_opttype_e_WTAP_OPTTYPE_PACKET_HASH: wtap_opttype_e = 10;
pub const wtap_opttype_e_WTAP_OPTTYPE_INT8: wtap_opttype_e = 11;
pub const wtap_opttype_e_WTAP_OPTTYPE_INT32: wtap_opttype_e = 12;
pub const wtap_opttype_e_WTAP_OPTTYPE_INT64: wtap_opttype_e = 13;
pub type wtap_opttype_e = ::std::os::raw::c_int;
pub const wtap_opttype_return_val_WTAP_OPTTYPE_SUCCESS: wtap_opttype_return_val = 0;
pub const wtap_opttype_return_val_WTAP_OPTTYPE_NO_SUCH_OPTION: wtap_opttype_return_val = -1;
pub const wtap_opttype_return_val_WTAP_OPTTYPE_NOT_FOUND: wtap_opttype_return_val = -2;
pub const wtap_opttype_return_val_WTAP_OPTTYPE_TYPE_MISMATCH: wtap_opttype_return_val = -3;
pub const wtap_opttype_return_val_WTAP_OPTTYPE_NUMBER_MISMATCH: wtap_opttype_return_val = -4;
pub const wtap_opttype_return_val_WTAP_OPTTYPE_ALREADY_EXISTS: wtap_opttype_return_val = -5;
pub const wtap_opttype_return_val_WTAP_OPTTYPE_BAD_BLOCK: wtap_opttype_return_val = -6;
pub type wtap_opttype_return_val = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct custom_opt_s {
    pub pen: guint32,
    pub data: custom_opt_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union custom_opt_s__bindgen_ty_1 {
    pub generic_data: custom_opt_s__bindgen_ty_1_generic_custom_opt_data,
    pub nflx_data: custom_opt_s__bindgen_ty_1_nflx_custom_opt_data,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct custom_opt_s__bindgen_ty_1_generic_custom_opt_data {
    pub custom_data_len: gsize,
    pub custom_data: *mut gchar,
}
#[test]
fn bindgen_test_layout_custom_opt_s__bindgen_ty_1_generic_custom_opt_data() {
    const UNINIT: ::std::mem::MaybeUninit<custom_opt_s__bindgen_ty_1_generic_custom_opt_data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<custom_opt_s__bindgen_ty_1_generic_custom_opt_data>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(custom_opt_s__bindgen_ty_1_generic_custom_opt_data)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<custom_opt_s__bindgen_ty_1_generic_custom_opt_data>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(custom_opt_s__bindgen_ty_1_generic_custom_opt_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_data_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_opt_s__bindgen_ty_1_generic_custom_opt_data),
            "::",
            stringify!(custom_data_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_opt_s__bindgen_ty_1_generic_custom_opt_data),
            "::",
            stringify!(custom_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct custom_opt_s__bindgen_ty_1_nflx_custom_opt_data {
    pub type_: guint32,
    pub custom_data_len: gsize,
    pub custom_data: *mut gchar,
    pub use_little_endian: gboolean,
}
#[test]
fn bindgen_test_layout_custom_opt_s__bindgen_ty_1_nflx_custom_opt_data() {
    const UNINIT: ::std::mem::MaybeUninit<custom_opt_s__bindgen_ty_1_nflx_custom_opt_data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<custom_opt_s__bindgen_ty_1_nflx_custom_opt_data>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(custom_opt_s__bindgen_ty_1_nflx_custom_opt_data)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<custom_opt_s__bindgen_ty_1_nflx_custom_opt_data>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(custom_opt_s__bindgen_ty_1_nflx_custom_opt_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_opt_s__bindgen_ty_1_nflx_custom_opt_data),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_data_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_opt_s__bindgen_ty_1_nflx_custom_opt_data),
            "::",
            stringify!(custom_data_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_opt_s__bindgen_ty_1_nflx_custom_opt_data),
            "::",
            stringify!(custom_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_little_endian) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_opt_s__bindgen_ty_1_nflx_custom_opt_data),
            "::",
            stringify!(use_little_endian)
        )
    );
}
#[test]
fn bindgen_test_layout_custom_opt_s__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<custom_opt_s__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<custom_opt_s__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(custom_opt_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<custom_opt_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(custom_opt_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).generic_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_opt_s__bindgen_ty_1),
            "::",
            stringify!(generic_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nflx_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_opt_s__bindgen_ty_1),
            "::",
            stringify!(nflx_data)
        )
    );
}
#[test]
fn bindgen_test_layout_custom_opt_s() {
    const UNINIT: ::std::mem::MaybeUninit<custom_opt_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<custom_opt_s>(),
        40usize,
        concat!("Size of: ", stringify!(custom_opt_s))
    );
    assert_eq!(
        ::std::mem::align_of::<custom_opt_s>(),
        8usize,
        concat!("Alignment of ", stringify!(custom_opt_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_opt_s),
            "::",
            stringify!(pen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(custom_opt_s),
            "::",
            stringify!(data)
        )
    );
}
pub type custom_opt_t = custom_opt_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nflx_custom_opt_s {
    pub nflx_use_little_endian: gboolean,
    pub nflx_type: guint32,
    pub nflx_custom_data_len: gsize,
    pub nflx_custom_data: *mut gchar,
}
#[test]
fn bindgen_test_layout_nflx_custom_opt_s() {
    const UNINIT: ::std::mem::MaybeUninit<nflx_custom_opt_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nflx_custom_opt_s>(),
        24usize,
        concat!("Size of: ", stringify!(nflx_custom_opt_s))
    );
    assert_eq!(
        ::std::mem::align_of::<nflx_custom_opt_s>(),
        8usize,
        concat!("Alignment of ", stringify!(nflx_custom_opt_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nflx_use_little_endian) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_custom_opt_s),
            "::",
            stringify!(nflx_use_little_endian)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nflx_type) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_custom_opt_s),
            "::",
            stringify!(nflx_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nflx_custom_data_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_custom_opt_s),
            "::",
            stringify!(nflx_custom_data_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nflx_custom_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_custom_opt_s),
            "::",
            stringify!(nflx_custom_data)
        )
    );
}
pub type nflx_custom_opt_t = nflx_custom_opt_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_bpf_insn_s {
    pub code: guint16,
    pub jt: guint8,
    pub jf: guint8,
    pub k: guint32,
}
#[test]
fn bindgen_test_layout_wtap_bpf_insn_s() {
    const UNINIT: ::std::mem::MaybeUninit<wtap_bpf_insn_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wtap_bpf_insn_s>(),
        8usize,
        concat!("Size of: ", stringify!(wtap_bpf_insn_s))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_bpf_insn_s>(),
        4usize,
        concat!("Alignment of ", stringify!(wtap_bpf_insn_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_bpf_insn_s),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).jt) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_bpf_insn_s),
            "::",
            stringify!(jt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).jf) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_bpf_insn_s),
            "::",
            stringify!(jf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).k) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_bpf_insn_s),
            "::",
            stringify!(k)
        )
    );
}
pub type wtap_bpf_insn_t = wtap_bpf_insn_s;
pub const if_filter_type_e_if_filter_pcap: if_filter_type_e = 0;
pub const if_filter_type_e_if_filter_bpf: if_filter_type_e = 1;
pub type if_filter_type_e = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct if_filter_opt_s {
    pub type_: if_filter_type_e,
    pub data: if_filter_opt_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union if_filter_opt_s__bindgen_ty_1 {
    #[doc = "< pcap filter string"]
    pub filter_str: *mut gchar,
    #[doc = "< BPF program"]
    pub bpf_prog: if_filter_opt_s__bindgen_ty_1_wtap_bpf_insns,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct if_filter_opt_s__bindgen_ty_1_wtap_bpf_insns {
    #[doc = "< number of BPF instructions"]
    pub bpf_prog_len: guint,
    #[doc = "< BPF instructions"]
    pub bpf_prog: *mut wtap_bpf_insn_t,
}
#[test]
fn bindgen_test_layout_if_filter_opt_s__bindgen_ty_1_wtap_bpf_insns() {
    const UNINIT: ::std::mem::MaybeUninit<if_filter_opt_s__bindgen_ty_1_wtap_bpf_insns> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<if_filter_opt_s__bindgen_ty_1_wtap_bpf_insns>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(if_filter_opt_s__bindgen_ty_1_wtap_bpf_insns)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<if_filter_opt_s__bindgen_ty_1_wtap_bpf_insns>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(if_filter_opt_s__bindgen_ty_1_wtap_bpf_insns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bpf_prog_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(if_filter_opt_s__bindgen_ty_1_wtap_bpf_insns),
            "::",
            stringify!(bpf_prog_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bpf_prog) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(if_filter_opt_s__bindgen_ty_1_wtap_bpf_insns),
            "::",
            stringify!(bpf_prog)
        )
    );
}
#[test]
fn bindgen_test_layout_if_filter_opt_s__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<if_filter_opt_s__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<if_filter_opt_s__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(if_filter_opt_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<if_filter_opt_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(if_filter_opt_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter_str) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(if_filter_opt_s__bindgen_ty_1),
            "::",
            stringify!(filter_str)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bpf_prog) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(if_filter_opt_s__bindgen_ty_1),
            "::",
            stringify!(bpf_prog)
        )
    );
}
#[test]
fn bindgen_test_layout_if_filter_opt_s() {
    const UNINIT: ::std::mem::MaybeUninit<if_filter_opt_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<if_filter_opt_s>(),
        24usize,
        concat!("Size of: ", stringify!(if_filter_opt_s))
    );
    assert_eq!(
        ::std::mem::align_of::<if_filter_opt_s>(),
        8usize,
        concat!("Alignment of ", stringify!(if_filter_opt_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(if_filter_opt_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(if_filter_opt_s),
            "::",
            stringify!(data)
        )
    );
}
pub type if_filter_opt_t = if_filter_opt_s;
pub const packet_verdict_type_e_packet_verdict_hardware: packet_verdict_type_e = 0;
pub const packet_verdict_type_e_packet_verdict_linux_ebpf_tc: packet_verdict_type_e = 1;
pub const packet_verdict_type_e_packet_verdict_linux_ebpf_xdp: packet_verdict_type_e = 2;
pub type packet_verdict_type_e = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct packet_verdict_opt_s {
    pub type_: packet_verdict_type_e,
    pub data: packet_verdict_opt_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union packet_verdict_opt_s__bindgen_ty_1 {
    pub verdict_bytes: *mut GByteArray,
    pub verdict_linux_ebpf_tc: guint64,
    pub verdict_linux_ebpf_xdp: guint64,
}
#[test]
fn bindgen_test_layout_packet_verdict_opt_s__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<packet_verdict_opt_s__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<packet_verdict_opt_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(packet_verdict_opt_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<packet_verdict_opt_s__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(packet_verdict_opt_s__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).verdict_bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(packet_verdict_opt_s__bindgen_ty_1),
            "::",
            stringify!(verdict_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).verdict_linux_ebpf_tc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(packet_verdict_opt_s__bindgen_ty_1),
            "::",
            stringify!(verdict_linux_ebpf_tc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).verdict_linux_ebpf_xdp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(packet_verdict_opt_s__bindgen_ty_1),
            "::",
            stringify!(verdict_linux_ebpf_xdp)
        )
    );
}
#[test]
fn bindgen_test_layout_packet_verdict_opt_s() {
    const UNINIT: ::std::mem::MaybeUninit<packet_verdict_opt_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<packet_verdict_opt_s>(),
        16usize,
        concat!("Size of: ", stringify!(packet_verdict_opt_s))
    );
    assert_eq!(
        ::std::mem::align_of::<packet_verdict_opt_s>(),
        8usize,
        concat!("Alignment of ", stringify!(packet_verdict_opt_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(packet_verdict_opt_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(packet_verdict_opt_s),
            "::",
            stringify!(data)
        )
    );
}
pub type packet_verdict_opt_t = packet_verdict_opt_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct packet_hash_opt_s {
    pub type_: guint8,
    pub hash_bytes: *mut GByteArray,
}
#[test]
fn bindgen_test_layout_packet_hash_opt_s() {
    const UNINIT: ::std::mem::MaybeUninit<packet_hash_opt_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<packet_hash_opt_s>(),
        16usize,
        concat!("Size of: ", stringify!(packet_hash_opt_s))
    );
    assert_eq!(
        ::std::mem::align_of::<packet_hash_opt_s>(),
        8usize,
        concat!("Alignment of ", stringify!(packet_hash_opt_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(packet_hash_opt_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash_bytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(packet_hash_opt_s),
            "::",
            stringify!(hash_bytes)
        )
    );
}
pub type packet_hash_opt_t = packet_hash_opt_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub union wtap_optval_t {
    pub uint8val: guint8,
    pub uint32val: guint32,
    pub uint64val: guint64,
    pub int8val: gint8,
    pub int32val: gint32,
    pub int64val: gint64,
    pub ipv4val: ws_in4_addr,
    pub ipv6val: ws_in6_addr,
    pub stringval: *mut ::std::os::raw::c_char,
    pub byteval: *mut GBytes,
    pub custom_opt: custom_opt_t,
    pub if_filterval: if_filter_opt_t,
    pub packet_verdictval: packet_verdict_opt_t,
    pub packet_hash: packet_hash_opt_t,
}
#[test]
fn bindgen_test_layout_wtap_optval_t() {
    const UNINIT: ::std::mem::MaybeUninit<wtap_optval_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wtap_optval_t>(),
        40usize,
        concat!("Size of: ", stringify!(wtap_optval_t))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_optval_t>(),
        8usize,
        concat!("Alignment of ", stringify!(wtap_optval_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uint8val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_optval_t),
            "::",
            stringify!(uint8val)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uint32val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_optval_t),
            "::",
            stringify!(uint32val)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uint64val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_optval_t),
            "::",
            stringify!(uint64val)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int8val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_optval_t),
            "::",
            stringify!(int8val)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int32val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_optval_t),
            "::",
            stringify!(int32val)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int64val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_optval_t),
            "::",
            stringify!(int64val)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipv4val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_optval_t),
            "::",
            stringify!(ipv4val)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipv6val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_optval_t),
            "::",
            stringify!(ipv6val)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stringval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_optval_t),
            "::",
            stringify!(stringval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byteval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_optval_t),
            "::",
            stringify!(byteval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_opt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_optval_t),
            "::",
            stringify!(custom_opt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).if_filterval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_optval_t),
            "::",
            stringify!(if_filterval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packet_verdictval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_optval_t),
            "::",
            stringify!(packet_verdictval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packet_hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_optval_t),
            "::",
            stringify!(packet_hash)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wtap_option_t {
    #[doc = "< option code for the option"]
    pub option_id: guint,
    #[doc = "< value"]
    pub value: wtap_optval_t,
}
#[test]
fn bindgen_test_layout_wtap_option_t() {
    const UNINIT: ::std::mem::MaybeUninit<wtap_option_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wtap_option_t>(),
        48usize,
        concat!("Size of: ", stringify!(wtap_option_t))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_option_t>(),
        8usize,
        concat!("Alignment of ", stringify!(wtap_option_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).option_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_option_t),
            "::",
            stringify!(option_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_option_t),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nflx_dumpinfo {
    pub tlh_version: guint32,
    pub tlh_type: guint32,
    pub tlh_length: guint64,
    pub tlh_ie_fport: guint16,
    pub tlh_ie_lport: guint16,
    pub tlh_ie_faddr_addr32: [guint32; 4usize],
    pub tlh_ie_laddr_addr32: [guint32; 4usize],
    pub tlh_ie_zoneid: guint32,
    pub tlh_offset_tv_sec: guint64,
    pub tlh_offset_tv_usec: guint64,
    pub tlh_id: [::std::os::raw::c_char; 64usize],
    pub tlh_reason: [::std::os::raw::c_char; 32usize],
    pub tlh_tag: [::std::os::raw::c_char; 32usize],
    pub tlh_af: guint8,
    pub _pad: [guint8; 7usize],
}
#[test]
fn bindgen_test_layout_nflx_dumpinfo() {
    const UNINIT: ::std::mem::MaybeUninit<nflx_dumpinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nflx_dumpinfo>(),
        208usize,
        concat!("Size of: ", stringify!(nflx_dumpinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<nflx_dumpinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(nflx_dumpinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlh_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_dumpinfo),
            "::",
            stringify!(tlh_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlh_type) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_dumpinfo),
            "::",
            stringify!(tlh_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlh_length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_dumpinfo),
            "::",
            stringify!(tlh_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlh_ie_fport) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_dumpinfo),
            "::",
            stringify!(tlh_ie_fport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlh_ie_lport) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_dumpinfo),
            "::",
            stringify!(tlh_ie_lport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlh_ie_faddr_addr32) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_dumpinfo),
            "::",
            stringify!(tlh_ie_faddr_addr32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlh_ie_laddr_addr32) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_dumpinfo),
            "::",
            stringify!(tlh_ie_laddr_addr32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlh_ie_zoneid) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_dumpinfo),
            "::",
            stringify!(tlh_ie_zoneid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlh_offset_tv_sec) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_dumpinfo),
            "::",
            stringify!(tlh_offset_tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlh_offset_tv_usec) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_dumpinfo),
            "::",
            stringify!(tlh_offset_tv_usec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlh_id) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_dumpinfo),
            "::",
            stringify!(tlh_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlh_reason) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_dumpinfo),
            "::",
            stringify!(tlh_reason)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlh_tag) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_dumpinfo),
            "::",
            stringify!(tlh_tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlh_af) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_dumpinfo),
            "::",
            stringify!(tlh_af)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._pad) as usize - ptr as usize },
        201usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_dumpinfo),
            "::",
            stringify!(_pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nflx_tcpinfo {
    pub tlb_tv_sec: guint64,
    pub tlb_tv_usec: guint64,
    pub tlb_ticks: guint32,
    pub tlb_sn: guint32,
    pub tlb_stackid: guint8,
    pub tlb_eventid: guint8,
    pub tlb_eventflags: guint16,
    pub tlb_errno: gint32,
    pub tlb_rxbuf_tls_sb_acc: guint32,
    pub tlb_rxbuf_tls_sb_ccc: guint32,
    pub tlb_rxbuf_tls_sb_spare: guint32,
    pub tlb_txbuf_tls_sb_acc: guint32,
    pub tlb_txbuf_tls_sb_ccc: guint32,
    pub tlb_txbuf_tls_sb_spare: guint32,
    pub tlb_state: gint32,
    pub tlb_starttime: guint32,
    pub tlb_iss: guint32,
    pub tlb_flags: guint32,
    pub tlb_snd_una: guint32,
    pub tlb_snd_max: guint32,
    pub tlb_snd_cwnd: guint32,
    pub tlb_snd_nxt: guint32,
    pub tlb_snd_recover: guint32,
    pub tlb_snd_wnd: guint32,
    pub tlb_snd_ssthresh: guint32,
    pub tlb_srtt: guint32,
    pub tlb_rttvar: guint32,
    pub tlb_rcv_up: guint32,
    pub tlb_rcv_adv: guint32,
    pub tlb_flags2: guint32,
    pub tlb_rcv_nxt: guint32,
    pub tlb_rcv_wnd: guint32,
    pub tlb_dupacks: guint32,
    pub tlb_segqlen: gint32,
    pub tlb_snd_numholes: gint32,
    pub tlb_flex1: guint32,
    pub tlb_flex2: guint32,
    pub tlb_fbyte_in: guint32,
    pub tlb_fbyte_out: guint32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub _pad: [guint8; 3usize],
    pub tlb_stackinfo_bbr_cur_del_rate: guint64,
    pub tlb_stackinfo_bbr_delRate: guint64,
    pub tlb_stackinfo_bbr_rttProp: guint64,
    pub tlb_stackinfo_bbr_bw_inuse: guint64,
    pub tlb_stackinfo_bbr_inflight: guint32,
    pub tlb_stackinfo_bbr_applimited: guint32,
    pub tlb_stackinfo_bbr_delivered: guint32,
    pub tlb_stackinfo_bbr_timeStamp: guint32,
    pub tlb_stackinfo_bbr_epoch: guint32,
    pub tlb_stackinfo_bbr_lt_epoch: guint32,
    pub tlb_stackinfo_bbr_pkts_out: guint32,
    pub tlb_stackinfo_bbr_flex1: guint32,
    pub tlb_stackinfo_bbr_flex2: guint32,
    pub tlb_stackinfo_bbr_flex3: guint32,
    pub tlb_stackinfo_bbr_flex4: guint32,
    pub tlb_stackinfo_bbr_flex5: guint32,
    pub tlb_stackinfo_bbr_flex6: guint32,
    pub tlb_stackinfo_bbr_lost: guint32,
    pub tlb_stackinfo_bbr_pacing_gain: guint16,
    pub tlb_stackinfo_bbr_cwnd_gain: guint16,
    pub tlb_stackinfo_bbr_flex7: guint16,
    pub tlb_stackinfo_bbr_bbr_state: guint8,
    pub tlb_stackinfo_bbr_bbr_substate: guint8,
    pub tlb_stackinfo_bbr_inhpts: guint8,
    pub tlb_stackinfo_bbr_ininput: guint8,
    pub tlb_stackinfo_bbr_use_lt_bw: guint8,
    pub tlb_stackinfo_bbr_flex8: guint8,
    pub tlb_stackinfo_bbr_pkt_epoch: guint32,
    pub tlb_len: guint32,
}
#[test]
fn bindgen_test_layout_nflx_tcpinfo() {
    const UNINIT: ::std::mem::MaybeUninit<nflx_tcpinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nflx_tcpinfo>(),
        272usize,
        concat!("Size of: ", stringify!(nflx_tcpinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<nflx_tcpinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(nflx_tcpinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_tv_usec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_ticks) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_ticks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_sn) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_sn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_stackid) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_eventid) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_eventid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_eventflags) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_eventflags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_errno) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_errno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_rxbuf_tls_sb_acc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_rxbuf_tls_sb_acc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_rxbuf_tls_sb_ccc) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_rxbuf_tls_sb_ccc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_rxbuf_tls_sb_spare) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_rxbuf_tls_sb_spare)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_txbuf_tls_sb_acc) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_txbuf_tls_sb_acc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_txbuf_tls_sb_ccc) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_txbuf_tls_sb_ccc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_txbuf_tls_sb_spare) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_txbuf_tls_sb_spare)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_state) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_starttime) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_starttime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_iss) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_iss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_flags) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_snd_una) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_snd_una)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_snd_max) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_snd_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_snd_cwnd) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_snd_cwnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_snd_nxt) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_snd_nxt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_snd_recover) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_snd_recover)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_snd_wnd) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_snd_wnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_snd_ssthresh) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_snd_ssthresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_srtt) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_srtt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_rttvar) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_rttvar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_rcv_up) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_rcv_up)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_rcv_adv) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_rcv_adv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_rcv_nxt) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_rcv_nxt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_rcv_wnd) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_rcv_wnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_dupacks) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_dupacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_segqlen) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_segqlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_snd_numholes) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_snd_numholes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_flex1) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_flex1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_flex2) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_flex2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_fbyte_in) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_fbyte_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_fbyte_out) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_fbyte_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._pad) as usize - ptr as usize },
        157usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).tlb_stackinfo_bbr_cur_del_rate) as usize - ptr as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackinfo_bbr_cur_del_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_stackinfo_bbr_delRate) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackinfo_bbr_delRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_stackinfo_bbr_rttProp) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackinfo_bbr_rttProp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_stackinfo_bbr_bw_inuse) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackinfo_bbr_bw_inuse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_stackinfo_bbr_inflight) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackinfo_bbr_inflight)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).tlb_stackinfo_bbr_applimited) as usize - ptr as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackinfo_bbr_applimited)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_stackinfo_bbr_delivered) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackinfo_bbr_delivered)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_stackinfo_bbr_timeStamp) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackinfo_bbr_timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_stackinfo_bbr_epoch) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackinfo_bbr_epoch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_stackinfo_bbr_lt_epoch) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackinfo_bbr_lt_epoch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_stackinfo_bbr_pkts_out) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackinfo_bbr_pkts_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_stackinfo_bbr_flex1) as usize - ptr as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackinfo_bbr_flex1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_stackinfo_bbr_flex2) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackinfo_bbr_flex2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_stackinfo_bbr_flex3) as usize - ptr as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackinfo_bbr_flex3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_stackinfo_bbr_flex4) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackinfo_bbr_flex4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_stackinfo_bbr_flex5) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackinfo_bbr_flex5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_stackinfo_bbr_flex6) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackinfo_bbr_flex6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_stackinfo_bbr_lost) as usize - ptr as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackinfo_bbr_lost)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).tlb_stackinfo_bbr_pacing_gain) as usize - ptr as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackinfo_bbr_pacing_gain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_stackinfo_bbr_cwnd_gain) as usize - ptr as usize },
        250usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackinfo_bbr_cwnd_gain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_stackinfo_bbr_flex7) as usize - ptr as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackinfo_bbr_flex7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_stackinfo_bbr_bbr_state) as usize - ptr as usize },
        254usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackinfo_bbr_bbr_state)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).tlb_stackinfo_bbr_bbr_substate) as usize - ptr as usize
        },
        255usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackinfo_bbr_bbr_substate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_stackinfo_bbr_inhpts) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackinfo_bbr_inhpts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_stackinfo_bbr_ininput) as usize - ptr as usize },
        257usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackinfo_bbr_ininput)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_stackinfo_bbr_use_lt_bw) as usize - ptr as usize },
        258usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackinfo_bbr_use_lt_bw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_stackinfo_bbr_flex8) as usize - ptr as usize },
        259usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackinfo_bbr_flex8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_stackinfo_bbr_pkt_epoch) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_stackinfo_bbr_pkt_epoch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tlb_len) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(nflx_tcpinfo),
            "::",
            stringify!(tlb_len)
        )
    );
}
impl nflx_tcpinfo {
    #[inline]
    pub fn tlb_snd_scale(&self) -> guint8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tlb_snd_scale(&mut self, val: guint8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn tlb_rcv_scale(&self) -> guint8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tlb_rcv_scale(&mut self, val: guint8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tlb_snd_scale: guint8,
        tlb_rcv_scale: guint8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let tlb_snd_scale: u8 = unsafe { ::std::mem::transmute(tlb_snd_scale) };
            tlb_snd_scale as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let tlb_rcv_scale: u8 = unsafe { ::std::mem::transmute(tlb_rcv_scale) };
            tlb_rcv_scale as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type wtap_block_create_func = ::std::option::Option<unsafe extern "C" fn(block: wtap_block_t)>;
pub type wtap_mand_free_func = ::std::option::Option<unsafe extern "C" fn(block: wtap_block_t)>;
pub type wtap_mand_copy_func =
    ::std::option::Option<unsafe extern "C" fn(dest_block: wtap_block_t, src_block: wtap_block_t)>;
extern "C" {
    #[doc = " Initialize block types.\n\n This is currently just a placeholder as nothing needs to be\n initialized yet.  Should handle \"registration\" when code is\n refactored to do so."]
    pub fn wtap_opttypes_initialize();
}
extern "C" {
    #[doc = " Create a block by type\n\n Return a newly allocated block with default options provided\n\n @param[in] block_type Block type to be created\n @return Newly allocated block"]
    pub fn wtap_block_create(block_type: wtap_block_type_t) -> wtap_block_t;
}
extern "C" {
    #[doc = " Increase reference count of a block\n\n Call when taking a copy of a block\n\n @param[in] block Block add ref to\n @return The block"]
    pub fn wtap_block_ref(block: wtap_block_t) -> wtap_block_t;
}
extern "C" {
    #[doc = " Decrease reference count of a block\n\n Needs to be called on any block once you're done with it\n\n @param[in] block Block to be deref'd"]
    pub fn wtap_block_unref(block: wtap_block_t);
}
extern "C" {
    #[doc = " Free an array of blocks\n\n Needs to be called to clean up blocks allocated\n through GArray (for multiple blocks of same type)\n Includes freeing the GArray\n\n @param[in] block_array Array of blocks to be freed"]
    pub fn wtap_block_array_free(block_array: *mut GArray);
}
extern "C" {
    #[doc = " Provide type of a block\n\n @param[in] block Block from which to retrieve mandatory data\n @return Block type."]
    pub fn wtap_block_get_type(block: wtap_block_t) -> wtap_block_type_t;
}
extern "C" {
    #[doc = " Provide mandatory data of a block\n\n @param[in] block Block from which to retrieve mandatory data\n @return Block mandatory data.  Structure varies based on block type"]
    pub fn wtap_block_get_mandatory_data(block: wtap_block_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Count the number of times the given option appears in the block\n\n @param[in] block Block to which to add the option\n @param[in] option_id Identifier value for option\n @return guint - the number of times the option was found"]
    pub fn wtap_block_count_option(block: wtap_block_t, option_id: guint) -> guint;
}
extern "C" {
    #[doc = " Add UINT8 option value to a block\n\n @param[in] block Block to which to add the option\n @param[in] option_id Identifier value for option\n @param[in] value Value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_add_uint8_option(
        block: wtap_block_t,
        option_id: guint,
        value: guint8,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Set UINT8 option value in a block\n\n @param[in] block Block in which to set the option value\n @param[in] option_id Identifier value for option\n @param[in] value New value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_set_uint8_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: guint8,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Get UINT8 option value from a block\n\n @param[in] block Block from which to get the option value\n @param[in] option_id Identifier value for option\n @param[out] value Returned value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_get_uint8_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: *mut guint8,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Add UINT32 option value to a block\n\n @param[in] block Block to which to add the option\n @param[in] option_id Identifier value for option\n @param[in] value Value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_add_uint32_option(
        block: wtap_block_t,
        option_id: guint,
        value: guint32,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Set UINT32 option value in a block\n\n @param[in] block Block in which to set the option value\n @param[in] option_id Identifier value for option\n @param[in] value New value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_set_uint32_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: guint32,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Get UINT32 option value from a block\n\n @param[in] block Block from which to get the option value\n @param[in] option_id Identifier value for option\n @param[out] value Returned value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_get_uint32_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: *mut guint32,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Add UINT64 option value to a block\n\n @param[in] block Block to which to add the option\n @param[in] option_id Identifier value for option\n @param[in] value Value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_add_uint64_option(
        block: wtap_block_t,
        option_id: guint,
        value: guint64,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Set UINT64 option value in a block\n\n @param[in] block Block in which to set the option value\n @param[in] option_id Identifier value for option\n @param[in] value New value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_set_uint64_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: guint64,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Get UINT64 option value from a block\n\n @param[in] block Block from which to get the option value\n @param[in] option_id Identifier value for option\n @param[out] value Returned value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_get_uint64_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: *mut guint64,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Add INT8 option value to a block\n\n @param[in] block Block to which to add the option\n @param[in] option_id Identifier value for option\n @param[in] value Value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_add_int8_option(
        block: wtap_block_t,
        option_id: guint,
        value: gint8,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Set INT8 option value in a block\n\n @param[in] block Block in which to set the option value\n @param[in] option_id Identifier value for option\n @param[in] value New value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_set_int8_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: gint8,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Get INT8 option value from a block\n\n @param[in] block Block from which to get the option value\n @param[in] option_id Identifier value for option\n @param[out] value Returned value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_get_int8_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: *mut gint8,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Add INT32 option value to a block\n\n @param[in] block Block to which to add the option\n @param[in] option_id Identifier value for option\n @param[in] value Value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_add_int32_option(
        block: wtap_block_t,
        option_id: guint,
        value: gint32,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Set INT32 option value in a block\n\n @param[in] block Block in which to set the option value\n @param[in] option_id Identifier value for option\n @param[in] value New value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_set_int32_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: gint32,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Get INT32 option value from a block\n\n @param[in] block Block from which to get the option value\n @param[in] option_id Identifier value for option\n @param[out] value Returned value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_get_int32_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: *mut gint32,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Add INT64 option value to a block\n\n @param[in] block Block to which to add the option\n @param[in] option_id Identifier value for option\n @param[in] value Value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_add_int64_option(
        block: wtap_block_t,
        option_id: guint,
        value: gint64,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Set INT64 option value in a block\n\n @param[in] block Block in which to set the option value\n @param[in] option_id Identifier value for option\n @param[in] value New value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_set_int64_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: gint64,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Get INT64 option value from a block\n\n @param[in] block Block from which to get the option value\n @param[in] option_id Identifier value for option\n @param[out] value Returned value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_get_int64_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: *mut gint64,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Add IPv4 address option value to a block\n\n @param[in] block Block to which to add the option\n @param[in] option_id Identifier value for option\n @param[in] value Value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_add_ipv4_option(
        block: wtap_block_t,
        option_id: guint,
        value: guint32,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Set IPv4 option value in a block\n\n @param[in] block Block in which to set the option value\n @param[in] option_id Identifier value for option\n @param[in] value New value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_set_ipv4_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: guint32,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Get IPv4 option value from a block\n\n @param[in] block Block from which to get the option value\n @param[in] option_id Identifier value for option\n @param[out] value Returned value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_get_ipv4_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: *mut guint32,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Add IPv6 address option value to a block\n\n @param[in] block Block to which to add the option\n @param[in] option_id Identifier value for option\n @param[in] value Value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_add_ipv6_option(
        block: wtap_block_t,
        option_id: guint,
        value: *mut ws_in6_addr,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Set IPv6 option value in a block\n\n @param[in] block Block in which to set the option value\n @param[in] option_id Identifier value for option\n @param[in] value New value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_set_ipv6_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: *mut ws_in6_addr,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Get IPv6 option value from a block\n\n @param[in] block Block from which to get the option value\n @param[in] option_id Identifier value for option\n @param[out] value Returned value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_get_ipv6_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: *mut ws_in6_addr,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Add a string option to a block\n\n @param[in] block Block to which to add the option\n @param[in] option_id Identifier value for option\n @param[in] value Value of option\n @param[in] value_length Maximum length of string to copy.\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_add_string_option(
        block: wtap_block_t,
        option_id: guint,
        value: *const ::std::os::raw::c_char,
        value_length: gsize,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Add a string option to a block taking ownership of the null-terminated string.\n\n @param[in] block Block to which to add the option\n @param[in] option_id Identifier value for option\n @param[in] value Value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_add_string_option_owned(
        block: wtap_block_t,
        option_id: guint,
        value: *mut ::std::os::raw::c_char,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Add a string option to a block with a printf-formatted string as its value\n\n @param[in] block Block to which to add the option\n @param[in] option_id Identifier value for option\n @param[in] format printf-like format string\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_add_string_option_format(
        block: wtap_block_t,
        option_id: guint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Set string option value in a block\n\n @param[in] block Block in which to set the option value\n @param[in] option_id Identifier value for option\n @param[in] value New value of option\n @param[in] value_length Maximum length of string to copy.\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_set_string_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: *const ::std::os::raw::c_char,
        value_length: gsize,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Set string option value for the nth instance of a particular option\n in a block\n\n @param[in] block Block in which to set the option value\n @param[in] option_id Identifier value for option\n @param[in] idx Instance number of option with that ID\n @param[in] value New value of option\n @param[in] value_length Maximum length of string to copy.\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_set_nth_string_option_value(
        block: wtap_block_t,
        option_id: guint,
        idx: guint,
        value: *const ::std::os::raw::c_char,
        value_length: gsize,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Set string option value in a block to a printf-formatted string\n\n @param[in] block Block in which to set the option value\n @param[in] option_id Identifier value for option\n @param[in] format printf-like format string\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_set_string_option_value_format(
        block: wtap_block_t,
        option_id: guint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Set string option value for the nth instance of a particular option\n in a block to a printf-formatted string\n\n @param[in] block Block in which to set the option value\n @param[in] option_id Identifier value for option\n @param[in] idx Instance number of option with that ID\n @param[in] format printf-like format string\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_set_nth_string_option_value_format(
        block: wtap_block_t,
        option_id: guint,
        idx: guint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Get string option value from a block\n\n @param[in] block Block from which to get the option value\n @param[in] option_id Identifier value for option\n @param[out] value Returned value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_get_string_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: *mut *mut ::std::os::raw::c_char,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Get string option value for the nth instance of a particular option\n in a block\n\n @param[in] block Block from which to get the option value\n @param[in] option_id Identifier value for option\n @param[in] idx Instance number of option with that ID\n @param[out] value Returned value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_get_nth_string_option_value(
        block: wtap_block_t,
        option_id: guint,
        idx: guint,
        value: *mut *mut ::std::os::raw::c_char,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Add a bytes option to a block\n\n @param[in] block Block to which to add the option\n @param[in] option_id Identifier value for option\n @param[in] value Value of option to copy\n @param[in] value_length Number of bytes to copy\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_add_bytes_option(
        block: wtap_block_t,
        option_id: guint,
        value: *const guint8,
        value_length: gsize,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Add a bytes option to a block, borrowing the value from a GBytes\n\n @param[in] block Block to which to add the option\n @param[in] option_id Identifier value for option\n @param[in] value Value of option as a GBytes\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_add_bytes_option_borrow(
        block: wtap_block_t,
        option_id: guint,
        value: *mut GBytes,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Set bytes option value in a block\n\n @param[in] block Block in which to set the option value\n @param[in] option_id Identifier value for option\n @param[in] value New value of option\n @param[in] value_length Number of bytes to copy.\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_set_bytes_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: *const guint8,
        value_length: gsize,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Set bytes option value for nth instance of a particular option in a block\n\n @param[in] block Block in which to set the option value\n @param[in] option_id Identifier value for option\n @param[in] idx Instance number of option with that ID\n @param[in] value New value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_set_nth_bytes_option_value(
        block: wtap_block_t,
        option_id: guint,
        idx: guint,
        value: *mut GBytes,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Get bytes option value from a block\n\n @param[in] block Block from which to get the option value\n @param[in] option_id Identifier value for option\n @param[out] value Returned value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise\n @note You should call g_bytes_ref() on value if you plan to keep it around\n (and then g_bytes_unref() when you're done with it)."]
    pub fn wtap_block_get_bytes_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: *mut *mut GBytes,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Get bytes option value for nth instance of a particular option in a block\n\n @param[in] block Block from which to get the option value\n @param[in] option_id Identifier value for option\n @param[in] idx Instance number of option with that ID\n @param[out] value Returned value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise\n @note You should call g_bytes_ref() on value if you plan to keep it around\n (and then g_bytes_unref() when you're done with it)."]
    pub fn wtap_block_get_nth_bytes_option_value(
        block: wtap_block_t,
        option_id: guint,
        idx: guint,
        value: *mut *mut GBytes,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Add an NFLX custom option to a block\n\n @param[in] block Block to which to add the option\n @param[in] nflx_type NFLX option type\n @param[in] nflx_custom_data pointer to the data\n @param[in] nflx_custom_data_len length of custom_data\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_add_nflx_custom_option(
        block: wtap_block_t,
        nflx_type: guint32,
        nflx_custom_data: *const ::std::os::raw::c_char,
        nflx_custom_data_len: gsize,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Get an NFLX custom option value from a block\n\n @param[in] block Block from which to get the option value\n @param[in] nflx_type type of the option\n @param[out] nflx_custom_data Returned value of NFLX custom option value\n @param[in] nflx_custom_data_len size of buffer provided in nflx_custom_data\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_get_nflx_custom_option(
        block: wtap_block_t,
        nflx_type: guint32,
        nflx_custom_data: *mut ::std::os::raw::c_char,
        nflx_custom_data_len: gsize,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Add a custom option to a block\n\n @param[in] block Block to which to add the option\n @param[in] option_id Identifier value for option\n @param[in] pen PEN\n @param[in] custom_data pointer to the data\n @param[in] custom_data_len length of custom_data\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_add_custom_option(
        block: wtap_block_t,
        option_id: guint,
        pen: guint32,
        custom_data: *const ::std::os::raw::c_char,
        custom_data_len: gsize,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Add an if_filter option value to a block\n\n @param[in] block Block to which to add the option\n @param[in] option_id Identifier value for option\n @param[in] value Value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_add_if_filter_option(
        block: wtap_block_t,
        option_id: guint,
        value: *mut if_filter_opt_t,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Set an if_filter option value in a block\n\n @param[in] block Block in which to set the option value\n @param[in] option_id Identifier value for option\n @param[in] value New value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_set_if_filter_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: *mut if_filter_opt_t,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Get an if_filter option value from a block\n\n @param[in] block Block from which to get the option value\n @param[in] option_id Identifier value for option\n @param[out] value Returned value of option value\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_get_if_filter_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: *mut if_filter_opt_t,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Add a packet_verdict option value to a block\n\n @param[in] block Block to which to add the option\n @param[in] option_id Identifier value for option\n @param[in] value Value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_add_packet_verdict_option(
        block: wtap_block_t,
        option_id: guint,
        value: *mut packet_verdict_opt_t,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Set packet_verdict option value for the nth instsance of a particular\n option in a block\n\n @param[in] block Block in which to set the option value\n @param[in] option_id Identifier value for option\n @param[in] idx Instance number of option with that ID\n @param[in] value New value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_set_nth_packet_verdict_option_value(
        block: wtap_block_t,
        option_id: guint,
        idx: guint,
        value: *mut packet_verdict_opt_t,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Get packet_verdict option value for the nth instance of a particular\n option in a block\n\n @param[in] block Block from which to get the option value\n @param[in] option_id Identifier value for option\n @param[in] idx Instance number of option with that ID\n @param[out] value Returned value of option value\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_get_nth_packet_verdict_option_value(
        block: wtap_block_t,
        option_id: guint,
        idx: guint,
        value: *mut packet_verdict_opt_t,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    pub fn wtap_packet_verdict_free(verdict: *mut packet_verdict_opt_t);
}
extern "C" {
    #[doc = " Add a packet_hash option value to a block\n\n @param[in] block Block to which to add the option\n @param[in] option_id Identifier value for option\n @param[in] value Value of option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_add_packet_hash_option(
        block: wtap_block_t,
        option_id: guint,
        value: *mut packet_hash_opt_t,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    pub fn wtap_packet_hash_free(hash: *mut packet_hash_opt_t);
}
extern "C" {
    #[doc = " Remove an option from a block\n\n @param[in] block Block from which to remove the option\n @param[in] option_id Identifier value for option\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_remove_option(
        block: wtap_block_t,
        option_id: guint,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Remove the nth instance of an option from a block\n\n @param[in] block Block from which to remove the option instance\n @param[in] option_id Identifier value for option\n @param[in] idx Instance number of option with that ID\n @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,\n error code otherwise"]
    pub fn wtap_block_remove_nth_option_instance(
        block: wtap_block_t,
        option_id: guint,
        idx: guint,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Copy a block to another.\n\n Any options that are in the destination but not the source are not removed.\n Options that are just in source will be added to destination\n\n @param[in] dest_block Block to be copied to\n @param[in] src_block Block to be copied from"]
    pub fn wtap_block_copy(dest_block: wtap_block_t, src_block: wtap_block_t);
}
extern "C" {
    #[doc = " Make a copy of a block.\n\n @param[in] block Block to be copied from\n @return Newly allocated copy of that block"]
    pub fn wtap_block_make_copy(block: wtap_block_t) -> wtap_block_t;
}
pub type wtap_block_foreach_func = ::std::option::Option<
    unsafe extern "C" fn(
        block: wtap_block_t,
        option_id: guint,
        option_type: wtap_opttype_e,
        option: *mut wtap_optval_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> gboolean,
>;
extern "C" {
    pub fn wtap_block_foreach_option(
        block: wtap_block_t,
        func: wtap_block_foreach_func,
        user_data: *mut ::std::os::raw::c_void,
    ) -> gboolean;
}
extern "C" {
    #[doc = " Cleanup the internal structures"]
    pub fn wtap_opttypes_cleanup();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eth_phdr {
    pub fcs_len: gint,
}
#[test]
fn bindgen_test_layout_eth_phdr() {
    const UNINIT: ::std::mem::MaybeUninit<eth_phdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<eth_phdr>(),
        4usize,
        concat!("Size of: ", stringify!(eth_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<eth_phdr>(),
        4usize,
        concat!("Alignment of ", stringify!(eth_phdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fcs_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_phdr),
            "::",
            stringify!(fcs_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dte_dce_phdr {
    pub flags: guint8,
}
#[test]
fn bindgen_test_layout_dte_dce_phdr() {
    const UNINIT: ::std::mem::MaybeUninit<dte_dce_phdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dte_dce_phdr>(),
        1usize,
        concat!("Size of: ", stringify!(dte_dce_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<dte_dce_phdr>(),
        1usize,
        concat!("Alignment of ", stringify!(dte_dce_phdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dte_dce_phdr),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct isdn_phdr {
    pub uton: gboolean,
    pub channel: guint8,
}
#[test]
fn bindgen_test_layout_isdn_phdr() {
    const UNINIT: ::std::mem::MaybeUninit<isdn_phdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isdn_phdr>(),
        8usize,
        concat!("Size of: ", stringify!(isdn_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<isdn_phdr>(),
        4usize,
        concat!("Alignment of ", stringify!(isdn_phdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uton) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(isdn_phdr),
            "::",
            stringify!(uton)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(isdn_phdr),
            "::",
            stringify!(channel)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atm_phdr {
    pub flags: guint32,
    pub aal: guint8,
    pub type_: guint8,
    pub subtype: guint8,
    pub vpi: guint16,
    pub vci: guint16,
    pub aal2_cid: guint8,
    pub channel: guint16,
    pub cells: guint16,
    pub aal5t_u2u: guint16,
    pub aal5t_len: guint16,
    pub aal5t_chksum: guint32,
}
#[test]
fn bindgen_test_layout_atm_phdr() {
    const UNINIT: ::std::mem::MaybeUninit<atm_phdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<atm_phdr>(),
        28usize,
        concat!("Size of: ", stringify!(atm_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<atm_phdr>(),
        4usize,
        concat!("Alignment of ", stringify!(atm_phdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atm_phdr),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aal) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(atm_phdr),
            "::",
            stringify!(aal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(atm_phdr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subtype) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(atm_phdr),
            "::",
            stringify!(subtype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vpi) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(atm_phdr),
            "::",
            stringify!(vpi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vci) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(atm_phdr),
            "::",
            stringify!(vci)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aal2_cid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(atm_phdr),
            "::",
            stringify!(aal2_cid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(atm_phdr),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cells) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(atm_phdr),
            "::",
            stringify!(cells)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aal5t_u2u) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(atm_phdr),
            "::",
            stringify!(aal5t_u2u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aal5t_len) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(atm_phdr),
            "::",
            stringify!(aal5t_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aal5t_chksum) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(atm_phdr),
            "::",
            stringify!(aal5t_chksum)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ascend_phdr {
    pub type_: guint16,
    pub user: [::std::os::raw::c_char; 64usize],
    pub sess: guint32,
    pub call_num: [::std::os::raw::c_char; 64usize],
    pub chunk: guint32,
    pub task: guint32,
}
#[test]
fn bindgen_test_layout_ascend_phdr() {
    const UNINIT: ::std::mem::MaybeUninit<ascend_phdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ascend_phdr>(),
        144usize,
        concat!("Size of: ", stringify!(ascend_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<ascend_phdr>(),
        4usize,
        concat!("Alignment of ", stringify!(ascend_phdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ascend_phdr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ascend_phdr),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sess) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(ascend_phdr),
            "::",
            stringify!(sess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).call_num) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ascend_phdr),
            "::",
            stringify!(call_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chunk) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ascend_phdr),
            "::",
            stringify!(chunk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).task) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(ascend_phdr),
            "::",
            stringify!(task)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct p2p_phdr {
    pub sent: gboolean,
}
#[test]
fn bindgen_test_layout_p2p_phdr() {
    const UNINIT: ::std::mem::MaybeUninit<p2p_phdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<p2p_phdr>(),
        4usize,
        concat!("Size of: ", stringify!(p2p_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<p2p_phdr>(),
        4usize,
        concat!("Alignment of ", stringify!(p2p_phdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(p2p_phdr),
            "::",
            stringify!(sent)
        )
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ieee_802_11_fhss {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
    pub hop_set: guint8,
    pub hop_pattern: guint8,
    pub hop_index: guint8,
}
#[test]
fn bindgen_test_layout_ieee_802_11_fhss() {
    const UNINIT: ::std::mem::MaybeUninit<ieee_802_11_fhss> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ieee_802_11_fhss>(),
        8usize,
        concat!("Size of: ", stringify!(ieee_802_11_fhss))
    );
    assert_eq!(
        ::std::mem::align_of::<ieee_802_11_fhss>(),
        4usize,
        concat!("Alignment of ", stringify!(ieee_802_11_fhss))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hop_set) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11_fhss),
            "::",
            stringify!(hop_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hop_pattern) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11_fhss),
            "::",
            stringify!(hop_pattern)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hop_index) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11_fhss),
            "::",
            stringify!(hop_index)
        )
    );
}
impl ieee_802_11_fhss {
    #[inline]
    pub fn has_hop_set(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_hop_set(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_hop_pattern(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_hop_pattern(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_hop_index(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_hop_index(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        has_hop_set: guint,
        has_hop_pattern: guint,
        has_hop_index: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_hop_set: u32 = unsafe { ::std::mem::transmute(has_hop_set) };
            has_hop_set as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_hop_pattern: u32 = unsafe { ::std::mem::transmute(has_hop_pattern) };
            has_hop_pattern as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let has_hop_index: u32 = unsafe { ::std::mem::transmute(has_hop_index) };
            has_hop_index as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee_802_11b {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub short_preamble: gboolean,
}
#[test]
fn bindgen_test_layout_ieee_802_11b() {
    const UNINIT: ::std::mem::MaybeUninit<ieee_802_11b> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ieee_802_11b>(),
        8usize,
        concat!("Size of: ", stringify!(ieee_802_11b))
    );
    assert_eq!(
        ::std::mem::align_of::<ieee_802_11b>(),
        4usize,
        concat!("Alignment of ", stringify!(ieee_802_11b))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).short_preamble) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11b),
            "::",
            stringify!(short_preamble)
        )
    );
}
impl ieee_802_11b {
    #[inline]
    pub fn has_short_preamble(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_short_preamble(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(has_short_preamble: guint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_short_preamble: u32 = unsafe { ::std::mem::transmute(has_short_preamble) };
            has_short_preamble as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ieee_802_11a {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_ieee_802_11a() {
    assert_eq!(
        ::std::mem::size_of::<ieee_802_11a>(),
        4usize,
        concat!("Size of: ", stringify!(ieee_802_11a))
    );
    assert_eq!(
        ::std::mem::align_of::<ieee_802_11a>(),
        4usize,
        concat!("Alignment of ", stringify!(ieee_802_11a))
    );
}
impl ieee_802_11a {
    #[inline]
    pub fn has_channel_type(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_channel_type(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_turbo_type(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_turbo_type(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel_type(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_channel_type(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn turbo_type(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_turbo_type(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        has_channel_type: guint,
        has_turbo_type: guint,
        channel_type: guint,
        turbo_type: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_channel_type: u32 = unsafe { ::std::mem::transmute(has_channel_type) };
            has_channel_type as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_turbo_type: u32 = unsafe { ::std::mem::transmute(has_turbo_type) };
            has_turbo_type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let channel_type: u32 = unsafe { ::std::mem::transmute(channel_type) };
            channel_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let turbo_type: u32 = unsafe { ::std::mem::transmute(turbo_type) };
            turbo_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee_802_11g {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub mode: guint32,
}
#[test]
fn bindgen_test_layout_ieee_802_11g() {
    const UNINIT: ::std::mem::MaybeUninit<ieee_802_11g> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ieee_802_11g>(),
        8usize,
        concat!("Size of: ", stringify!(ieee_802_11g))
    );
    assert_eq!(
        ::std::mem::align_of::<ieee_802_11g>(),
        4usize,
        concat!("Alignment of ", stringify!(ieee_802_11g))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11g),
            "::",
            stringify!(mode)
        )
    );
}
impl ieee_802_11g {
    #[inline]
    pub fn has_mode(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_mode(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(has_mode: guint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_mode: u32 = unsafe { ::std::mem::transmute(has_mode) };
            has_mode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee_802_11n {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u16,
    pub mcs_index: guint16,
    pub bandwidth: guint,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub ness: guint,
}
#[test]
fn bindgen_test_layout_ieee_802_11n() {
    const UNINIT: ::std::mem::MaybeUninit<ieee_802_11n> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ieee_802_11n>(),
        20usize,
        concat!("Size of: ", stringify!(ieee_802_11n))
    );
    assert_eq!(
        ::std::mem::align_of::<ieee_802_11n>(),
        4usize,
        concat!("Alignment of ", stringify!(ieee_802_11n))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mcs_index) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11n),
            "::",
            stringify!(mcs_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bandwidth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11n),
            "::",
            stringify!(bandwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ness) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11n),
            "::",
            stringify!(ness)
        )
    );
}
impl ieee_802_11n {
    #[inline]
    pub fn has_mcs_index(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_mcs_index(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_bandwidth(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_bandwidth(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_short_gi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_short_gi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_greenfield(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_greenfield(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_fec(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_fec(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_stbc_streams(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_stbc_streams(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_ness(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_ness(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        has_mcs_index: guint,
        has_bandwidth: guint,
        has_short_gi: guint,
        has_greenfield: guint,
        has_fec: guint,
        has_stbc_streams: guint,
        has_ness: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_mcs_index: u32 = unsafe { ::std::mem::transmute(has_mcs_index) };
            has_mcs_index as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_bandwidth: u32 = unsafe { ::std::mem::transmute(has_bandwidth) };
            has_bandwidth as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let has_short_gi: u32 = unsafe { ::std::mem::transmute(has_short_gi) };
            has_short_gi as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let has_greenfield: u32 = unsafe { ::std::mem::transmute(has_greenfield) };
            has_greenfield as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let has_fec: u32 = unsafe { ::std::mem::transmute(has_fec) };
            has_fec as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let has_stbc_streams: u32 = unsafe { ::std::mem::transmute(has_stbc_streams) };
            has_stbc_streams as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let has_ness: u32 = unsafe { ::std::mem::transmute(has_ness) };
            has_ness as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn short_gi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_short_gi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn greenfield(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_greenfield(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fec(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fec(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stbc_streams(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_stbc_streams(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        short_gi: guint,
        greenfield: guint,
        fec: guint,
        stbc_streams: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let short_gi: u32 = unsafe { ::std::mem::transmute(short_gi) };
            short_gi as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let greenfield: u32 = unsafe { ::std::mem::transmute(greenfield) };
            greenfield as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let fec: u32 = unsafe { ::std::mem::transmute(fec) };
            fec as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let stbc_streams: u32 = unsafe { ::std::mem::transmute(stbc_streams) };
            stbc_streams as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ieee_802_11ac {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: [u8; 2usize],
    pub bandwidth: guint8,
    pub mcs: [guint8; 4usize],
    pub nss: [guint8; 4usize],
    pub fec: guint8,
    pub group_id: guint8,
    pub partial_aid: guint16,
}
#[test]
fn bindgen_test_layout_ieee_802_11ac() {
    const UNINIT: ::std::mem::MaybeUninit<ieee_802_11ac> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ieee_802_11ac>(),
        20usize,
        concat!("Size of: ", stringify!(ieee_802_11ac))
    );
    assert_eq!(
        ::std::mem::align_of::<ieee_802_11ac>(),
        4usize,
        concat!("Alignment of ", stringify!(ieee_802_11ac))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bandwidth) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11ac),
            "::",
            stringify!(bandwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mcs) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11ac),
            "::",
            stringify!(mcs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nss) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11ac),
            "::",
            stringify!(nss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fec) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11ac),
            "::",
            stringify!(fec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group_id) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11ac),
            "::",
            stringify!(group_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partial_aid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11ac),
            "::",
            stringify!(partial_aid)
        )
    );
}
impl ieee_802_11ac {
    #[inline]
    pub fn has_stbc(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_stbc(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_txop_ps_not_allowed(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_txop_ps_not_allowed(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_short_gi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_short_gi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_short_gi_nsym_disambig(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_short_gi_nsym_disambig(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_ldpc_extra_ofdm_symbol(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_ldpc_extra_ofdm_symbol(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_beamformed(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_beamformed(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_bandwidth(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_bandwidth(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_fec(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_fec(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_group_id(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_group_id(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_partial_aid(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_partial_aid(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stbc(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stbc(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txop_ps_not_allowed(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txop_ps_not_allowed(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn short_gi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_short_gi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn short_gi_nsym_disambig(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_short_gi_nsym_disambig(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ldpc_extra_ofdm_symbol(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ldpc_extra_ofdm_symbol(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn beamformed(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_beamformed(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        has_stbc: guint,
        has_txop_ps_not_allowed: guint,
        has_short_gi: guint,
        has_short_gi_nsym_disambig: guint,
        has_ldpc_extra_ofdm_symbol: guint,
        has_beamformed: guint,
        has_bandwidth: guint,
        has_fec: guint,
        has_group_id: guint,
        has_partial_aid: guint,
        stbc: guint,
        txop_ps_not_allowed: guint,
        short_gi: guint,
        short_gi_nsym_disambig: guint,
        ldpc_extra_ofdm_symbol: guint,
        beamformed: guint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_stbc: u32 = unsafe { ::std::mem::transmute(has_stbc) };
            has_stbc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_txop_ps_not_allowed: u32 =
                unsafe { ::std::mem::transmute(has_txop_ps_not_allowed) };
            has_txop_ps_not_allowed as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let has_short_gi: u32 = unsafe { ::std::mem::transmute(has_short_gi) };
            has_short_gi as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let has_short_gi_nsym_disambig: u32 =
                unsafe { ::std::mem::transmute(has_short_gi_nsym_disambig) };
            has_short_gi_nsym_disambig as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let has_ldpc_extra_ofdm_symbol: u32 =
                unsafe { ::std::mem::transmute(has_ldpc_extra_ofdm_symbol) };
            has_ldpc_extra_ofdm_symbol as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let has_beamformed: u32 = unsafe { ::std::mem::transmute(has_beamformed) };
            has_beamformed as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let has_bandwidth: u32 = unsafe { ::std::mem::transmute(has_bandwidth) };
            has_bandwidth as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let has_fec: u32 = unsafe { ::std::mem::transmute(has_fec) };
            has_fec as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let has_group_id: u32 = unsafe { ::std::mem::transmute(has_group_id) };
            has_group_id as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let has_partial_aid: u32 = unsafe { ::std::mem::transmute(has_partial_aid) };
            has_partial_aid as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let stbc: u32 = unsafe { ::std::mem::transmute(stbc) };
            stbc as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let txop_ps_not_allowed: u32 = unsafe { ::std::mem::transmute(txop_ps_not_allowed) };
            txop_ps_not_allowed as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let short_gi: u32 = unsafe { ::std::mem::transmute(short_gi) };
            short_gi as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let short_gi_nsym_disambig: u32 =
                unsafe { ::std::mem::transmute(short_gi_nsym_disambig) };
            short_gi_nsym_disambig as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ldpc_extra_ofdm_symbol: u32 =
                unsafe { ::std::mem::transmute(ldpc_extra_ofdm_symbol) };
            ldpc_extra_ofdm_symbol as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let beamformed: u32 = unsafe { ::std::mem::transmute(beamformed) };
            beamformed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ieee_802_11ad {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
    pub mcs: guint8,
}
#[test]
fn bindgen_test_layout_ieee_802_11ad() {
    const UNINIT: ::std::mem::MaybeUninit<ieee_802_11ad> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ieee_802_11ad>(),
        8usize,
        concat!("Size of: ", stringify!(ieee_802_11ad))
    );
    assert_eq!(
        ::std::mem::align_of::<ieee_802_11ad>(),
        4usize,
        concat!("Alignment of ", stringify!(ieee_802_11ad))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mcs) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11ad),
            "::",
            stringify!(mcs)
        )
    );
}
impl ieee_802_11ad {
    #[inline]
    pub fn has_mcs_index(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_mcs_index(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(has_mcs_index: guint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_mcs_index: u32 = unsafe { ::std::mem::transmute(has_mcs_index) };
            has_mcs_index as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ieee_802_11ax {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: [u8; 5usize],
}
#[test]
fn bindgen_test_layout_ieee_802_11ax() {
    assert_eq!(
        ::std::mem::size_of::<ieee_802_11ax>(),
        8usize,
        concat!("Size of: ", stringify!(ieee_802_11ax))
    );
    assert_eq!(
        ::std::mem::align_of::<ieee_802_11ax>(),
        4usize,
        concat!("Alignment of ", stringify!(ieee_802_11ax))
    );
}
impl ieee_802_11ax {
    #[inline]
    pub fn has_mcs_index(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_mcs_index(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_bwru(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_bwru(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_gi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_gi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nsts(&self) -> guint8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_nsts(&mut self, val: guint8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mcs(&self) -> guint8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_mcs(&mut self, val: guint8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn bwru(&self) -> guint8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_bwru(&mut self, val: guint8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn gi(&self) -> guint8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_gi(&mut self, val: guint8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        has_mcs_index: guint,
        has_bwru: guint,
        has_gi: guint,
        nsts: guint8,
        mcs: guint8,
        bwru: guint8,
        gi: guint8,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_mcs_index: u32 = unsafe { ::std::mem::transmute(has_mcs_index) };
            has_mcs_index as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_bwru: u32 = unsafe { ::std::mem::transmute(has_bwru) };
            has_bwru as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let has_gi: u32 = unsafe { ::std::mem::transmute(has_gi) };
            has_gi as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let nsts: u8 = unsafe { ::std::mem::transmute(nsts) };
            nsts as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let mcs: u8 = unsafe { ::std::mem::transmute(mcs) };
            mcs as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let bwru: u8 = unsafe { ::std::mem::transmute(bwru) };
            bwru as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let gi: u8 = unsafe { ::std::mem::transmute(gi) };
            gi as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ieee_802_11_phy_info {
    pub info_11_fhss: ieee_802_11_fhss,
    pub info_11b: ieee_802_11b,
    pub info_11a: ieee_802_11a,
    pub info_11g: ieee_802_11g,
    pub info_11n: ieee_802_11n,
    pub info_11ac: ieee_802_11ac,
    pub info_11ad: ieee_802_11ad,
    pub info_11ax: ieee_802_11ax,
}
#[test]
fn bindgen_test_layout_ieee_802_11_phy_info() {
    const UNINIT: ::std::mem::MaybeUninit<ieee_802_11_phy_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ieee_802_11_phy_info>(),
        20usize,
        concat!("Size of: ", stringify!(ieee_802_11_phy_info))
    );
    assert_eq!(
        ::std::mem::align_of::<ieee_802_11_phy_info>(),
        4usize,
        concat!("Alignment of ", stringify!(ieee_802_11_phy_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info_11_fhss) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11_phy_info),
            "::",
            stringify!(info_11_fhss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info_11b) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11_phy_info),
            "::",
            stringify!(info_11b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info_11a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11_phy_info),
            "::",
            stringify!(info_11a)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info_11g) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11_phy_info),
            "::",
            stringify!(info_11g)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info_11n) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11_phy_info),
            "::",
            stringify!(info_11n)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info_11ac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11_phy_info),
            "::",
            stringify!(info_11ac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info_11ad) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11_phy_info),
            "::",
            stringify!(info_11ad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info_11ax) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11_phy_info),
            "::",
            stringify!(info_11ax)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ieee_802_11_phdr {
    pub fcs_len: gint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub phy: guint,
    pub phy_info: ieee_802_11_phy_info,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
    pub channel: guint16,
    pub frequency: guint32,
    pub data_rate: guint16,
    pub signal_percent: guint8,
    pub noise_percent: guint8,
    pub signal_dbm: gint8,
    pub noise_dbm: gint8,
    pub signal_db: guint8,
    pub noise_db: guint8,
    pub tsf_timestamp: guint64,
    pub aggregate_flags: guint32,
    pub aggregate_id: guint32,
    pub zero_length_psdu_type: guint8,
}
#[test]
fn bindgen_test_layout_ieee_802_11_phdr() {
    const UNINIT: ::std::mem::MaybeUninit<ieee_802_11_phdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ieee_802_11_phdr>(),
        80usize,
        concat!("Size of: ", stringify!(ieee_802_11_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<ieee_802_11_phdr>(),
        8usize,
        concat!("Alignment of ", stringify!(ieee_802_11_phdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fcs_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11_phdr),
            "::",
            stringify!(fcs_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).phy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11_phdr),
            "::",
            stringify!(phy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).phy_info) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11_phdr),
            "::",
            stringify!(phy_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11_phdr),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11_phdr),
            "::",
            stringify!(frequency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_rate) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11_phdr),
            "::",
            stringify!(data_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_percent) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11_phdr),
            "::",
            stringify!(signal_percent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).noise_percent) as usize - ptr as usize },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11_phdr),
            "::",
            stringify!(noise_percent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_dbm) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11_phdr),
            "::",
            stringify!(signal_dbm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).noise_dbm) as usize - ptr as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11_phdr),
            "::",
            stringify!(noise_dbm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_db) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11_phdr),
            "::",
            stringify!(signal_db)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).noise_db) as usize - ptr as usize },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11_phdr),
            "::",
            stringify!(noise_db)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tsf_timestamp) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11_phdr),
            "::",
            stringify!(tsf_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aggregate_flags) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11_phdr),
            "::",
            stringify!(aggregate_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aggregate_id) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11_phdr),
            "::",
            stringify!(aggregate_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zero_length_psdu_type) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ieee_802_11_phdr),
            "::",
            stringify!(zero_length_psdu_type)
        )
    );
}
impl ieee_802_11_phdr {
    #[inline]
    pub fn decrypted(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_decrypted(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn datapad(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_datapad(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_a_msdus(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_a_msdus(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        decrypted: guint,
        datapad: guint,
        no_a_msdus: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let decrypted: u32 = unsafe { ::std::mem::transmute(decrypted) };
            decrypted as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let datapad: u32 = unsafe { ::std::mem::transmute(datapad) };
            datapad as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let no_a_msdus: u32 = unsafe { ::std::mem::transmute(no_a_msdus) };
            no_a_msdus as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn has_channel(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_channel(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_frequency(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_frequency(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_data_rate(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_data_rate(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_signal_percent(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_signal_percent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_noise_percent(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_noise_percent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_signal_dbm(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_signal_dbm(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_noise_dbm(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_noise_dbm(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_signal_db(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_signal_db(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_noise_db(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_noise_db(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_tsf_timestamp(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_tsf_timestamp(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_aggregate_info(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_aggregate_info(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_zero_length_psdu_type(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_zero_length_psdu_type(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        has_channel: guint,
        has_frequency: guint,
        has_data_rate: guint,
        has_signal_percent: guint,
        has_noise_percent: guint,
        has_signal_dbm: guint,
        has_noise_dbm: guint,
        has_signal_db: guint,
        has_noise_db: guint,
        has_tsf_timestamp: guint,
        has_aggregate_info: guint,
        has_zero_length_psdu_type: guint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_channel: u32 = unsafe { ::std::mem::transmute(has_channel) };
            has_channel as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_frequency: u32 = unsafe { ::std::mem::transmute(has_frequency) };
            has_frequency as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let has_data_rate: u32 = unsafe { ::std::mem::transmute(has_data_rate) };
            has_data_rate as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let has_signal_percent: u32 = unsafe { ::std::mem::transmute(has_signal_percent) };
            has_signal_percent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let has_noise_percent: u32 = unsafe { ::std::mem::transmute(has_noise_percent) };
            has_noise_percent as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let has_signal_dbm: u32 = unsafe { ::std::mem::transmute(has_signal_dbm) };
            has_signal_dbm as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let has_noise_dbm: u32 = unsafe { ::std::mem::transmute(has_noise_dbm) };
            has_noise_dbm as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let has_signal_db: u32 = unsafe { ::std::mem::transmute(has_signal_db) };
            has_signal_db as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let has_noise_db: u32 = unsafe { ::std::mem::transmute(has_noise_db) };
            has_noise_db as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let has_tsf_timestamp: u32 = unsafe { ::std::mem::transmute(has_tsf_timestamp) };
            has_tsf_timestamp as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let has_aggregate_info: u32 = unsafe { ::std::mem::transmute(has_aggregate_info) };
            has_aggregate_info as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let has_zero_length_psdu_type: u32 =
                unsafe { ::std::mem::transmute(has_zero_length_psdu_type) };
            has_zero_length_psdu_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cosine_phdr {
    pub encap: guint8,
    pub direction: guint8,
    pub if_name: [::std::os::raw::c_char; 128usize],
    pub pro: guint16,
    pub off: guint16,
    pub pri: guint16,
    pub rm: guint16,
    pub err: guint16,
}
#[test]
fn bindgen_test_layout_cosine_phdr() {
    const UNINIT: ::std::mem::MaybeUninit<cosine_phdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cosine_phdr>(),
        140usize,
        concat!("Size of: ", stringify!(cosine_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cosine_phdr>(),
        2usize,
        concat!("Alignment of ", stringify!(cosine_phdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cosine_phdr),
            "::",
            stringify!(encap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(cosine_phdr),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).if_name) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(cosine_phdr),
            "::",
            stringify!(if_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pro) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(cosine_phdr),
            "::",
            stringify!(pro)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).off) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(cosine_phdr),
            "::",
            stringify!(off)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pri) as usize - ptr as usize },
        134usize,
        concat!(
            "Offset of field: ",
            stringify!(cosine_phdr),
            "::",
            stringify!(pri)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rm) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(cosine_phdr),
            "::",
            stringify!(rm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).err) as usize - ptr as usize },
        138usize,
        concat!(
            "Offset of field: ",
            stringify!(cosine_phdr),
            "::",
            stringify!(err)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irda_phdr {
    pub pkttype: guint16,
}
#[test]
fn bindgen_test_layout_irda_phdr() {
    const UNINIT: ::std::mem::MaybeUninit<irda_phdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<irda_phdr>(),
        2usize,
        concat!("Size of: ", stringify!(irda_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<irda_phdr>(),
        2usize,
        concat!("Alignment of ", stringify!(irda_phdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pkttype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(irda_phdr),
            "::",
            stringify!(pkttype)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nettl_phdr {
    pub subsys: guint16,
    pub devid: guint32,
    pub kind: guint32,
    pub pid: gint32,
    pub uid: guint32,
}
#[test]
fn bindgen_test_layout_nettl_phdr() {
    const UNINIT: ::std::mem::MaybeUninit<nettl_phdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nettl_phdr>(),
        20usize,
        concat!("Size of: ", stringify!(nettl_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<nettl_phdr>(),
        4usize,
        concat!("Alignment of ", stringify!(nettl_phdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subsys) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nettl_phdr),
            "::",
            stringify!(subsys)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).devid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nettl_phdr),
            "::",
            stringify!(devid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kind) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nettl_phdr),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nettl_phdr),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nettl_phdr),
            "::",
            stringify!(uid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mtp2_phdr {
    pub sent: guint8,
    pub annex_a_used: guint8,
    pub link_number: guint16,
}
#[test]
fn bindgen_test_layout_mtp2_phdr() {
    const UNINIT: ::std::mem::MaybeUninit<mtp2_phdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mtp2_phdr>(),
        4usize,
        concat!("Size of: ", stringify!(mtp2_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<mtp2_phdr>(),
        2usize,
        concat!("Alignment of ", stringify!(mtp2_phdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mtp2_phdr),
            "::",
            stringify!(sent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).annex_a_used) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(mtp2_phdr),
            "::",
            stringify!(annex_a_used)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).link_number) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(mtp2_phdr),
            "::",
            stringify!(link_number)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union k12_input_info_t {
    pub atm: k12_input_info_t__bindgen_ty_1,
    pub ds0mask: guint32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k12_input_info_t__bindgen_ty_1 {
    pub vp: guint16,
    pub vc: guint16,
    pub cid: guint16,
}
#[test]
fn bindgen_test_layout_k12_input_info_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<k12_input_info_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<k12_input_info_t__bindgen_ty_1>(),
        6usize,
        concat!("Size of: ", stringify!(k12_input_info_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<k12_input_info_t__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(k12_input_info_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k12_input_info_t__bindgen_ty_1),
            "::",
            stringify!(vp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vc) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(k12_input_info_t__bindgen_ty_1),
            "::",
            stringify!(vc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(k12_input_info_t__bindgen_ty_1),
            "::",
            stringify!(cid)
        )
    );
}
#[test]
fn bindgen_test_layout_k12_input_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<k12_input_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<k12_input_info_t>(),
        8usize,
        concat!("Size of: ", stringify!(k12_input_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<k12_input_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(k12_input_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).atm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k12_input_info_t),
            "::",
            stringify!(atm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ds0mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k12_input_info_t),
            "::",
            stringify!(ds0mask)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k12_phdr {
    pub input: guint32,
    pub input_name: *const gchar,
    pub stack_file: *const gchar,
    pub input_type: guint32,
    pub input_info: k12_input_info_t,
    pub extra_info: *mut guint8,
    pub extra_length: guint32,
    pub stuff: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_k12_phdr() {
    const UNINIT: ::std::mem::MaybeUninit<k12_phdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<k12_phdr>(),
        64usize,
        concat!("Size of: ", stringify!(k12_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<k12_phdr>(),
        8usize,
        concat!("Alignment of ", stringify!(k12_phdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k12_phdr),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k12_phdr),
            "::",
            stringify!(input_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stack_file) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k12_phdr),
            "::",
            stringify!(stack_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(k12_phdr),
            "::",
            stringify!(input_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_info) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(k12_phdr),
            "::",
            stringify!(input_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extra_info) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(k12_phdr),
            "::",
            stringify!(extra_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extra_length) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(k12_phdr),
            "::",
            stringify!(extra_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stuff) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(k12_phdr),
            "::",
            stringify!(stuff)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lapd_phdr {
    pub pkttype: guint16,
    pub we_network: guint8,
}
#[test]
fn bindgen_test_layout_lapd_phdr() {
    const UNINIT: ::std::mem::MaybeUninit<lapd_phdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lapd_phdr>(),
        4usize,
        concat!("Size of: ", stringify!(lapd_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<lapd_phdr>(),
        2usize,
        concat!("Alignment of ", stringify!(lapd_phdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pkttype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lapd_phdr),
            "::",
            stringify!(pkttype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).we_network) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lapd_phdr),
            "::",
            stringify!(we_network)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct catapult_dct2000_phdr {
    pub inner_pseudo_header: catapult_dct2000_phdr__bindgen_ty_1,
    pub seek_off: gint64,
    pub wth: *mut wtap,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union catapult_dct2000_phdr__bindgen_ty_1 {
    pub isdn: isdn_phdr,
    pub atm: atm_phdr,
    pub p2p: p2p_phdr,
}
#[test]
fn bindgen_test_layout_catapult_dct2000_phdr__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<catapult_dct2000_phdr__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<catapult_dct2000_phdr__bindgen_ty_1>(),
        28usize,
        concat!("Size of: ", stringify!(catapult_dct2000_phdr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<catapult_dct2000_phdr__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(catapult_dct2000_phdr__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isdn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(catapult_dct2000_phdr__bindgen_ty_1),
            "::",
            stringify!(isdn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).atm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(catapult_dct2000_phdr__bindgen_ty_1),
            "::",
            stringify!(atm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p2p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(catapult_dct2000_phdr__bindgen_ty_1),
            "::",
            stringify!(p2p)
        )
    );
}
#[test]
fn bindgen_test_layout_catapult_dct2000_phdr() {
    const UNINIT: ::std::mem::MaybeUninit<catapult_dct2000_phdr> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<catapult_dct2000_phdr>(),
        48usize,
        concat!("Size of: ", stringify!(catapult_dct2000_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<catapult_dct2000_phdr>(),
        8usize,
        concat!("Alignment of ", stringify!(catapult_dct2000_phdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner_pseudo_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(catapult_dct2000_phdr),
            "::",
            stringify!(inner_pseudo_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek_off) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(catapult_dct2000_phdr),
            "::",
            stringify!(seek_off)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wth) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(catapult_dct2000_phdr),
            "::",
            stringify!(wth)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct erf_phdr {
    pub ts: guint64,
    pub type_: guint8,
    pub flags: guint8,
    pub rlen: guint16,
    pub lctr: guint16,
    pub wlen: guint16,
}
#[test]
fn bindgen_test_layout_erf_phdr() {
    const UNINIT: ::std::mem::MaybeUninit<erf_phdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<erf_phdr>(),
        16usize,
        concat!("Size of: ", stringify!(erf_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<erf_phdr>(),
        8usize,
        concat!("Alignment of ", stringify!(erf_phdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ts) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(erf_phdr),
            "::",
            stringify!(ts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(erf_phdr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(erf_phdr),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rlen) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(erf_phdr),
            "::",
            stringify!(rlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lctr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(erf_phdr),
            "::",
            stringify!(lctr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wlen) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(erf_phdr),
            "::",
            stringify!(wlen)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct erf_ehdr {
    pub ehdr: guint64,
}
#[test]
fn bindgen_test_layout_erf_ehdr() {
    const UNINIT: ::std::mem::MaybeUninit<erf_ehdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<erf_ehdr>(),
        8usize,
        concat!("Size of: ", stringify!(erf_ehdr))
    );
    assert_eq!(
        ::std::mem::align_of::<erf_ehdr>(),
        8usize,
        concat!("Alignment of ", stringify!(erf_ehdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ehdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(erf_ehdr),
            "::",
            stringify!(ehdr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_erf_eth_hdr {
    pub offset: guint8,
    pub pad: guint8,
}
#[test]
fn bindgen_test_layout_wtap_erf_eth_hdr() {
    const UNINIT: ::std::mem::MaybeUninit<wtap_erf_eth_hdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wtap_erf_eth_hdr>(),
        2usize,
        concat!("Size of: ", stringify!(wtap_erf_eth_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_erf_eth_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(wtap_erf_eth_hdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_erf_eth_hdr),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_erf_eth_hdr),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct erf_mc_phdr {
    pub phdr: erf_phdr,
    pub ehdr_list: [erf_ehdr; 16usize],
    pub subhdr: erf_mc_phdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union erf_mc_phdr__bindgen_ty_1 {
    pub eth_hdr: wtap_erf_eth_hdr,
    pub mc_hdr: guint32,
    pub aal2_hdr: guint32,
}
#[test]
fn bindgen_test_layout_erf_mc_phdr__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<erf_mc_phdr__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<erf_mc_phdr__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(erf_mc_phdr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<erf_mc_phdr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(erf_mc_phdr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eth_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(erf_mc_phdr__bindgen_ty_1),
            "::",
            stringify!(eth_hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mc_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(erf_mc_phdr__bindgen_ty_1),
            "::",
            stringify!(mc_hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aal2_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(erf_mc_phdr__bindgen_ty_1),
            "::",
            stringify!(aal2_hdr)
        )
    );
}
#[test]
fn bindgen_test_layout_erf_mc_phdr() {
    const UNINIT: ::std::mem::MaybeUninit<erf_mc_phdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<erf_mc_phdr>(),
        152usize,
        concat!("Size of: ", stringify!(erf_mc_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<erf_mc_phdr>(),
        8usize,
        concat!("Alignment of ", stringify!(erf_mc_phdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).phdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(erf_mc_phdr),
            "::",
            stringify!(phdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ehdr_list) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(erf_mc_phdr),
            "::",
            stringify!(ehdr_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subhdr) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(erf_mc_phdr),
            "::",
            stringify!(subhdr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sita_phdr {
    pub sita_flags: guint8,
    pub sita_signals: guint8,
    pub sita_errors1: guint8,
    pub sita_errors2: guint8,
    pub sita_proto: guint8,
}
#[test]
fn bindgen_test_layout_sita_phdr() {
    const UNINIT: ::std::mem::MaybeUninit<sita_phdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sita_phdr>(),
        5usize,
        concat!("Size of: ", stringify!(sita_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<sita_phdr>(),
        1usize,
        concat!("Alignment of ", stringify!(sita_phdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sita_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sita_phdr),
            "::",
            stringify!(sita_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sita_signals) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sita_phdr),
            "::",
            stringify!(sita_signals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sita_errors1) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sita_phdr),
            "::",
            stringify!(sita_errors1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sita_errors2) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sita_phdr),
            "::",
            stringify!(sita_errors2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sita_proto) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sita_phdr),
            "::",
            stringify!(sita_proto)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bthci_phdr {
    pub sent: gboolean,
    pub channel: guint32,
}
#[test]
fn bindgen_test_layout_bthci_phdr() {
    const UNINIT: ::std::mem::MaybeUninit<bthci_phdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bthci_phdr>(),
        8usize,
        concat!("Size of: ", stringify!(bthci_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<bthci_phdr>(),
        4usize,
        concat!("Alignment of ", stringify!(bthci_phdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bthci_phdr),
            "::",
            stringify!(sent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bthci_phdr),
            "::",
            stringify!(channel)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btmon_phdr {
    pub adapter_id: guint16,
    pub opcode: guint16,
}
#[test]
fn bindgen_test_layout_btmon_phdr() {
    const UNINIT: ::std::mem::MaybeUninit<btmon_phdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<btmon_phdr>(),
        4usize,
        concat!("Size of: ", stringify!(btmon_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<btmon_phdr>(),
        2usize,
        concat!("Alignment of ", stringify!(btmon_phdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adapter_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(btmon_phdr),
            "::",
            stringify!(adapter_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opcode) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(btmon_phdr),
            "::",
            stringify!(opcode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct l1event_phdr {
    pub uton: gboolean,
}
#[test]
fn bindgen_test_layout_l1event_phdr() {
    const UNINIT: ::std::mem::MaybeUninit<l1event_phdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<l1event_phdr>(),
        4usize,
        concat!("Size of: ", stringify!(l1event_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<l1event_phdr>(),
        4usize,
        concat!("Alignment of ", stringify!(l1event_phdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uton) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(l1event_phdr),
            "::",
            stringify!(uton)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2c_phdr {
    pub is_event: guint8,
    pub bus: guint8,
    pub flags: guint32,
}
#[test]
fn bindgen_test_layout_i2c_phdr() {
    const UNINIT: ::std::mem::MaybeUninit<i2c_phdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<i2c_phdr>(),
        8usize,
        concat!("Size of: ", stringify!(i2c_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<i2c_phdr>(),
        4usize,
        concat!("Alignment of ", stringify!(i2c_phdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_phdr),
            "::",
            stringify!(is_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bus) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_phdr),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_phdr),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gsm_um_phdr {
    pub uplink: gboolean,
    pub channel: guint8,
    pub bsic: guint8,
    pub arfcn: guint16,
    pub tdma_frame: guint32,
    pub error: guint8,
    pub timeshift: guint16,
}
#[test]
fn bindgen_test_layout_gsm_um_phdr() {
    const UNINIT: ::std::mem::MaybeUninit<gsm_um_phdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gsm_um_phdr>(),
        16usize,
        concat!("Size of: ", stringify!(gsm_um_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<gsm_um_phdr>(),
        4usize,
        concat!("Alignment of ", stringify!(gsm_um_phdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uplink) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gsm_um_phdr),
            "::",
            stringify!(uplink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gsm_um_phdr),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bsic) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(gsm_um_phdr),
            "::",
            stringify!(bsic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arfcn) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(gsm_um_phdr),
            "::",
            stringify!(arfcn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tdma_frame) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gsm_um_phdr),
            "::",
            stringify!(tdma_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gsm_um_phdr),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeshift) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(gsm_um_phdr),
            "::",
            stringify!(timeshift)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nstr_phdr {
    pub rec_offset: gint64,
    pub rec_len: gint32,
    pub nicno_offset: guint8,
    pub nicno_len: guint8,
    pub dir_offset: guint8,
    pub dir_len: guint8,
    pub eth_offset: guint16,
    pub pcb_offset: guint8,
    pub l_pcb_offset: guint8,
    pub rec_type: guint8,
    pub vlantag_offset: guint8,
    pub coreid_offset: guint8,
    pub srcnodeid_offset: guint8,
    pub destnodeid_offset: guint8,
    pub clflags_offset: guint8,
    pub src_vmname_len_offset: guint8,
    pub dst_vmname_len_offset: guint8,
    pub ns_activity_offset: guint8,
    pub data_offset: guint8,
}
#[test]
fn bindgen_test_layout_nstr_phdr() {
    const UNINIT: ::std::mem::MaybeUninit<nstr_phdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nstr_phdr>(),
        32usize,
        concat!("Size of: ", stringify!(nstr_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<nstr_phdr>(),
        8usize,
        concat!("Alignment of ", stringify!(nstr_phdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rec_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nstr_phdr),
            "::",
            stringify!(rec_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rec_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nstr_phdr),
            "::",
            stringify!(rec_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nicno_offset) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nstr_phdr),
            "::",
            stringify!(nicno_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nicno_len) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(nstr_phdr),
            "::",
            stringify!(nicno_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dir_offset) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(nstr_phdr),
            "::",
            stringify!(dir_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dir_len) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(nstr_phdr),
            "::",
            stringify!(dir_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eth_offset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nstr_phdr),
            "::",
            stringify!(eth_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcb_offset) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(nstr_phdr),
            "::",
            stringify!(pcb_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_pcb_offset) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(nstr_phdr),
            "::",
            stringify!(l_pcb_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rec_type) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nstr_phdr),
            "::",
            stringify!(rec_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vlantag_offset) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(nstr_phdr),
            "::",
            stringify!(vlantag_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coreid_offset) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(nstr_phdr),
            "::",
            stringify!(coreid_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcnodeid_offset) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(nstr_phdr),
            "::",
            stringify!(srcnodeid_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destnodeid_offset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nstr_phdr),
            "::",
            stringify!(destnodeid_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clflags_offset) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(nstr_phdr),
            "::",
            stringify!(clflags_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_vmname_len_offset) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(nstr_phdr),
            "::",
            stringify!(src_vmname_len_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst_vmname_len_offset) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(nstr_phdr),
            "::",
            stringify!(dst_vmname_len_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ns_activity_offset) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nstr_phdr),
            "::",
            stringify!(ns_activity_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_offset) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(nstr_phdr),
            "::",
            stringify!(data_offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nokia_phdr {
    pub eth: eth_phdr,
    pub stuff: [guint8; 4usize],
}
#[test]
fn bindgen_test_layout_nokia_phdr() {
    const UNINIT: ::std::mem::MaybeUninit<nokia_phdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nokia_phdr>(),
        8usize,
        concat!("Size of: ", stringify!(nokia_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<nokia_phdr>(),
        4usize,
        concat!("Alignment of ", stringify!(nokia_phdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nokia_phdr),
            "::",
            stringify!(eth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stuff) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nokia_phdr),
            "::",
            stringify!(stuff)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llcp_phdr {
    pub adapter: guint8,
    pub flags: guint8,
}
#[test]
fn bindgen_test_layout_llcp_phdr() {
    const UNINIT: ::std::mem::MaybeUninit<llcp_phdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<llcp_phdr>(),
        2usize,
        concat!("Size of: ", stringify!(llcp_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<llcp_phdr>(),
        1usize,
        concat!("Alignment of ", stringify!(llcp_phdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adapter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llcp_phdr),
            "::",
            stringify!(adapter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(llcp_phdr),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct logcat_phdr {
    pub version: gint,
}
#[test]
fn bindgen_test_layout_logcat_phdr() {
    const UNINIT: ::std::mem::MaybeUninit<logcat_phdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<logcat_phdr>(),
        4usize,
        concat!("Size of: ", stringify!(logcat_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<logcat_phdr>(),
        4usize,
        concat!("Alignment of ", stringify!(logcat_phdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(logcat_phdr),
            "::",
            stringify!(version)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netmon_phdr {
    pub title: *mut guint8,
    pub descLength: guint32,
    pub description: *mut guint8,
    pub sub_encap: guint,
    pub subheader: netmon_phdr_sub_wtap_pseudo_header,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union netmon_phdr_sub_wtap_pseudo_header {
    pub eth: eth_phdr,
    pub atm: atm_phdr,
    pub ieee_802_11: ieee_802_11_phdr,
}
#[test]
fn bindgen_test_layout_netmon_phdr_sub_wtap_pseudo_header() {
    const UNINIT: ::std::mem::MaybeUninit<netmon_phdr_sub_wtap_pseudo_header> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<netmon_phdr_sub_wtap_pseudo_header>(),
        80usize,
        concat!("Size of: ", stringify!(netmon_phdr_sub_wtap_pseudo_header))
    );
    assert_eq!(
        ::std::mem::align_of::<netmon_phdr_sub_wtap_pseudo_header>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(netmon_phdr_sub_wtap_pseudo_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netmon_phdr_sub_wtap_pseudo_header),
            "::",
            stringify!(eth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).atm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netmon_phdr_sub_wtap_pseudo_header),
            "::",
            stringify!(atm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ieee_802_11) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netmon_phdr_sub_wtap_pseudo_header),
            "::",
            stringify!(ieee_802_11)
        )
    );
}
#[test]
fn bindgen_test_layout_netmon_phdr() {
    const UNINIT: ::std::mem::MaybeUninit<netmon_phdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<netmon_phdr>(),
        112usize,
        concat!("Size of: ", stringify!(netmon_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<netmon_phdr>(),
        8usize,
        concat!("Alignment of ", stringify!(netmon_phdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).title) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netmon_phdr),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).descLength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netmon_phdr),
            "::",
            stringify!(descLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netmon_phdr),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sub_encap) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(netmon_phdr),
            "::",
            stringify!(sub_encap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subheader) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(netmon_phdr),
            "::",
            stringify!(subheader)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ber_phdr {
    pub pathname: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ber_phdr() {
    const UNINIT: ::std::mem::MaybeUninit<ber_phdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ber_phdr>(),
        8usize,
        concat!("Size of: ", stringify!(ber_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<ber_phdr>(),
        8usize,
        concat!("Alignment of ", stringify!(ber_phdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pathname) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ber_phdr),
            "::",
            stringify!(pathname)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wtap_pseudo_header {
    pub eth: eth_phdr,
    pub dte_dce: dte_dce_phdr,
    pub isdn: isdn_phdr,
    pub atm: atm_phdr,
    pub ascend: ascend_phdr,
    pub p2p: p2p_phdr,
    pub ieee_802_11: ieee_802_11_phdr,
    pub cosine: cosine_phdr,
    pub irda: irda_phdr,
    pub nettl: nettl_phdr,
    pub mtp2: mtp2_phdr,
    pub k12: k12_phdr,
    pub lapd: lapd_phdr,
    pub dct2000: catapult_dct2000_phdr,
    pub erf: erf_mc_phdr,
    pub sita: sita_phdr,
    pub bthci: bthci_phdr,
    pub btmon: btmon_phdr,
    pub l1event: l1event_phdr,
    pub i2c: i2c_phdr,
    pub gsm_um: gsm_um_phdr,
    pub nstr: nstr_phdr,
    pub nokia: nokia_phdr,
    pub llcp: llcp_phdr,
    pub logcat: logcat_phdr,
    pub netmon: netmon_phdr,
    pub ber: ber_phdr,
}
#[test]
fn bindgen_test_layout_wtap_pseudo_header() {
    const UNINIT: ::std::mem::MaybeUninit<wtap_pseudo_header> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wtap_pseudo_header>(),
        152usize,
        concat!("Size of: ", stringify!(wtap_pseudo_header))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_pseudo_header>(),
        8usize,
        concat!("Alignment of ", stringify!(wtap_pseudo_header))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_pseudo_header),
            "::",
            stringify!(eth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dte_dce) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_pseudo_header),
            "::",
            stringify!(dte_dce)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isdn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_pseudo_header),
            "::",
            stringify!(isdn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).atm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_pseudo_header),
            "::",
            stringify!(atm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ascend) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_pseudo_header),
            "::",
            stringify!(ascend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p2p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_pseudo_header),
            "::",
            stringify!(p2p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ieee_802_11) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_pseudo_header),
            "::",
            stringify!(ieee_802_11)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cosine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_pseudo_header),
            "::",
            stringify!(cosine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).irda) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_pseudo_header),
            "::",
            stringify!(irda)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nettl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_pseudo_header),
            "::",
            stringify!(nettl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtp2) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_pseudo_header),
            "::",
            stringify!(mtp2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).k12) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_pseudo_header),
            "::",
            stringify!(k12)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lapd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_pseudo_header),
            "::",
            stringify!(lapd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dct2000) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_pseudo_header),
            "::",
            stringify!(dct2000)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).erf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_pseudo_header),
            "::",
            stringify!(erf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sita) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_pseudo_header),
            "::",
            stringify!(sita)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bthci) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_pseudo_header),
            "::",
            stringify!(bthci)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).btmon) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_pseudo_header),
            "::",
            stringify!(btmon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l1event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_pseudo_header),
            "::",
            stringify!(l1event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i2c) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_pseudo_header),
            "::",
            stringify!(i2c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gsm_um) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_pseudo_header),
            "::",
            stringify!(gsm_um)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nstr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_pseudo_header),
            "::",
            stringify!(nstr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nokia) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_pseudo_header),
            "::",
            stringify!(nokia)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).llcp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_pseudo_header),
            "::",
            stringify!(llcp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logcat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_pseudo_header),
            "::",
            stringify!(logcat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).netmon) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_pseudo_header),
            "::",
            stringify!(netmon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ber) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_pseudo_header),
            "::",
            stringify!(ber)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wtap_packet_header {
    pub caplen: guint32,
    pub len: guint32,
    pub pkt_encap: ::std::os::raw::c_int,
    pub interface_id: guint32,
    pub pseudo_header: wtap_pseudo_header,
}
#[test]
fn bindgen_test_layout_wtap_packet_header() {
    const UNINIT: ::std::mem::MaybeUninit<wtap_packet_header> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wtap_packet_header>(),
        168usize,
        concat!("Size of: ", stringify!(wtap_packet_header))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_packet_header>(),
        8usize,
        concat!("Alignment of ", stringify!(wtap_packet_header))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).caplen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_packet_header),
            "::",
            stringify!(caplen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_packet_header),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pkt_encap) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_packet_header),
            "::",
            stringify!(pkt_encap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_packet_header),
            "::",
            stringify!(interface_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pseudo_header) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_packet_header),
            "::",
            stringify!(pseudo_header)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_ft_specific_header {
    pub record_type: guint,
    pub record_len: guint32,
}
#[test]
fn bindgen_test_layout_wtap_ft_specific_header() {
    const UNINIT: ::std::mem::MaybeUninit<wtap_ft_specific_header> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wtap_ft_specific_header>(),
        8usize,
        concat!("Size of: ", stringify!(wtap_ft_specific_header))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_ft_specific_header>(),
        4usize,
        concat!("Alignment of ", stringify!(wtap_ft_specific_header))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).record_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_ft_specific_header),
            "::",
            stringify!(record_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).record_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_ft_specific_header),
            "::",
            stringify!(record_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_syscall_header {
    pub record_type: guint,
    pub byte_order: ::std::os::raw::c_int,
    pub timestamp: guint64,
    pub thread_id: guint64,
    pub event_len: guint32,
    pub event_filelen: guint32,
    pub event_type: guint16,
    pub nparams: guint32,
    pub cpu_id: guint16,
}
#[test]
fn bindgen_test_layout_wtap_syscall_header() {
    const UNINIT: ::std::mem::MaybeUninit<wtap_syscall_header> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wtap_syscall_header>(),
        48usize,
        concat!("Size of: ", stringify!(wtap_syscall_header))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_syscall_header>(),
        8usize,
        concat!("Alignment of ", stringify!(wtap_syscall_header))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).record_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_syscall_header),
            "::",
            stringify!(record_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byte_order) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_syscall_header),
            "::",
            stringify!(byte_order)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_syscall_header),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_syscall_header),
            "::",
            stringify!(thread_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_syscall_header),
            "::",
            stringify!(event_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_filelen) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_syscall_header),
            "::",
            stringify!(event_filelen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_type) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_syscall_header),
            "::",
            stringify!(event_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nparams) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_syscall_header),
            "::",
            stringify!(nparams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpu_id) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_syscall_header),
            "::",
            stringify!(cpu_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_systemd_journal_export_header {
    pub record_len: guint32,
}
#[test]
fn bindgen_test_layout_wtap_systemd_journal_export_header() {
    const UNINIT: ::std::mem::MaybeUninit<wtap_systemd_journal_export_header> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wtap_systemd_journal_export_header>(),
        4usize,
        concat!("Size of: ", stringify!(wtap_systemd_journal_export_header))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_systemd_journal_export_header>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(wtap_systemd_journal_export_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).record_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_systemd_journal_export_header),
            "::",
            stringify!(record_len)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wtap_custom_block_header {
    pub length: guint32,
    pub pen: guint32,
    pub copy_allowed: gboolean,
    pub custom_data_header: wtap_custom_block_header__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wtap_custom_block_header__bindgen_ty_1 {
    pub nflx_custom_data_header: wtap_custom_block_header__bindgen_ty_1_nflx,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_custom_block_header__bindgen_ty_1_nflx {
    pub type_: guint32,
    pub skipped: guint32,
}
#[test]
fn bindgen_test_layout_wtap_custom_block_header__bindgen_ty_1_nflx() {
    const UNINIT: ::std::mem::MaybeUninit<wtap_custom_block_header__bindgen_ty_1_nflx> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wtap_custom_block_header__bindgen_ty_1_nflx>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(wtap_custom_block_header__bindgen_ty_1_nflx)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_custom_block_header__bindgen_ty_1_nflx>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(wtap_custom_block_header__bindgen_ty_1_nflx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_custom_block_header__bindgen_ty_1_nflx),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skipped) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_custom_block_header__bindgen_ty_1_nflx),
            "::",
            stringify!(skipped)
        )
    );
}
#[test]
fn bindgen_test_layout_wtap_custom_block_header__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<wtap_custom_block_header__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wtap_custom_block_header__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(wtap_custom_block_header__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_custom_block_header__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(wtap_custom_block_header__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nflx_custom_data_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_custom_block_header__bindgen_ty_1),
            "::",
            stringify!(nflx_custom_data_header)
        )
    );
}
#[test]
fn bindgen_test_layout_wtap_custom_block_header() {
    const UNINIT: ::std::mem::MaybeUninit<wtap_custom_block_header> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wtap_custom_block_header>(),
        20usize,
        concat!("Size of: ", stringify!(wtap_custom_block_header))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_custom_block_header>(),
        4usize,
        concat!("Alignment of ", stringify!(wtap_custom_block_header))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_custom_block_header),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pen) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_custom_block_header),
            "::",
            stringify!(pen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copy_allowed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_custom_block_header),
            "::",
            stringify!(copy_allowed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_data_header) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_custom_block_header),
            "::",
            stringify!(custom_data_header)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wtap_rec {
    pub rec_type: guint,
    pub presence_flags: guint32,
    pub section_number: guint,
    pub ts: nstime_t,
    pub tsprec: ::std::os::raw::c_int,
    pub ts_rel_cap: nstime_t,
    pub ts_rel_cap_valid: gboolean,
    pub rec_header: wtap_rec__bindgen_ty_1,
    pub block: wtap_block_t,
    pub block_was_modified: gboolean,
    pub options_buf: Buffer,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wtap_rec__bindgen_ty_1 {
    pub packet_header: wtap_packet_header,
    pub ft_specific_header: wtap_ft_specific_header,
    pub syscall_header: wtap_syscall_header,
    pub systemd_journal_export_header: wtap_systemd_journal_export_header,
    pub custom_block_header: wtap_custom_block_header,
}
#[test]
fn bindgen_test_layout_wtap_rec__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<wtap_rec__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wtap_rec__bindgen_ty_1>(),
        168usize,
        concat!("Size of: ", stringify!(wtap_rec__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_rec__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wtap_rec__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packet_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec__bindgen_ty_1),
            "::",
            stringify!(packet_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ft_specific_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec__bindgen_ty_1),
            "::",
            stringify!(ft_specific_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).syscall_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec__bindgen_ty_1),
            "::",
            stringify!(syscall_header)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).systemd_journal_export_header) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec__bindgen_ty_1),
            "::",
            stringify!(systemd_journal_export_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_block_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec__bindgen_ty_1),
            "::",
            stringify!(custom_block_header)
        )
    );
}
#[test]
fn bindgen_test_layout_wtap_rec() {
    const UNINIT: ::std::mem::MaybeUninit<wtap_rec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wtap_rec>(),
        280usize,
        concat!("Size of: ", stringify!(wtap_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(wtap_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rec_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(rec_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).presence_flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(presence_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).section_number) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(section_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ts) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(ts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tsprec) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(tsprec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ts_rel_cap) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(ts_rel_cap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ts_rel_cap_valid) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(ts_rel_cap_valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rec_header) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(rec_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_was_modified) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(block_was_modified)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).options_buf) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(options_buf)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hashipv4 {
    pub addr: guint,
    pub flags: guint8,
    pub ip: [gchar; 16usize],
    pub name: [gchar; 64usize],
}
#[test]
fn bindgen_test_layout_hashipv4() {
    const UNINIT: ::std::mem::MaybeUninit<hashipv4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hashipv4>(),
        88usize,
        concat!("Size of: ", stringify!(hashipv4))
    );
    assert_eq!(
        ::std::mem::align_of::<hashipv4>(),
        4usize,
        concat!("Alignment of ", stringify!(hashipv4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hashipv4),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hashipv4),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(hashipv4),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(hashipv4),
            "::",
            stringify!(name)
        )
    );
}
pub type hashipv4_t = hashipv4;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hashipv6 {
    pub addr: [guint8; 16usize],
    pub flags: guint8,
    pub ip6: [gchar; 46usize],
    pub name: [gchar; 64usize],
}
#[test]
fn bindgen_test_layout_hashipv6() {
    const UNINIT: ::std::mem::MaybeUninit<hashipv6> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hashipv6>(),
        127usize,
        concat!("Size of: ", stringify!(hashipv6))
    );
    assert_eq!(
        ::std::mem::align_of::<hashipv6>(),
        1usize,
        concat!("Alignment of ", stringify!(hashipv6))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hashipv6),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hashipv6),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(hashipv6),
            "::",
            stringify!(ip6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        63usize,
        concat!(
            "Offset of field: ",
            stringify!(hashipv6),
            "::",
            stringify!(name)
        )
    );
}
pub type hashipv6_t = hashipv6;
#[doc = " A struct with lists of resolved addresses.\n  Used when writing name resolutions blocks (NRB)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo_lists {
    #[doc = "< A list of resolved hashipv4_t"]
    pub ipv4_addr_list: *mut GList,
    #[doc = "< A list of resolved hashipv6_t"]
    pub ipv6_addr_list: *mut GList,
}
#[test]
fn bindgen_test_layout_addrinfo_lists() {
    const UNINIT: ::std::mem::MaybeUninit<addrinfo_lists> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<addrinfo_lists>(),
        16usize,
        concat!("Size of: ", stringify!(addrinfo_lists))
    );
    assert_eq!(
        ::std::mem::align_of::<addrinfo_lists>(),
        8usize,
        concat!("Alignment of ", stringify!(addrinfo_lists))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipv4_addr_list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo_lists),
            "::",
            stringify!(ipv4_addr_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipv6_addr_list) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo_lists),
            "::",
            stringify!(ipv6_addr_list)
        )
    );
}
#[doc = " A struct with lists of resolved addresses.\n  Used when writing name resolutions blocks (NRB)"]
pub type addrinfo_lists_t = addrinfo_lists;
#[doc = " Parameters for various wtap_dump_* functions, specifying per-file\n information. The structure itself is no longer used after returning\n from wtap_dump_*, but its pointer fields must remain valid until\n wtap_dump_close is called.\n\n @note The shb_hdr and idb_inf arguments will be used until\n     wtap_dump_close() is called, but will not be free'd by the dumper. If\n     you created them, you must free them yourself after wtap_dump_close().\n     dsbs_initial will be freed by wtap_dump_close(),\n     dsbs_growing typically refers to another wth->dsbs.\n     nrbs_growing typically refers to another wth->nrbs.\n\n @see wtap_dump_params_init, wtap_dump_params_cleanup."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_dump_params {
    #[doc = "< Per-file packet encapsulation, or WTAP_ENCAP_PER_PACKET"]
    pub encap: ::std::os::raw::c_int,
    #[doc = "< Per-file snapshot length (what if it's per-interface?)"]
    pub snaplen: ::std::os::raw::c_int,
    #[doc = "< Per-file time stamp precision"]
    pub tsprec: ::std::os::raw::c_int,
    #[doc = "< The section header block(s) information, or NULL."]
    pub shb_hdrs: *mut GArray,
    #[doc = "< The interface description information, or NULL."]
    pub idb_inf: *mut wtapng_iface_descriptions_t,
    #[doc = "< NRBs that will be written while writing packets, or NULL.\nThis array may grow since the dumper was opened and will subsequently\nbe written before newer packets are written in wtap_dump."]
    pub nrbs_growing: *const GArray,
    #[doc = "< The initial Decryption Secrets Block(s) to be written, or NULL."]
    pub dsbs_initial: *mut GArray,
    #[doc = "< DSBs that will be written while writing packets, or NULL.\nThis array may grow since the dumper was opened and will subsequently\nbe written before newer packets are written in wtap_dump."]
    pub dsbs_growing: *const GArray,
    #[doc = "< Meta events that will be written while writing packets, or NULL.\nThis array may grow since the dumper was opened and will subsequently\nbe written before newer packets are written in wtap_dump."]
    pub sysdig_mev_growing: *const GArray,
    #[doc = "< XXX - don't copy IDBs; this should eventually always be the case."]
    pub dont_copy_idbs: gboolean,
}
#[test]
fn bindgen_test_layout_wtap_dump_params() {
    const UNINIT: ::std::mem::MaybeUninit<wtap_dump_params> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wtap_dump_params>(),
        72usize,
        concat!("Size of: ", stringify!(wtap_dump_params))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_dump_params>(),
        8usize,
        concat!("Alignment of ", stringify!(wtap_dump_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_dump_params),
            "::",
            stringify!(encap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).snaplen) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_dump_params),
            "::",
            stringify!(snaplen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tsprec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_dump_params),
            "::",
            stringify!(tsprec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shb_hdrs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_dump_params),
            "::",
            stringify!(shb_hdrs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).idb_inf) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_dump_params),
            "::",
            stringify!(idb_inf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nrbs_growing) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_dump_params),
            "::",
            stringify!(nrbs_growing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dsbs_initial) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_dump_params),
            "::",
            stringify!(dsbs_initial)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dsbs_growing) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_dump_params),
            "::",
            stringify!(dsbs_growing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sysdig_mev_growing) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_dump_params),
            "::",
            stringify!(sysdig_mev_growing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dont_copy_idbs) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_dump_params),
            "::",
            stringify!(dont_copy_idbs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_dumper {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_reader {
    _unused: [u8; 0],
}
pub type FILE_T = *mut wtap_reader;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_wslua_file_info {
    pub wslua_can_write_encap: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub wslua_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_wtap_wslua_file_info() {
    const UNINIT: ::std::mem::MaybeUninit<wtap_wslua_file_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wtap_wslua_file_info>(),
        16usize,
        concat!("Size of: ", stringify!(wtap_wslua_file_info))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_wslua_file_info>(),
        8usize,
        concat!("Alignment of ", stringify!(wtap_wslua_file_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wslua_can_write_encap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_wslua_file_info),
            "::",
            stringify!(wslua_can_write_encap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wslua_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_wslua_file_info),
            "::",
            stringify!(wslua_data)
        )
    );
}
pub type wtap_wslua_file_info_t = wtap_wslua_file_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_extension_info {
    pub name: *const ::std::os::raw::c_char,
    pub is_capture_file: gboolean,
    pub extensions: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_file_extension_info() {
    const UNINIT: ::std::mem::MaybeUninit<file_extension_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<file_extension_info>(),
        24usize,
        concat!("Size of: ", stringify!(file_extension_info))
    );
    assert_eq!(
        ::std::mem::align_of::<file_extension_info>(),
        8usize,
        concat!("Alignment of ", stringify!(file_extension_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_extension_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_capture_file) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_extension_info),
            "::",
            stringify!(is_capture_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extensions) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(file_extension_info),
            "::",
            stringify!(extensions)
        )
    );
}
pub const wtap_open_return_val_WTAP_OPEN_NOT_MINE: wtap_open_return_val = 0;
pub const wtap_open_return_val_WTAP_OPEN_MINE: wtap_open_return_val = 1;
pub const wtap_open_return_val_WTAP_OPEN_ERROR: wtap_open_return_val = -1;
pub type wtap_open_return_val = ::std::os::raw::c_int;
pub type wtap_open_routine_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut wtap,
        arg2: *mut ::std::os::raw::c_int,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> wtap_open_return_val,
>;
pub const wtap_open_type_OPEN_INFO_MAGIC: wtap_open_type = 0;
pub const wtap_open_type_OPEN_INFO_HEURISTIC: wtap_open_type = 1;
pub type wtap_open_type = ::std::os::raw::c_int;
extern "C" {
    pub fn init_open_routines();
}
extern "C" {
    pub fn cleanup_open_routines();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct open_info {
    pub name: *const ::std::os::raw::c_char,
    pub type_: wtap_open_type,
    pub open_routine: wtap_open_routine_t,
    pub extensions: *const ::std::os::raw::c_char,
    pub extensions_set: *mut *mut gchar,
    pub wslua_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_open_info() {
    const UNINIT: ::std::mem::MaybeUninit<open_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<open_info>(),
        48usize,
        concat!("Size of: ", stringify!(open_info))
    );
    assert_eq!(
        ::std::mem::align_of::<open_info>(),
        8usize,
        concat!("Alignment of ", stringify!(open_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(open_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(open_info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).open_routine) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(open_info),
            "::",
            stringify!(open_routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extensions) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(open_info),
            "::",
            stringify!(extensions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extensions_set) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(open_info),
            "::",
            stringify!(extensions_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wslua_data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(open_info),
            "::",
            stringify!(wslua_data)
        )
    );
}
extern "C" {
    pub static mut open_routines: *mut open_info;
}
pub const option_support_t_OPTION_NOT_SUPPORTED: option_support_t = 0;
pub const option_support_t_ONE_OPTION_SUPPORTED: option_support_t = 1;
pub const option_support_t_MULTIPLE_OPTIONS_SUPPORTED: option_support_t = 2;
pub type option_support_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct supported_option_type {
    pub opt: guint,
    pub support: option_support_t,
}
#[test]
fn bindgen_test_layout_supported_option_type() {
    const UNINIT: ::std::mem::MaybeUninit<supported_option_type> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<supported_option_type>(),
        8usize,
        concat!("Size of: ", stringify!(supported_option_type))
    );
    assert_eq!(
        ::std::mem::align_of::<supported_option_type>(),
        4usize,
        concat!("Alignment of ", stringify!(supported_option_type))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(supported_option_type),
            "::",
            stringify!(opt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).support) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(supported_option_type),
            "::",
            stringify!(support)
        )
    );
}
pub const block_support_t_BLOCK_NOT_SUPPORTED: block_support_t = 0;
pub const block_support_t_ONE_BLOCK_SUPPORTED: block_support_t = 1;
pub const block_support_t_MULTIPLE_BLOCKS_SUPPORTED: block_support_t = 2;
pub type block_support_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct supported_block_type {
    pub type_: wtap_block_type_t,
    pub support: block_support_t,
    pub num_supported_options: usize,
    pub supported_options: *const supported_option_type,
}
#[test]
fn bindgen_test_layout_supported_block_type() {
    const UNINIT: ::std::mem::MaybeUninit<supported_block_type> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<supported_block_type>(),
        24usize,
        concat!("Size of: ", stringify!(supported_block_type))
    );
    assert_eq!(
        ::std::mem::align_of::<supported_block_type>(),
        8usize,
        concat!("Alignment of ", stringify!(supported_block_type))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(supported_block_type),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).support) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(supported_block_type),
            "::",
            stringify!(support)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_supported_options) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(supported_block_type),
            "::",
            stringify!(num_supported_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supported_options) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(supported_block_type),
            "::",
            stringify!(supported_options)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_type_subtype_info {
    #[doc = " The file type description."]
    pub description: *const ::std::os::raw::c_char,
    #[doc = " The file type name, used to look up file types by name, e.g.\n looking up a file type specified as a command-line argument."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " The default file extension, used to save this type.\n Should be NULL if no default extension is known."]
    pub default_file_extension: *const ::std::os::raw::c_char,
    #[doc = " A semicolon-separated list of additional file extensions\n used for this type.\n Should be NULL if no extensions, or no extensions other\n than the default extension, are known."]
    pub additional_file_extensions: *const ::std::os::raw::c_char,
    #[doc = " When writing this file format, is seeking required?"]
    pub writing_must_seek: gboolean,
    #[doc = " Number of block types supported."]
    pub num_supported_blocks: usize,
    #[doc = " Table of block types supported."]
    pub supported_blocks: *const supported_block_type,
    #[doc = " Can this type write this encapsulation format?\n Should be NULL is this file type doesn't have write support."]
    pub can_write_encap: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    >,
    #[doc = " The function to open the capture file for writing.\n Should be NULL if this file type doesn't have write support."]
    pub dump_open: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut wtap_dumper,
            arg2: *mut ::std::os::raw::c_int,
            arg3: *mut *mut gchar,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " If can_write_encap returned WTAP_ERR_CHECK_WSLUA, then this is used instead.\n This should be NULL for everyone except Lua-based file writers."]
    pub wslua_info: *mut wtap_wslua_file_info_t,
}
#[test]
fn bindgen_test_layout_file_type_subtype_info() {
    const UNINIT: ::std::mem::MaybeUninit<file_type_subtype_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<file_type_subtype_info>(),
        80usize,
        concat!("Size of: ", stringify!(file_type_subtype_info))
    );
    assert_eq!(
        ::std::mem::align_of::<file_type_subtype_info>(),
        8usize,
        concat!("Alignment of ", stringify!(file_type_subtype_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_type_subtype_info),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_type_subtype_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_file_extension) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(file_type_subtype_info),
            "::",
            stringify!(default_file_extension)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).additional_file_extensions) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(file_type_subtype_info),
            "::",
            stringify!(additional_file_extensions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).writing_must_seek) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(file_type_subtype_info),
            "::",
            stringify!(writing_must_seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_supported_blocks) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(file_type_subtype_info),
            "::",
            stringify!(num_supported_blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supported_blocks) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(file_type_subtype_info),
            "::",
            stringify!(supported_blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_write_encap) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file_type_subtype_info),
            "::",
            stringify!(can_write_encap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dump_open) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(file_type_subtype_info),
            "::",
            stringify!(dump_open)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wslua_info) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(file_type_subtype_info),
            "::",
            stringify!(wslua_info)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialize the Wiretap library.\n\n @param load_wiretap_plugins Load Wiretap plugins when initializing library."]
    pub fn wtap_init(load_wiretap_plugins: gboolean);
}
extern "C" {
    #[doc = " On failure, \"wtap_open_offline()\" returns NULL, and puts into the\n \"int\" pointed to by its second argument:\n\n @param filename Name of the file to open\n @param type WTAP_TYPE_AUTO for automatic recognize file format or explicit choose format type\n @param[out] err a positive \"errno\" value if the capture file can't be opened;\n a negative number, indicating the type of error, on other failures.\n @param[out] err_info for some errors, a string giving more details of\n the error\n @param do_random TRUE if random access to the file will be done,\n FALSE if not"]
    pub fn wtap_open_offline(
        filename: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_uint,
        err: *mut ::std::os::raw::c_int,
        err_info: *mut *mut gchar,
        do_random: gboolean,
    ) -> *mut wtap;
}
extern "C" {
    #[doc = " If we were compiled with zlib and we're at EOF, unset EOF so that\n wtap_read/gzread has a chance to succeed. This is necessary if\n we're tailing a file."]
    pub fn wtap_cleareof(wth: *mut wtap);
}
#[doc = " Set callback functions to add new hostnames. Currently pcapng-only.\n MUST match add_ipv4_name and add_ipv6_name in addr_resolv.c."]
pub type wtap_new_ipv4_callback_t = ::std::option::Option<
    unsafe extern "C" fn(addr: guint, name: *const gchar, static_entry: gboolean),
>;
extern "C" {
    pub fn wtap_set_cb_new_ipv4(wth: *mut wtap, add_new_ipv4: wtap_new_ipv4_callback_t);
}
pub type wtap_new_ipv6_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        addrp: *const ::std::os::raw::c_void,
        name: *const gchar,
        static_entry: gboolean,
    ),
>;
extern "C" {
    pub fn wtap_set_cb_new_ipv6(wth: *mut wtap, add_new_ipv6: wtap_new_ipv6_callback_t);
}
#[doc = " Set callback function to receive new decryption secrets for a particular\n secrets type (as defined in secrets-types.h). Currently pcapng-only."]
pub type wtap_new_secrets_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        secrets_type: guint32,
        secrets: *const ::std::os::raw::c_void,
        size: guint,
    ),
>;
extern "C" {
    pub fn wtap_set_cb_new_secrets(wth: *mut wtap, add_new_secrets: wtap_new_secrets_callback_t);
}
#[doc = " Set callback function to receive new sysdig meta events. Currently pcapng-only."]
pub type wtap_new_sysdig_meta_event_callback_t = ::std::option::Option<
    unsafe extern "C" fn(mev_type: u32, mev_data: *const u8, mev_data_size: ::std::os::raw::c_uint),
>;
extern "C" {
    pub fn wtap_set_cb_new_sysdig_meta_event(
        wth: *mut wtap,
        add_new_sysdig_meta_event: wtap_new_sysdig_meta_event_callback_t,
    );
}
extern "C" {
    #[doc = " Read the next record in the file, filling in *phdr and *buf.\n\n @wth a wtap * returned by a call that opened a file for reading.\n @rec a pointer to a wtap_rec, filled in with information about the\n record.\n @buf a pointer to a Buffer, filled in with data from the record.\n @param err a positive \"errno\" value, or a negative number indicating\n the type of error, if the read failed.\n @param err_info for some errors, a string giving more details of\n the error\n @param offset a pointer to a gint64, set to the offset in the file\n that should be used on calls to wtap_seek_read() to reread that record,\n if the read succeeded.\n @return TRUE on success, FALSE on failure."]
    pub fn wtap_read(
        wth: *mut wtap,
        rec: *mut wtap_rec,
        buf: *mut Buffer,
        err: *mut ::std::os::raw::c_int,
        err_info: *mut *mut gchar,
        offset: *mut gint64,
    ) -> gboolean;
}
extern "C" {
    #[doc = " Read the record at a specified offset in a capture file, filling in\n *phdr and *buf.\n\n @wth a wtap * returned by a call that opened a file for random-access\n reading.\n @seek_off a gint64 giving an offset value returned by a previous\n wtap_read() call.\n @rec a pointer to a struct wtap_rec, filled in with information\n about the record.\n @buf a pointer to a Buffer, filled in with data from the record.\n @param err a positive \"errno\" value, or a negative number indicating\n the type of error, if the read failed.\n @param err_info for some errors, a string giving more details of\n the error\n @return TRUE on success, FALSE on failure."]
    pub fn wtap_seek_read(
        wth: *mut wtap,
        seek_off: gint64,
        rec: *mut wtap_rec,
        buf: *mut Buffer,
        err: *mut ::std::os::raw::c_int,
        err_info: *mut *mut gchar,
    ) -> gboolean;
}
extern "C" {
    #[doc = " initialize a wtap_rec structure"]
    pub fn wtap_rec_init(rec: *mut wtap_rec);
}
extern "C" {
    #[doc = " Re-initialize a wtap_rec structure"]
    pub fn wtap_rec_reset(rec: *mut wtap_rec);
}
extern "C" {
    #[doc = " clean up a wtap_rec structure, freeing what wtap_rec_init() allocated"]
    pub fn wtap_rec_cleanup(rec: *mut wtap_rec);
}
pub const wtap_compression_type_WTAP_UNCOMPRESSED: wtap_compression_type = 0;
pub const wtap_compression_type_WTAP_GZIP_COMPRESSED: wtap_compression_type = 1;
pub const wtap_compression_type_WTAP_ZSTD_COMPRESSED: wtap_compression_type = 2;
pub const wtap_compression_type_WTAP_LZ4_COMPRESSED: wtap_compression_type = 3;
pub type wtap_compression_type = ::std::os::raw::c_int;
extern "C" {
    pub fn wtap_get_compression_type(wth: *mut wtap) -> wtap_compression_type;
}
extern "C" {
    pub fn wtap_compression_type_description(
        compression_type: wtap_compression_type,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wtap_compression_type_extension(
        compression_type: wtap_compression_type,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wtap_get_all_compression_type_extensions_list() -> *mut GSList;
}
extern "C" {
    #[doc = " Return an approximation of the amount of data we've read sequentially\n from the file so far."]
    pub fn wtap_read_so_far(wth: *mut wtap) -> gint64;
}
extern "C" {
    pub fn wtap_file_size(wth: *mut wtap, err: *mut ::std::os::raw::c_int) -> gint64;
}
extern "C" {
    pub fn wtap_snapshot_length(wth: *mut wtap) -> guint;
}
extern "C" {
    pub fn wtap_file_type_subtype(wth: *mut wtap) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wtap_file_encap(wth: *mut wtap) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wtap_file_tsprec(wth: *mut wtap) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Gets number of section header blocks.\n @details Returns the number of existing SHBs.\n\n @param wth The wiretap session.\n @return The number of existing section headers."]
    pub fn wtap_file_get_num_shbs(wth: *mut wtap) -> guint;
}
extern "C" {
    #[doc = " @brief Gets existing section header block, not for new file.\n @details Returns the pointer to an existing SHB, without creating a\n          new one. This should only be used for accessing info, not\n          for creating a new file based on existing SHB info. Use\n          wtap_file_get_shb_for_new_file() for that.\n\n @param wth The wiretap session.\n @param shb_num The ordinal number (0-based) of the section header\n in the file\n @return The specified existing section header, which must NOT be g_free'd."]
    pub fn wtap_file_get_shb(wth: *mut wtap, shb_num: guint) -> wtap_block_t;
}
extern "C" {
    #[doc = " @brief Sets or replaces the section header comment.\n @details The passed-in comment string is set to be the comment\n          for the section header block. The passed-in string's\n          ownership will be owned by the block, so it should be\n          duplicated before passing into this function.\n\n @param wth The wiretap session.\n @param comment The comment string."]
    pub fn wtap_write_shb_comment(wth: *mut wtap, comment: *mut gchar);
}
extern "C" {
    #[doc = " @brief Gets existing interface descriptions.\n @details Returns a new struct containing a pointer to the existing\n          description, without creating new descriptions internally.\n @note The returned pointer must be g_free'd, but its internal\n       interface_data must not.\n\n @param wth The wiretap session.\n @return A new struct of the existing section descriptions, which must be g_free'd."]
    pub fn wtap_file_get_idb_info(wth: *mut wtap) -> *mut wtapng_iface_descriptions_t;
}
extern "C" {
    #[doc = " @brief Gets next interface description.\n\n @details This returns the first unfetched wtap_block_t from the set\n of interface descriptions.  Returns NULL if there are no more\n unfetched interface descriptions; a subsequent call after\n wtap_read() returns, either with a new record or an EOF, may return\n another interface description."]
    pub fn wtap_get_next_interface_description(wth: *mut wtap) -> wtap_block_t;
}
extern "C" {
    #[doc = " @brief Free's a interface description block and all of its members.\n\n @details This free's all of the interface descriptions inside the passed-in\n     struct, including their members (e.g., comments); and then free's the\n     passed-in struct as well.\n\n @warning Do not use this for the struct returned by\n     wtap_file_get_idb_info(), as that one did not create the internal\n     interface descriptions; for that case you can simply g_free() the new\n     struct."]
    pub fn wtap_free_idb_info(idb_info: *mut wtapng_iface_descriptions_t);
}
extern "C" {
    #[doc = " @brief Gets a debug string of an interface description.\n @details Returns a newly allocated string of debug information about\n          the given interface descrption, useful for debugging.\n @note The returned pointer must be g_free'd.\n\n @param if_descr The interface description.\n @param indent Number of spaces to indent each line by.\n @param line_end A string to append to each line (e.g., \"\\n\" or \", \").\n @return A newly allocated gcahr array string, which must be g_free'd."]
    pub fn wtap_get_debug_if_descr(
        if_descr: wtap_block_t,
        indent: ::std::os::raw::c_int,
        line_end: *const ::std::os::raw::c_char,
    ) -> *mut gchar;
}
extern "C" {
    #[doc = " @brief Gets existing name resolution block, not for new file.\n @details Returns the pointer to the existing NRB, without creating a\n          new one. This should only be used for accessing info, not\n          for creating a new file based on existing NRB info. Use\n          wtap_file_get_nrb_for_new_file() for that.\n\n @param wth The wiretap session.\n @return The existing section header, which must NOT be g_free'd.\n\n XXX - need to be updated to handle multiple NRBs."]
    pub fn wtap_file_get_nrb(wth: *mut wtap) -> wtap_block_t;
}
extern "C" {
    #[doc = " @brief Adds a Decryption Secrets Block to the open wiretap session.\n @details The passed-in DSB is added to the DSBs for the current\n          session.\n\n @param wth The wiretap session.\n @param dsb The Decryption Secrets Block to add"]
    pub fn wtap_file_add_decryption_secrets(wth: *mut wtap, dsb: wtap_block_t);
}
extern "C" {
    #[doc = " Remove any decryption secret information from the per-file information;\n used if we're stripping decryption secrets while the file is open\n\n @param wth The wiretap session from which to remove the\n decryption secrets.\n @return TRUE if any DSBs were removed"]
    pub fn wtap_file_discard_decryption_secrets(wth: *mut wtap) -> gboolean;
}
extern "C" {
    #[doc = " close the file descriptors for the current file"]
    pub fn wtap_fdclose(wth: *mut wtap);
}
extern "C" {
    #[doc = " reopen the random file descriptor for the current file"]
    pub fn wtap_fdreopen(
        wth: *mut wtap,
        filename: *const ::std::os::raw::c_char,
        err: *mut ::std::os::raw::c_int,
    ) -> gboolean;
}
extern "C" {
    #[doc = " Close only the sequential side, freeing up memory it uses."]
    pub fn wtap_sequential_close(wth: *mut wtap);
}
extern "C" {
    #[doc = " Closes any open file handles and frees the memory associated with wth."]
    pub fn wtap_close(wth: *mut wtap);
}
extern "C" {
    #[doc = " dump packets into a capture file"]
    pub fn wtap_dump_can_open(filetype: ::std::os::raw::c_int) -> gboolean;
}
extern "C" {
    #[doc = " Given a GArray of WTAP_ENCAP_ types, return the per-file encapsulation\n type that would be needed to write out a file with those types."]
    pub fn wtap_dump_required_file_encap_type(file_encaps: *const GArray) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return TRUE if we can write this encapsulation type in this\n capture file type/subtype, FALSE if not."]
    pub fn wtap_dump_can_write_encap(
        file_type_subtype: ::std::os::raw::c_int,
        encap: ::std::os::raw::c_int,
    ) -> gboolean;
}
extern "C" {
    #[doc = " Return TRUE if we can write this capture file type/subtype out in\n compressed form, FALSE if not."]
    pub fn wtap_dump_can_compress(file_type_subtype: ::std::os::raw::c_int) -> gboolean;
}
extern "C" {
    #[doc = " Initialize the per-file information based on an existing file. Its\n contents must be freed according to the requirements of wtap_dump_params.\n If wth does not remain valid for the duration of the session, dsbs_growing\n MUST be cleared after this function.\n\n @param params The parameters for wtap_dump_* to initialize.\n @param wth The wiretap session."]
    pub fn wtap_dump_params_init(params: *mut wtap_dump_params, wth: *mut wtap);
}
extern "C" {
    #[doc = " Initialize the per-file information based on an existing file, but\n don't copy over the interface information. Its contents must be freed\n according to the requirements of wtap_dump_params.\n If wth does not remain valid for the duration of the session, dsbs_growing\n MUST be cleared after this function.\n\n XXX - this should eventually become wtap_dump_params_init(), with all\n programs writing capture files copying IDBs over by hand, so that they\n handle IDBs in the middle of the file.\n\n @param params The parameters for wtap_dump_* to initialize.\n @param wth The wiretap session."]
    pub fn wtap_dump_params_init_no_idbs(params: *mut wtap_dump_params, wth: *mut wtap);
}
extern "C" {
    #[doc = " Remove any name resolution information from the per-file information;\n used if we're stripping name resolution as we write the file.\n\n @param params The parameters for wtap_dump_* from which to remove the\n name resolution.."]
    pub fn wtap_dump_params_discard_name_resolution(params: *mut wtap_dump_params);
}
extern "C" {
    #[doc = " Remove any decryption secret information from the per-file information;\n used if we're stripping decryption secrets as we write the file.\n\n @param params The parameters for wtap_dump_* from which to remove the\n decryption secrets.."]
    pub fn wtap_dump_params_discard_decryption_secrets(params: *mut wtap_dump_params);
}
extern "C" {
    #[doc = " Free memory associated with the wtap_dump_params when it is no longer in\n use by wtap_dumper.\n\n @param params The parameters as initialized by wtap_dump_params_init."]
    pub fn wtap_dump_params_cleanup(params: *mut wtap_dump_params);
}
extern "C" {
    #[doc = " @brief Opens a new capture file for writing.\n\n @param filename The new file's name.\n @param file_type_subtype The WTAP_FILE_TYPE_SUBTYPE_XXX file type.\n @param compression_type Type of compression to use when writing, if any\n @param params The per-file information for this file.\n @param[out] err Will be set to an error code on failure.\n @param[out] err_info for some errors, a string giving more details of\n the error\n @return The newly created dumper object, or NULL on failure."]
    pub fn wtap_dump_open(
        filename: *const ::std::os::raw::c_char,
        file_type_subtype: ::std::os::raw::c_int,
        compression_type: wtap_compression_type,
        params: *const wtap_dump_params,
        err: *mut ::std::os::raw::c_int,
        err_info: *mut *mut gchar,
    ) -> *mut wtap_dumper;
}
extern "C" {
    #[doc = " @brief Creates a dumper for a temporary file.\n\n @param tmpdir Directory in which to create the temporary file.\n @param filenamep Points to a pointer that's set to point to the\n        pathname of the temporary file; it's allocated with g_malloc()\n @param pfx A string to be used as the prefix for the temporary file name\n @param file_type_subtype The WTAP_FILE_TYPE_SUBTYPE_XXX file type.\n @param compression_type Type of compression to use when writing, if any\n @param params The per-file information for this file.\n @param[out] err Will be set to an error code on failure.\n @param[out] err_info for some errors, a string giving more details of\n the error\n @return The newly created dumper object, or NULL on failure."]
    pub fn wtap_dump_open_tempfile(
        tmpdir: *const ::std::os::raw::c_char,
        filenamep: *mut *mut ::std::os::raw::c_char,
        pfx: *const ::std::os::raw::c_char,
        file_type_subtype: ::std::os::raw::c_int,
        compression_type: wtap_compression_type,
        params: *const wtap_dump_params,
        err: *mut ::std::os::raw::c_int,
        err_info: *mut *mut gchar,
    ) -> *mut wtap_dumper;
}
extern "C" {
    #[doc = " @brief Creates a dumper for an existing file descriptor.\n\n @param fd The file descriptor for which the dumper should be created.\n @param file_type_subtype The WTAP_FILE_TYPE_SUBTYPE_XXX file type.\n @param compression_type Type of compression to use when writing, if any\n @param params The per-file information for this file.\n @param[out] err Will be set to an error code on failure.\n @param[out] err_info for some errors, a string giving more details of\n the error\n @return The newly created dumper object, or NULL on failure."]
    pub fn wtap_dump_fdopen(
        fd: ::std::os::raw::c_int,
        file_type_subtype: ::std::os::raw::c_int,
        compression_type: wtap_compression_type,
        params: *const wtap_dump_params,
        err: *mut ::std::os::raw::c_int,
        err_info: *mut *mut gchar,
    ) -> *mut wtap_dumper;
}
extern "C" {
    #[doc = " @brief Creates a dumper for the standard output.\n\n @param file_type_subtype The WTAP_FILE_TYPE_SUBTYPE_XXX file type.\n @param compression_type Type of compression to use when writing, if any\n @param params The per-file information for this file.\n @param[out] err Will be set to an error code on failure.\n @param[out] err_info for some errors, a string giving more details of\n the error\n @return The newly created dumper object, or NULL on failure."]
    pub fn wtap_dump_open_stdout(
        file_type_subtype: ::std::os::raw::c_int,
        compression_type: wtap_compression_type,
        params: *const wtap_dump_params,
        err: *mut ::std::os::raw::c_int,
        err_info: *mut *mut gchar,
    ) -> *mut wtap_dumper;
}
extern "C" {
    pub fn wtap_dump_add_idb(
        wdh: *mut wtap_dumper,
        idb: wtap_block_t,
        err: *mut ::std::os::raw::c_int,
        err_info: *mut *mut gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn wtap_dump(
        arg1: *mut wtap_dumper,
        arg2: *const wtap_rec,
        arg3: *const guint8,
        err: *mut ::std::os::raw::c_int,
        err_info: *mut *mut gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn wtap_dump_flush(arg1: *mut wtap_dumper, arg2: *mut ::std::os::raw::c_int) -> gboolean;
}
extern "C" {
    pub fn wtap_dump_file_type_subtype(wdh: *mut wtap_dumper) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wtap_get_bytes_dumped(arg1: *mut wtap_dumper) -> gint64;
}
extern "C" {
    pub fn wtap_set_bytes_dumped(wdh: *mut wtap_dumper, bytes_dumped: gint64);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
    _unused: [u8; 0],
}
extern "C" {
    pub fn wtap_addrinfo_list_empty(addrinfo_lists: *mut addrinfo_lists_t) -> gboolean;
}
extern "C" {
    pub fn wtap_dump_set_addrinfo_list(
        wdh: *mut wtap_dumper,
        addrinfo_lists: *mut addrinfo_lists_t,
    ) -> gboolean;
}
extern "C" {
    pub fn wtap_dump_discard_name_resolution(wdh: *mut wtap_dumper);
}
extern "C" {
    pub fn wtap_dump_discard_decryption_secrets(wdh: *mut wtap_dumper);
}
extern "C" {
    #[doc = " Closes open file handles and frees memory associated with wdh. Note that\n shb_hdr and idb_inf are not freed by this routine.\n\n @param wdh handle for the file we're closing.\n @param[out] needs_reload if not null, points to a gboolean that will\n    be set to TRUE if a full reload of the file would be required if\n    this was done as part of a \"Save\" or \"Save As\" operation, FALSE\n    if no full reload would be required.\n @param[out] err points to an int that will be set to an error code\n    on failure.\n @param[out] err_info for some errors, points to a gchar * that will\n    be set to a string giving more details of the error.\n\n @return TRUE on success, FALSE on failure."]
    pub fn wtap_dump_close(
        wdh: *mut wtap_dumper,
        needs_reload: *mut gboolean,
        err: *mut ::std::os::raw::c_int,
        err_info: *mut *mut gchar,
    ) -> gboolean;
}
extern "C" {
    #[doc = " Return TRUE if we can write a file out with the given GArray of file\n encapsulations and the given bitmask of comment types."]
    pub fn wtap_dump_can_write(
        file_encaps: *const GArray,
        required_comment_types: guint32,
    ) -> gboolean;
}
extern "C" {
    #[doc = " Generates arbitrary packet data in \"exported PDU\" format\n and appends it to buf.\n For filetype readers to transform non-packetized data.\n Calls ws_buffer_asssure_space() for you and handles padding\n to 4-byte boundary.\n\n @param[in,out] buf   Buffer into which to write field\n @param epdu_tag      tag ID of field to create\n @param data          data to be written\n @param data_len      length of data"]
    pub fn wtap_buffer_append_epdu_tag(
        buf: *mut Buffer,
        epdu_tag: guint16,
        data: *const guint8,
        data_len: guint16,
    );
}
extern "C" {
    #[doc = " Generates packet data for an unsigned integer in \"exported PDU\" format.\n For filetype readers to transform non-packetized data.\n\n @param[in,out] buf   Buffer into which to write field\n @param epdu_tag      tag ID of field to create\n @param val           integer value to write to buf"]
    pub fn wtap_buffer_append_epdu_uint(buf: *mut Buffer, epdu_tag: guint16, val: guint32);
}
extern "C" {
    #[doc = " Generates packet data for a string in \"exported PDU\" format.\n For filetype readers to transform non-packetized data.\n\n @param[in,out] buf   Buffer into which to write field\n @param epdu_tag      tag ID of field to create\n @param val           string value to write to buf"]
    pub fn wtap_buffer_append_epdu_string(
        buf: *mut Buffer,
        epdu_tag: guint16,
        val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Close off a set of \"exported PDUs\" added to the buffer.\n For filetype readers to transform non-packetized data.\n\n @param[in,out] buf   Buffer into which to write field\n\n @return Total length of buf populated to date"]
    pub fn wtap_buffer_append_epdu_end(buf: *mut Buffer) -> gint;
}
pub const ft_sort_order_FT_SORT_BY_NAME: ft_sort_order = 0;
pub const ft_sort_order_FT_SORT_BY_DESCRIPTION: ft_sort_order = 1;
pub type ft_sort_order = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Get a GArray of file type/subtype values for file types/subtypes\n that can be used to save a file of a given type with a given GArray of\n WTAP_ENCAP_ types and the given bitmask of comment types."]
    pub fn wtap_get_savable_file_types_subtypes_for_file(
        file_type_subtype: ::std::os::raw::c_int,
        file_encaps: *const GArray,
        required_comment_types: guint32,
        sort_order: ft_sort_order,
    ) -> *mut GArray;
}
extern "C" {
    #[doc = " Get a GArray of all writable file type/subtype values."]
    pub fn wtap_get_writable_file_types_subtypes(sort_order: ft_sort_order) -> *mut GArray;
}
extern "C" {
    #[doc = " various file type/subtype functions"]
    pub fn wtap_file_type_subtype_description(
        file_type_subtype: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wtap_file_type_subtype_name(
        file_type_subtype: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wtap_name_to_file_type_subtype(
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wtap_pcap_file_type_subtype() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wtap_pcap_nsec_file_type_subtype() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wtap_pcapng_file_type_subtype() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return an indication of whether this capture file format supports\n the block in question."]
    pub fn wtap_file_type_subtype_supports_block(
        file_type_subtype: ::std::os::raw::c_int,
        type_: wtap_block_type_t,
    ) -> block_support_t;
}
extern "C" {
    #[doc = " Return an indication of whether this capture file format supports\n the option in queston for the block in question."]
    pub fn wtap_file_type_subtype_supports_option(
        file_type_subtype: ::std::os::raw::c_int,
        type_: wtap_block_type_t,
        opttype: guint,
    ) -> option_support_t;
}
extern "C" {
    pub fn wtap_get_all_capture_file_extensions_list() -> *mut GSList;
}
extern "C" {
    pub fn wtap_get_all_file_extensions_list() -> *mut GSList;
}
extern "C" {
    pub fn wtap_free_extensions_list(extensions: *mut GSList);
}
extern "C" {
    pub fn wtap_default_file_extension(
        file_type_subtype: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wtap_get_file_extensions_list(
        file_type_subtype: ::std::os::raw::c_int,
        include_compressed: gboolean,
    ) -> *mut GSList;
}
extern "C" {
    pub fn wtap_encap_name(encap: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wtap_encap_description(encap: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wtap_name_to_encap(short_name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wtap_tsprec_string(tsprec: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wtap_strerror(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " get available number of file types and encapsulations"]
    pub fn wtap_get_num_file_type_extensions() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wtap_get_num_encap_types() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get information for file type extension"]
    pub fn wtap_get_file_extension_type_name(
        extension_type: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wtap_get_file_extension_type_extensions(extension_type: guint) -> *mut GSList;
}
extern "C" {
    #[doc = " dynamically register new file types and encapsulations"]
    pub fn wtap_register_file_type_extension(ei: *const file_extension_info);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_plugin {
    pub register_wtap_module: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_wtap_plugin() {
    const UNINIT: ::std::mem::MaybeUninit<wtap_plugin> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wtap_plugin>(),
        8usize,
        concat!("Size of: ", stringify!(wtap_plugin))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_plugin>(),
        8usize,
        concat!("Alignment of ", stringify!(wtap_plugin))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_wtap_module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_plugin),
            "::",
            stringify!(register_wtap_module)
        )
    );
}
extern "C" {
    pub fn wtap_register_plugin(plug: *const wtap_plugin);
}
extern "C" {
    #[doc = " Returns_\n     0 if plugins can be loaded for libwiretap (file type).\n     1 if plugins are not supported by the platform.\n    -1 if plugins were disabled in the build configuration."]
    pub fn wtap_plugins_supported() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wtap_register_open_info(oi: *mut open_info, first_routine: gboolean);
}
extern "C" {
    pub fn wtap_has_open_info(name: *const gchar) -> gboolean;
}
extern "C" {
    pub fn wtap_uses_lua_filehandler(wth: *const wtap) -> gboolean;
}
extern "C" {
    pub fn wtap_deregister_open_info(name: *const gchar);
}
extern "C" {
    pub fn open_info_name_to_type(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn wtap_register_file_type_subtype(
        fi: *const file_type_subtype_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wtap_deregister_file_type_subtype(file_type_subtype: ::std::os::raw::c_int);
}
extern "C" {
    pub fn wtap_register_encap_type(
        description: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Cleanup the internal library structures"]
    pub fn wtap_cleanup();
}
extern "C" {
    #[doc = " @brief Fetch the current epan scope.\n\n Allocated memory is freed when wmem_leave_epan_scope() is called, which is normally at program exit."]
    pub fn wmem_epan_scope() -> *mut wmem_allocator_t;
}
extern "C" {
    #[doc = " @brief Fetch the current packet scope.\n\n Allocated memory is freed when wmem_leave_packet_scope() is called, which is normally at the end of packet dissection.\n N.B. Please use pinfo->pool in new code when possible. See\n <https://www.wireshark.org/lists/wireshark-dev/202107/msg00052.html>"]
    pub fn wmem_packet_scope() -> *mut wmem_allocator_t;
}
extern "C" {
    pub fn wmem_enter_packet_scope();
}
extern "C" {
    pub fn wmem_leave_packet_scope();
}
extern "C" {
    #[doc = " @brief Fetch the current file scope.\n\n Allocated memory is freed when wmem_leave_file_scope() is called, which is normally when a capture file is closed."]
    pub fn wmem_file_scope() -> *mut wmem_allocator_t;
}
extern "C" {
    pub fn wmem_enter_file_scope();
}
extern "C" {
    pub fn wmem_leave_file_scope();
}
extern "C" {
    pub fn wmem_init_scopes();
}
extern "C" {
    pub fn wmem_cleanup_scopes();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipv4_addr_and_mask {
    pub addr: guint32,
    pub nmask: guint32,
}
#[test]
fn bindgen_test_layout_ipv4_addr_and_mask() {
    const UNINIT: ::std::mem::MaybeUninit<ipv4_addr_and_mask> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ipv4_addr_and_mask>(),
        8usize,
        concat!("Size of: ", stringify!(ipv4_addr_and_mask))
    );
    assert_eq!(
        ::std::mem::align_of::<ipv4_addr_and_mask>(),
        4usize,
        concat!("Alignment of ", stringify!(ipv4_addr_and_mask))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv4_addr_and_mask),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nmask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv4_addr_and_mask),
            "::",
            stringify!(nmask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _e_guid_t {
    pub data1: guint32,
    pub data2: guint16,
    pub data3: guint16,
    pub data4: [guint8; 8usize],
}
#[test]
fn bindgen_test_layout__e_guid_t() {
    const UNINIT: ::std::mem::MaybeUninit<_e_guid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_e_guid_t>(),
        16usize,
        concat!("Size of: ", stringify!(_e_guid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_e_guid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_e_guid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_guid_t),
            "::",
            stringify!(data1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_guid_t),
            "::",
            stringify!(data2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data3) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_guid_t),
            "::",
            stringify!(data3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data4) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_guid_t),
            "::",
            stringify!(data4)
        )
    );
}
pub type e_guid_t = _e_guid_t;
extern "C" {
    pub fn guids_init();
}
extern "C" {
    pub fn guids_add_guid(guid: *const e_guid_t, name: *const gchar);
}
extern "C" {
    pub fn guids_get_guid_name(guid: *const e_guid_t, scope: *mut wmem_allocator_t)
        -> *const gchar;
}
extern "C" {
    pub fn guids_resolve_guid_to_str(
        guid: *const e_guid_t,
        scope: *mut wmem_allocator_t,
    ) -> *const gchar;
}
extern "C" {
    pub fn guid_cmp(g1: *const e_guid_t, g2: *const e_guid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn guid_hash(guid: *const e_guid_t) -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipv6_addr_and_prefix {
    pub addr: ws_in6_addr,
    pub prefix: guint32,
}
#[test]
fn bindgen_test_layout_ipv6_addr_and_prefix() {
    const UNINIT: ::std::mem::MaybeUninit<ipv6_addr_and_prefix> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ipv6_addr_and_prefix>(),
        20usize,
        concat!("Size of: ", stringify!(ipv6_addr_and_prefix))
    );
    assert_eq!(
        ::std::mem::align_of::<ipv6_addr_and_prefix>(),
        4usize,
        concat!("Alignment of ", stringify!(ipv6_addr_and_prefix))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_addr_and_prefix),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_addr_and_prefix),
            "::",
            stringify!(prefix)
        )
    );
}
#[doc = " The pattern object used for ws_mempbrk_exec()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ws_mempbrk_pattern {
    pub patt: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_ws_mempbrk_pattern() {
    const UNINIT: ::std::mem::MaybeUninit<ws_mempbrk_pattern> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ws_mempbrk_pattern>(),
        256usize,
        concat!("Size of: ", stringify!(ws_mempbrk_pattern))
    );
    assert_eq!(
        ::std::mem::align_of::<ws_mempbrk_pattern>(),
        1usize,
        concat!("Alignment of ", stringify!(ws_mempbrk_pattern))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).patt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ws_mempbrk_pattern),
            "::",
            stringify!(patt)
        )
    );
}
extern "C" {
    #[doc = " Compile the pattern for the needles to find using ws_mempbrk_exec()."]
    pub fn ws_mempbrk_compile(
        pattern: *mut ws_mempbrk_pattern,
        needles: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Scan for the needles specified by the compiled pattern."]
    pub fn ws_mempbrk_exec(
        haystack: *const u8,
        haystacklen: usize,
        pattern: *const ws_mempbrk_pattern,
        found_needle: *mut ::std::os::raw::c_uchar,
    ) -> *const u8;
}
#[doc = " \"testy, virtual(-izable) buffer\".  They are testy in that they get mad when\n an attempt is made to access data beyond the bounds of their array. In that\n case, they throw an exception.\n\n They are virtualizable in that new tvbuff's can be made from other tvbuffs,\n while only the original tvbuff may have data. That is, the new tvbuff has\n virtual data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tvbuff {
    _unused: [u8; 0],
}
pub type tvbuff_t = tvbuff;
#[doc = " A \"real\" tvbuff contains a guint8* that points to real data.\n The data is allocated and contiguous.\n\n A \"subset\" tvbuff has a backing tvbuff. It is a \"window\" through\n which the program sees only a portion of the backing tvbuff.\n\n A \"composite\" tvbuff combines multiple tvbuffs sequentially to\n produce a larger byte array.\n\n tvbuff's of any type can be used as the backing-tvbuff of a\n \"subset\" tvbuff or as a member of a \"composite\" tvbuff.\n \"composite\" tvbuffs can have member-tvbuffs of different types.\n\n Once a tvbuff is create/initialized/finalized, the tvbuff is read-only.\n That is, it cannot point to any other data. A new tvbuff must be created if\n you want a tvbuff that points to other data.\n\n tvbuff's are normally chained together to allow efficient de-allocation of\n tvbuff's."]
pub type tvbuff_free_cb_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Extracts 'number of bits' starting at 'bit offset'.\n Returns a pointer to a newly initialized g_malloc'd REAL_DATA\n tvbuff with the bits octet aligned.\n Bits are counted from MSB (0) to LSB (7) within octets."]
    pub fn tvb_new_octet_aligned(
        tvb: *mut tvbuff_t,
        bit_offset: guint32,
        no_of_bits: gint32,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Extracts 'number of bits' starting at 'bit offset'.\n Bits are counted from LSB (0) to MSB (7) within octets."]
    pub fn tvb_new_octet_right_aligned(
        tvb: *mut tvbuff_t,
        bit_offset: guint32,
        no_of_bits: gint32,
    ) -> *mut tvbuff_t;
}
extern "C" {
    pub fn tvb_new_chain(parent: *mut tvbuff_t, backing: *mut tvbuff_t) -> *mut tvbuff_t;
}
extern "C" {
    pub fn tvb_clone(tvb: *mut tvbuff_t) -> *mut tvbuff_t;
}
extern "C" {
    pub fn tvb_clone_offset_len(tvb: *mut tvbuff_t, offset: guint, len: guint) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Free a tvbuff_t and all tvbuffs chained from it\n The tvbuff must be 'the 'head' (initial) tvb of a chain or\n must not be in a chain.\n If specified, a callback to free the tvbuff data will be invoked\n for each tvbuff free'd"]
    pub fn tvb_free(tvb: *mut tvbuff_t);
}
extern "C" {
    #[doc = " Free the tvbuff_t and all tvbuffs chained from it.\n The tvbuff must be 'the 'head' (initial) tvb of a chain or\n must not be in a chain.\n If specified, a callback to free the tvbuff data will be invoked\n for each tvbuff free'd"]
    pub fn tvb_free_chain(tvb: *mut tvbuff_t);
}
extern "C" {
    #[doc = " Set a callback function to call when a tvbuff is actually freed\n One argument is passed to that callback --- a void* that points\n to the real data. Obviously, this only applies to a\n \"real\" tvbuff."]
    pub fn tvb_set_free_cb(tvb: *mut tvbuff_t, func: tvbuff_free_cb_t);
}
extern "C" {
    #[doc = " Attach a \"real\" tvbuff to a parent tvbuff. This connection is used\n during a tvb_free_chain()... the \"child\" \"real\" tvbuff acts as if it\n is part of the chain-of-creation of the parent tvbuff, although it\n isn't. This is useful if you need to take the data from some tvbuff,\n run some operation on it, like decryption or decompression, and make\n a new tvbuff from it, yet want the new tvbuff to be part of the chain.\n The reality is that the new tvbuff *is* part of the \"chain of creation\",\n but in a way that these tvbuff routines are ignorant of. Use this\n function to make the tvbuff routines knowledgable of this fact."]
    pub fn tvb_set_child_real_data_tvbuff(parent: *mut tvbuff_t, child: *mut tvbuff_t);
}
extern "C" {
    pub fn tvb_new_child_real_data(
        parent: *mut tvbuff_t,
        data: *const guint8,
        length: guint,
        reported_length: gint,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Create a tvbuff backed by existing data. Can throw ReportedBoundsError.\n Normally, a callback to free the data should be registered using\n tvb_set_free_cb(); when this tvbuff is freed, then your callback will be\n called, and at that time you can free your original data."]
    pub fn tvb_new_real_data(
        data: *const guint8,
        length: guint,
        reported_length: gint,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Create a tvbuff that's a subset of another tvbuff, with the captured\n length explicitly given. You probably want tvb_new_subset_length() or\n tvb_new_subset_remaining() instead.\n\n @param backing The backing tvbuff onto which the new tvbuff is a view\n @param backing_offset If positive, is the offset from the beginning of\n the backing tvbuff at which the new tvbuff's data begins, and, if\n negative, is the offset from the end of the backing tvbuff at which\n the new tvbuff's data begins.\n @param backing_length The length of the data to include in the new\n tvbuff, starting with the byte at 'backing_offset'; if -1, it\n means \"to the end of the backing tvbuff\".  It can be 0, although\n the usefulness of the buffer would be rather limited.  The length\n actually included will be no more than the reported length.\n @param reported_length The reported length of the new tvbuff; if -1, it\n means \"the reported length to the end of the backing tvbuff\".  It can\n be 0, although the usefulness of the buffer would be rather limited.\n\n @return A tvbuff that is a subset of the backing tvbuff beginning at\n backing_offset (which is offset 0 in the subset) and with the given\n reported_length, with captured length no more than backing_length.\n\n @note In most cases use tvb_new_subset_length() (or equivalently, pass -1\n as 'backing_length') or tvb_new_subset_remaining() instead.  Use this when\n the backing tvbuff includes bytes at the end that must not be included in\n the subset regardless of the reported length, such as an FCS or padding.\n In such cases it may still be simpler to call tvb_new_subset_length()\n twice, once to remove the trailing bytes and once to select the chosen\n payload bytes.\n\n @warning Will throw BoundsError if 'backing_offset'/'length'\n is beyond the bounds of the backing tvbuff.\n Can throw ReportedBoundsError."]
    pub fn tvb_new_subset_length_caplen(
        backing: *mut tvbuff_t,
        backing_offset: gint,
        backing_length: gint,
        reported_length: gint,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Similar to tvb_new_subset_length_caplen() but with captured length calculated\n to fit within the existing captured length and the specified\n reported length.\n Can throw ReportedBoundsError."]
    pub fn tvb_new_subset_length(
        backing: *mut tvbuff_t,
        backing_offset: gint,
        reported_length: gint,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Similar to tvb_new_subset_length_caplen() but with backing_length and reported_length set\n to -1.  Can throw ReportedBoundsError."]
    pub fn tvb_new_subset_remaining(backing: *mut tvbuff_t, backing_offset: gint) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Append to the list of tvbuffs that make up this composite tvbuff"]
    pub fn tvb_composite_append(tvb: *mut tvbuff_t, member: *mut tvbuff_t);
}
extern "C" {
    #[doc = " Prepend to the list of tvbuffs that make up this composite tvbuff"]
    pub fn tvb_composite_prepend(tvb: *mut tvbuff_t, member: *mut tvbuff_t);
}
extern "C" {
    #[doc = " Create an empty composite tvbuff."]
    pub fn tvb_new_composite() -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Mark a composite tvbuff as initialized. No further appends or prepends\n occur, data access can finally happen after this finalization."]
    pub fn tvb_composite_finalize(tvb: *mut tvbuff_t);
}
extern "C" {
    pub fn tvb_captured_length(tvb: *const tvbuff_t) -> guint;
}
extern "C" {
    #[doc = " Computes bytes to end of buffer, from offset (which can be negative,\n to indicate bytes from end of buffer). Function returns 0 if offset is\n either at the end of the buffer or out of bounds. No exception is thrown.\n You probably want tvb_reported_length_remaining instead."]
    pub fn tvb_captured_length_remaining(tvb: *const tvbuff_t, offset: gint) -> gint;
}
extern "C" {
    #[doc = " Same as above, but throws an exception if the offset is out of bounds."]
    pub fn tvb_ensure_captured_length_remaining(tvb: *const tvbuff_t, offset: gint) -> guint;
}
extern "C" {
    pub fn tvb_bytes_exist(tvb: *const tvbuff_t, offset: gint, length: gint) -> gboolean;
}
extern "C" {
    #[doc = " Checks that the bytes referred to by 'offset'/'length', where 'length'\n is a 64-bit unsigned integer, actually exist in the buffer, and throws\n an exception if they aren't."]
    pub fn tvb_ensure_bytes_exist64(tvb: *const tvbuff_t, offset: gint, length: guint64);
}
extern "C" {
    #[doc = " Checks that the bytes referred to by 'offset'/'length' actually exist\n in the buffer, and throws an exception if they aren't."]
    pub fn tvb_ensure_bytes_exist(tvb: *const tvbuff_t, offset: gint, length: gint);
}
extern "C" {
    pub fn tvb_offset_exists(tvb: *const tvbuff_t, offset: gint) -> gboolean;
}
extern "C" {
    pub fn tvb_reported_length(tvb: *const tvbuff_t) -> guint;
}
extern "C" {
    #[doc = " Computes bytes of reported packet data to end of buffer, from offset\n (which can be negative, to indicate bytes from end of buffer). Function\n returns 0 if offset is either at the end of the buffer or out of bounds.\n No exception is thrown."]
    pub fn tvb_reported_length_remaining(tvb: *const tvbuff_t, offset: gint) -> gint;
}
extern "C" {
    #[doc = " Same as above, but throws an exception if the offset is out of bounds."]
    pub fn tvb_ensure_reported_length_remaining(tvb: *const tvbuff_t, offset: gint) -> guint;
}
extern "C" {
    #[doc = " Set the reported length of a tvbuff to a given value; used for protocols\nwhose headers contain an explicit length and where the calling\ndissector's payload may include padding as well as the packet for\nthis protocol.\n\nAlso adjusts the available and contained length."]
    pub fn tvb_set_reported_length(tvb: *mut tvbuff_t, arg1: guint);
}
extern "C" {
    pub fn tvb_fix_reported_length(tvb: *mut tvbuff_t);
}
extern "C" {
    pub fn tvb_offset_from_real_beginning(tvb: *const tvbuff_t) -> guint;
}
extern "C" {
    pub fn tvb_raw_offset(tvb: *mut tvbuff_t) -> gint;
}
extern "C" {
    #[doc = " Set the \"this is a fragment\" flag. This affects whether\n FragmentBoundsError is thrown instead of ContainedBoundsError\n or ReportedBoundsError."]
    pub fn tvb_set_fragment(tvb: *mut tvbuff_t);
}
extern "C" {
    pub fn tvb_get_ds_tvb(tvb: *mut tvbuff_t) -> *mut tvbuff;
}
extern "C" {
    #[doc = " START OF ACCESSORS"]
    pub fn tvb_get_guint8(tvb: *mut tvbuff_t, offset: gint) -> guint8;
}
extern "C" {
    pub fn tvb_get_gint8(tvb: *mut tvbuff_t, offset: gint) -> gint8;
}
extern "C" {
    pub fn tvb_get_ntohs(tvb: *mut tvbuff_t, offset: gint) -> guint16;
}
extern "C" {
    pub fn tvb_get_ntohis(tvb: *mut tvbuff_t, offset: gint) -> gint16;
}
extern "C" {
    pub fn tvb_get_ntoh24(tvb: *mut tvbuff_t, offset: gint) -> guint32;
}
extern "C" {
    pub fn tvb_get_ntohi24(tvb: *mut tvbuff_t, offset: gint) -> gint32;
}
extern "C" {
    pub fn tvb_get_ntohl(tvb: *mut tvbuff_t, offset: gint) -> guint32;
}
extern "C" {
    pub fn tvb_get_ntohil(tvb: *mut tvbuff_t, offset: gint) -> gint32;
}
extern "C" {
    pub fn tvb_get_ntoh40(tvb: *mut tvbuff_t, offset: gint) -> guint64;
}
extern "C" {
    pub fn tvb_get_ntohi40(tvb: *mut tvbuff_t, offset: gint) -> gint64;
}
extern "C" {
    pub fn tvb_get_ntoh48(tvb: *mut tvbuff_t, offset: gint) -> guint64;
}
extern "C" {
    pub fn tvb_get_ntohi48(tvb: *mut tvbuff_t, offset: gint) -> gint64;
}
extern "C" {
    pub fn tvb_get_ntoh56(tvb: *mut tvbuff_t, offset: gint) -> guint64;
}
extern "C" {
    pub fn tvb_get_ntohi56(tvb: *mut tvbuff_t, offset: gint) -> gint64;
}
extern "C" {
    pub fn tvb_get_ntoh64(tvb: *mut tvbuff_t, offset: gint) -> guint64;
}
extern "C" {
    pub fn tvb_get_ntohi64(tvb: *mut tvbuff_t, offset: gint) -> gint64;
}
extern "C" {
    pub fn tvb_get_ntohieee_float(tvb: *mut tvbuff_t, offset: gint) -> gfloat;
}
extern "C" {
    pub fn tvb_get_ntohieee_double(tvb: *mut tvbuff_t, offset: gint) -> gdouble;
}
extern "C" {
    pub fn tvb_get_letohs(tvb: *mut tvbuff_t, offset: gint) -> guint16;
}
extern "C" {
    pub fn tvb_get_letohis(tvb: *mut tvbuff_t, offset: gint) -> gint16;
}
extern "C" {
    pub fn tvb_get_letoh24(tvb: *mut tvbuff_t, offset: gint) -> guint32;
}
extern "C" {
    pub fn tvb_get_letohi24(tvb: *mut tvbuff_t, offset: gint) -> gint32;
}
extern "C" {
    pub fn tvb_get_letohl(tvb: *mut tvbuff_t, offset: gint) -> guint32;
}
extern "C" {
    pub fn tvb_get_letohil(tvb: *mut tvbuff_t, offset: gint) -> gint32;
}
extern "C" {
    pub fn tvb_get_letoh40(tvb: *mut tvbuff_t, offset: gint) -> guint64;
}
extern "C" {
    pub fn tvb_get_letohi40(tvb: *mut tvbuff_t, offset: gint) -> gint64;
}
extern "C" {
    pub fn tvb_get_letoh48(tvb: *mut tvbuff_t, offset: gint) -> guint64;
}
extern "C" {
    pub fn tvb_get_letohi48(tvb: *mut tvbuff_t, offset: gint) -> gint64;
}
extern "C" {
    pub fn tvb_get_letoh56(tvb: *mut tvbuff_t, offset: gint) -> guint64;
}
extern "C" {
    pub fn tvb_get_letohi56(tvb: *mut tvbuff_t, offset: gint) -> gint64;
}
extern "C" {
    pub fn tvb_get_letoh64(tvb: *mut tvbuff_t, offset: gint) -> guint64;
}
extern "C" {
    pub fn tvb_get_letohi64(tvb: *mut tvbuff_t, offset: gint) -> gint64;
}
extern "C" {
    pub fn tvb_get_letohieee_float(tvb: *mut tvbuff_t, offset: gint) -> gfloat;
}
extern "C" {
    pub fn tvb_get_letohieee_double(tvb: *mut tvbuff_t, offset: gint) -> gdouble;
}
extern "C" {
    pub fn tvb_get_guint16(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> guint16;
}
extern "C" {
    pub fn tvb_get_gint16(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> gint16;
}
extern "C" {
    pub fn tvb_get_guint24(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> guint32;
}
extern "C" {
    pub fn tvb_get_gint24(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> gint32;
}
extern "C" {
    pub fn tvb_get_guint32(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> guint32;
}
extern "C" {
    pub fn tvb_get_gint32(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> gint32;
}
extern "C" {
    pub fn tvb_get_guint40(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> guint64;
}
extern "C" {
    pub fn tvb_get_gint40(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> gint64;
}
extern "C" {
    pub fn tvb_get_guint48(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> guint64;
}
extern "C" {
    pub fn tvb_get_gint48(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> gint64;
}
extern "C" {
    pub fn tvb_get_guint56(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> guint64;
}
extern "C" {
    pub fn tvb_get_gint56(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> gint64;
}
extern "C" {
    pub fn tvb_get_guint64(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> guint64;
}
extern "C" {
    pub fn tvb_get_gint64(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> gint64;
}
extern "C" {
    pub fn tvb_get_ieee_float(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> gfloat;
}
extern "C" {
    pub fn tvb_get_ieee_double(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> gdouble;
}
extern "C" {
    pub fn tvb_get_string_time(
        tvb: *mut tvbuff_t,
        offset: gint,
        length: gint,
        encoding: guint,
        ns: *mut nstime_t,
        endoff: *mut gint,
    ) -> *mut nstime_t;
}
extern "C" {
    pub fn tvb_get_string_bytes(
        tvb: *mut tvbuff_t,
        offset: gint,
        length: gint,
        encoding: guint,
        bytes: *mut GByteArray,
        endoff: *mut gint,
    ) -> *mut GByteArray;
}
extern "C" {
    #[doc = " Fetch an IPv4 address, in network byte order.\n We do *not* convert it to host byte order; we leave it in\n network byte order, as that's what its callers expect."]
    pub fn tvb_get_ipv4(tvb: *mut tvbuff_t, offset: gint) -> guint32;
}
extern "C" {
    pub fn tvb_get_ipv6(tvb: *mut tvbuff_t, offset: gint, addr: *mut ws_in6_addr);
}
extern "C" {
    pub fn tvb_get_ntohguid(tvb: *mut tvbuff_t, offset: gint, guid: *mut e_guid_t);
}
extern "C" {
    pub fn tvb_get_letohguid(tvb: *mut tvbuff_t, offset: gint, guid: *mut e_guid_t);
}
extern "C" {
    pub fn tvb_get_guid(tvb: *mut tvbuff_t, offset: gint, guid: *mut e_guid_t, encoding: guint);
}
extern "C" {
    pub fn tvb_get_bits_array(
        scope: *mut wmem_allocator_t,
        tvb: *mut tvbuff_t,
        offset: gint,
        length: usize,
        data_length: *mut usize,
        encoding: guint,
    ) -> *mut guint8;
}
extern "C" {
    pub fn tvb_get_bits8(tvb: *mut tvbuff_t, bit_offset: guint, no_of_bits: gint) -> guint8;
}
extern "C" {
    pub fn tvb_get_bits16(
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        encoding: guint,
    ) -> guint16;
}
extern "C" {
    pub fn tvb_get_bits32(
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        encoding: guint,
    ) -> guint32;
}
extern "C" {
    pub fn tvb_get_bits64(
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        encoding: guint,
    ) -> guint64;
}
extern "C" {
    #[doc = "  This function has EXACTLY the same behavior as\n  tvb_get_bits32()"]
    pub fn tvb_get_bits(
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        encoding: guint,
    ) -> guint32;
}
extern "C" {
    #[doc = " Returns target for convenience. Does not suffer from possible\n expense of tvb_get_ptr(), since this routine is smart enough\n to copy data in chunks if the request range actually exists in\n different \"real\" tvbuffs. This function assumes that the target\n memory is already allocated; it does not allocate or free the\n target memory."]
    pub fn tvb_memcpy(
        tvb: *mut tvbuff_t,
        target: *mut ::std::os::raw::c_void,
        offset: gint,
        length: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Given an allocator scope, a tvbuff, a byte offset, a byte length:\n\n    allocate a buffer using the specified scope;\n\n    copy the data from the tvbuff specified by the offset and length\n    into that buffer, using tvb_memcpy();\n\n    and return a pointer to the buffer.\n\n Throws an exception if the tvbuff ends before the data being copied does.\n\n If scope is set to NULL it is the user's responsibility to wmem_free()\n the memory allocated. Otherwise memory is automatically freed when the\n scope lifetime is reached."]
    pub fn tvb_memdup(
        scope: *mut wmem_allocator_t,
        tvb: *mut tvbuff_t,
        offset: gint,
        length: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " WARNING! This function is possibly expensive, temporarily allocating\n another copy of the packet data. Furthermore, it's dangerous because once\n this pointer is given to the user, there's no guarantee that the user will\n honor the 'length' and not overstep the boundaries of the buffer.\n\n If you're thinking of using tvb_get_ptr, STOP WHAT YOU ARE DOING\n IMMEDIATELY. Go take a break. Consider that tvb_get_ptr hands you\n a raw, unprotected pointer that you can easily use to create a\n security vulnerability or otherwise crash Wireshark. Then consider\n that you can probably find a function elsewhere in this file that\n does exactly what you want in a much more safe and robust manner.\n\n The returned pointer is data that is internal to the tvbuff, so do not\n attempt to free it. Don't modify the data, either, because another tvbuff\n that might be using this tvbuff may have already copied that portion of\n the data (sometimes tvbuff's need to make copies of data, but that's the\n internal implementation that you need not worry about). Assume that the\n guint8* points to read-only data that the tvbuff manages.\n\n Return a pointer into our buffer if the data asked for via 'offset'/'length'\n is contiguous (which might not be the case for a \"composite\" tvbuff). If the\n data is not contiguous, a tvb_memdup() is called for the entire buffer\n and the pointer to the newly-contiguous data is returned. This dynamically-\n allocated memory will be freed when the tvbuff is freed, after the\n tvbuff_free_cb_t() is called, if any."]
    pub fn tvb_get_ptr(tvb: *mut tvbuff_t, offset: gint, length: gint) -> *const guint8;
}
extern "C" {
    #[doc = " Find first occurrence of needle in tvbuff, starting at offset. Searches\n at most maxlength number of bytes; if maxlength is -1, searches to\n end of tvbuff.\n Returns the offset of the found needle, or -1 if not found.\n Will not throw an exception, even if maxlength exceeds boundary of tvbuff;\n in that case, -1 will be returned if the boundary is reached before\n finding needle."]
    pub fn tvb_find_guint8(
        tvb: *mut tvbuff_t,
        offset: gint,
        maxlength: gint,
        needle: guint8,
    ) -> gint;
}
extern "C" {
    #[doc = " Same as tvb_find_guint8() with 16bit needle."]
    pub fn tvb_find_guint16(
        tvb: *mut tvbuff_t,
        offset: gint,
        maxlength: gint,
        needle: guint16,
    ) -> gint;
}
extern "C" {
    #[doc = " Find first occurrence of any of the needles of the pre-compiled pattern in\n tvbuff, starting at offset. The passed in pattern must have been \"compiled\"\n before-hand, using ws_mempbrk_compile().\n Searches at most maxlength number of bytes. Returns the offset of the\n found needle, or -1 if not found and the found needle.\n Will not throw an exception, even if\n maxlength exceeds boundary of tvbuff; in that case, -1 will be returned if\n the boundary is reached before finding needle."]
    pub fn tvb_ws_mempbrk_pattern_guint8(
        tvb: *mut tvbuff_t,
        offset: gint,
        maxlength: gint,
        pattern: *const ws_mempbrk_pattern,
        found_needle: *mut guchar,
    ) -> gint;
}
extern "C" {
    #[doc = " Find size of stringz (NUL-terminated string) by looking for terminating\n NUL.  The size of the string includes the terminating NUL.\n\n If the NUL isn't found, it throws the appropriate exception."]
    pub fn tvb_strsize(tvb: *mut tvbuff_t, offset: gint) -> guint;
}
extern "C" {
    #[doc = " Find size of UCS-2 or UTF-16 stringz (NUL-terminated string) by\n looking for terminating 16-bit NUL.  The size of the string includes\n the terminating NUL.\n\n If the NUL isn't found, it throws the appropriate exception."]
    pub fn tvb_unicode_strsize(tvb: *mut tvbuff_t, offset: gint) -> guint;
}
extern "C" {
    #[doc = " Find length of string by looking for end of zero terminated string, up to\n 'maxlength' characters'; if 'maxlength' is -1, searches to end\n of tvbuff.\n Returns -1 if 'maxlength' reached before finding EOS."]
    pub fn tvb_strnlen(tvb: *mut tvbuff_t, offset: gint, maxlength: guint) -> gint;
}
extern "C" {
    #[doc = " Format the data in the tvb from offset for size."]
    pub fn tvb_format_text(
        scope: *mut wmem_allocator_t,
        tvb: *mut tvbuff_t,
        offset: gint,
        size: gint,
    ) -> *mut gchar;
}
extern "C" {
    #[doc = " Like \"tvb_format_text()\", but for 'wsp'; don't show\n the characters as C-style escapes."]
    pub fn tvb_format_text_wsp(
        allocator: *mut wmem_allocator_t,
        tvb: *mut tvbuff_t,
        offset: gint,
        size: gint,
    ) -> *mut gchar;
}
extern "C" {
    #[doc = " Like \"tvb_format_text()\", but for null-padded strings; don't show\n the null padding characters as \"\\000\"."]
    pub fn tvb_format_stringzpad(
        scope: *mut wmem_allocator_t,
        tvb: *mut tvbuff_t,
        offset: gint,
        size: gint,
    ) -> *mut gchar;
}
extern "C" {
    #[doc = " Like \"tvb_format_text_wsp()\", but for null-padded strings; don't show\n the null padding characters as \"\\000\"."]
    pub fn tvb_format_stringzpad_wsp(
        allocator: *mut wmem_allocator_t,
        tvb: *mut tvbuff_t,
        offset: gint,
        size: gint,
    ) -> *mut gchar;
}
extern "C" {
    #[doc = " Given an allocator scope, a tvbuff, a byte offset, a byte length, and\n a string encoding, with the specified offset and length referring to\n a string in the specified encoding:\n\n    allocate a buffer using the specified scope;\n\n    convert the string from the specified encoding to UTF-8, possibly\n    mapping some characters or invalid octet sequences to the Unicode\n    REPLACEMENT CHARACTER, and put the resulting UTF-8 string, plus a\n    trailing '\\0', into that buffer;\n\n    and return a pointer to the buffer.\n\n Throws an exception if the tvbuff ends before the string does.\n\n If scope is set to NULL it is the user's responsibility to wmem_free()\n the memory allocated. Otherwise memory is automatically freed when the\n scope lifetime is reached."]
    pub fn tvb_get_string_enc(
        scope: *mut wmem_allocator_t,
        tvb: *mut tvbuff_t,
        offset: gint,
        length: gint,
        encoding: guint,
    ) -> *mut guint8;
}
extern "C" {
    #[doc = " Given an allocator scope, a tvbuff, a bit offset, and a length in\n 7-bit characters (not octets!), with the specified offset and\n length referring to a string in the 3GPP TS 23.038 7bits encoding,\n with code points packed into 7 bits:\n\n    allocate a buffer using the specified scope;\n\n    convert the string from the specified encoding to UTF-8, possibly\n    mapping some characters or invalid octet sequences to the Unicode\n    REPLACEMENT CHARACTER, and put the resulting UTF-8 string, plus a\n    trailing '\\0', into that buffer;\n\n    and return a pointer to the buffer.\n\n Throws an exception if the tvbuff ends before the string does.\n\n If scope is set to NULL it is the user's responsibility to wmem_free()\n the memory allocated. Otherwise memory is automatically freed when the\n scope lifetime is reached."]
    pub fn tvb_get_ts_23_038_7bits_string_packed(
        scope: *mut wmem_allocator_t,
        tvb: *mut tvbuff_t,
        bit_offset: gint,
        no_of_chars: gint,
    ) -> *mut gchar;
}
extern "C" {
    #[doc = " Given an allocator scope, a tvbuff, an offset, and a length in\n octets with the specified offset and length referring to a string\n in the 3GPP TS 23.038 7bits encoding, with one octet per code poiint\n (the 8th bit of each octet should be 0; if not, the octet is invalid):\n\n    allocate a buffer using the specified scope;\n\n    convert the string from the specified encoding to UTF-8, possibly\n    mapping some characters or invalid octet sequences to the Unicode\n    REPLACEMENT CHARACTER, and put the resulting UTF-8 string, plus a\n    trailing '\\0', into that buffer;\n\n    and return a pointer to the buffer.\n\n Throws an exception if the tvbuff ends before the string does.\n\n If scope is set to NULL it is the user's responsibility to wmem_free()\n the memory allocated. Otherwise memory is automatically freed when the\n scope lifetime is reached."]
    pub fn tvb_get_ts_23_038_7bits_string_unpacked(
        scope: *mut wmem_allocator_t,
        tvb: *mut tvbuff_t,
        offset: gint,
        length: gint,
    ) -> *mut gchar;
}
extern "C" {
    #[doc = " Given an allocator scope, a tvbuff, an offset, and a length in\n octets with the specified offset and length referring to a string\n in the ETSI TS 102 221 Annex A encodings; if not:\n\n    allocate a buffer using the specified scope;\n\n    convert the string from the specified encoding to UTF-8, possibly\n    mapping some characters or invalid octet sequences to the Unicode\n    REPLACEMENT CHARACTER, and put the resulting UTF-8 string, plus a\n    trailing '\\0', into that buffer;\n\n    and return a pointer to the buffer.\n\n Throws an exception if the tvbuff ends before the string does.\n\n If scope is set to NULL it is the user's responsibility to wmem_free()\n the memory allocated. Otherwise memory is automatically freed when the\n scope lifetime is reached."]
    pub fn tvb_get_etsi_ts_102_221_annex_a_string(
        scope: *mut wmem_allocator_t,
        tvb: *mut tvbuff_t,
        offset: gint,
        length: gint,
    ) -> *mut gchar;
}
extern "C" {
    #[doc = " Given an allocator scope, a tvbuff, an offset, and a length in\n 7-bit characters (not octets!), with the specified offset and\n length referring to a string in the ASCII 7bits encoding:\n\n    allocate a buffer using the specified scope;\n\n    convert the string from the specified encoding to UTF-8, possibly\n    mapping some characters or invalid octet sequences to the Unicode\n    REPLACEMENT CHARACTER, and put the resulting UTF-8 string, plus a\n    trailing '\\0', into that buffer;\n\n    and return a pointer to the buffer.\n\n Throws an exception if the tvbuff ends before the string does.\n\n If scope is set to NULL it is the user's responsibility to wmem_free()\n the memory allocated. Otherwise memory is automatically freed when the\n scope lifetime is reached."]
    pub fn tvb_get_ascii_7bits_string(
        scope: *mut wmem_allocator_t,
        tvb: *mut tvbuff_t,
        bit_offset: gint,
        no_of_chars: gint,
    ) -> *mut gchar;
}
extern "C" {
    #[doc = " Given an allocator scope, a tvbuff, a byte offset, a byte length, and\n a string encoding, with the specified offset and length referring to\n a null-padded string in the specified encoding:\n\n    allocate a buffer using the specified scope;\n\n    convert the string from the specified encoding to UTF-8, possibly\n    mapping some characters or invalid octet sequences to the Unicode\n    REPLACEMENT CHARACTER, and put the resulting UTF-8 string, plus a\n    trailing '\\0', into that buffer;\n\n    and return a pointer to the buffer.\n\n Throws an exception if the tvbuff ends before the string does.\n\n If scope is set to NULL it is the user's responsibility to wmem_free()\n the memory allocated. Otherwise memory is automatically freed when the\n scope lifetime is reached."]
    pub fn tvb_get_stringzpad(
        scope: *mut wmem_allocator_t,
        tvb: *mut tvbuff_t,
        offset: gint,
        length: gint,
        encoding: guint,
    ) -> *mut guint8;
}
extern "C" {
    #[doc = " Given an allocator scope, a tvbuff, a byte offset, a pointer to a\n gint, and a string encoding, with the specified offset referring to\n a null-terminated string in the specified encoding:\n\n    find the length of that string (and throw an exception if the tvbuff\n    ends before we find the null);\n\n    allocate a buffer using the specified scope;\n\n    convert the string from the specified encoding to UTF-8, possibly\n    mapping some characters or invalid octet sequences to the Unicode\n    REPLACEMENT CHARACTER, and put the resulting UTF-8 string, plus a\n    trailing '\\0', into that buffer;\n\n    if the pointer to the gint is non-null, set the gint to which it\n    points to the length of the string;\n\n    and return a pointer to the buffer.\n\n Throws an exception if the tvbuff ends before the string does.\n\n If scope is set to NULL it is the user's responsibility to wmem_free()\n the memory allocated. Otherwise memory is automatically freed when the\n scope lifetime is reached."]
    pub fn tvb_get_stringz_enc(
        scope: *mut wmem_allocator_t,
        tvb: *mut tvbuff_t,
        offset: gint,
        lengthp: *mut gint,
        encoding: guint,
    ) -> *mut guint8;
}
extern "C" {
    #[doc = " Given a tvbuff and an offset, with the offset assumed to refer to\n a null-terminated string, find the length of that string (and throw\n an exception if the tvbuff ends before we find the null), allocate\n a buffer big enough to hold the string, copy the string into it,\n and return a pointer to the string.  Also return the length of the\n string (including the terminating null) through a pointer.\n\n This returns a constant (unmodifiable) string that does not need\n to be freed; instead, it will automatically be freed once the next\n packet is dissected.\n\n It is slightly more efficient than the other routines, but does *NOT*\n do any translation to UTF-8 - the string consists of the raw octets\n of the string, in whatever encoding they happen to be in, and, if\n the string is not valid in that encoding, with invalid octet sequences\n as they are in the packet.\n\n This function is deprecated because it does no validation of the string\n encoding. Do not use in new code. Prefer other APIs such as:\n \ttvb_get_stringz_enc()\n \tproto_tree_add_item_ret_string_and_length()\n \ttvb_strsize() and validate the pointed to memory region manually."]
    pub fn tvb_get_const_stringz(
        tvb: *mut tvbuff_t,
        offset: gint,
        lengthp: *mut gint,
    ) -> *const guint8;
}
extern "C" {
    #[doc = " Looks for a NUL byte in tvbuff and copies\n no more than bufsize number of bytes, including terminating NUL, to buffer.\n Returns number of bytes copied (not including terminating NUL).\n\n When processing a packet where the remaining number of bytes is less\n than bufsize, an exception is not thrown if the end of the packet\n is reached before the NUL is found. The byte buffer is guaranteed to\n have a terminating NUL."]
    pub fn tvb_get_raw_bytes_as_stringz(
        tvb: *mut tvbuff_t,
        offset: gint,
        bufsize: guint,
        buffer: *mut guint8,
    ) -> gint;
}
extern "C" {
    pub fn tvb_get_raw_bytes_as_string(
        tvb: *mut tvbuff_t,
        offset: gint,
        buffer: *mut ::std::os::raw::c_char,
        bufsize: usize,
    ) -> gint;
}
extern "C" {
    #[doc = " Iterates over the provided portion of the tvb checking that each byte\n is an ascii printable character.\n Returns TRUE if all bytes are printable, FALSE otherwise"]
    pub fn tvb_ascii_isprint(tvb: *mut tvbuff_t, offset: gint, length: gint) -> gboolean;
}
extern "C" {
    #[doc = " Iterates over the provided portion of the tvb checking that it is\n valid UTF-8 consisting entirely of printable characters. (The characters\n must be complete; if the portion ends in a partial sequence that could\n begin a valid character, this returns FALSE.) The length may be -1 for\n \"all the way to the end of the tvbuff\".\n Returns TRUE if printable, FALSE otherwise\n\n @see isprint_utf8_string()"]
    pub fn tvb_utf_8_isprint(tvb: *mut tvbuff_t, offset: gint, length: gint) -> gboolean;
}
extern "C" {
    #[doc = " Iterates over the provided portion of the tvb checking that each byte\n is an ascii digit.\n Returns TRUE if all bytes are digits, FALSE otherwise"]
    pub fn tvb_ascii_isdigit(tvb: *mut tvbuff_t, offset: gint, length: gint) -> gboolean;
}
extern "C" {
    #[doc = " Given a tvbuff, an offset into the tvbuff, and a length that starts\n at that offset (which may be -1 for \"all the way to the end of the\n tvbuff\"), find the end of the (putative) line that starts at the\n specified offset in the tvbuff, going no further than the specified\n length.\n\n Return the length of the line (not counting the line terminator at\n the end), or, if we don't find a line terminator:\n\n  if \"deseg\" is true, return -1;\n\n  if \"deseg\" is false, return the amount of data remaining in\n  the buffer.\n\n If \"next_offset\" is not NULL, set \"*next_offset\" to the offset of the\n character past the line terminator, or past the end of the buffer if\n we don't find a line terminator.  (It's not set if we return -1.)"]
    pub fn tvb_find_line_end(
        tvb: *mut tvbuff_t,
        offset: gint,
        len: ::std::os::raw::c_int,
        next_offset: *mut gint,
        desegment: gboolean,
    ) -> gint;
}
extern "C" {
    #[doc = " Given a tvbuff, an offset into the tvbuff, and a length that starts\n at that offset (which may be -1 for \"all the way to the end of the\n tvbuff\"), find the end of the (putative) line that starts at the\n specified offset in the tvbuff, going no further than the specified\n length.\n\n However, treat quoted strings inside the buffer specially - don't\n treat newlines in quoted strings as line terminators.\n\n Return the length of the line (not counting the line terminator at\n the end), or the amount of data remaining in the buffer if we don't\n find a line terminator.\n\n If \"next_offset\" is not NULL, set \"*next_offset\" to the offset of the\n character past the line terminator, or past the end of the buffer if\n we don't find a line terminator."]
    pub fn tvb_find_line_end_unquoted(
        tvb: *mut tvbuff_t,
        offset: gint,
        len: ::std::os::raw::c_int,
        next_offset: *mut gint,
    ) -> gint;
}
extern "C" {
    #[doc = " Copied from the mgcp dissector. (This function should be moved to /epan )\n tvb_skip_wsp - Returns the position in tvb of the first non-whitespace\n                character following offset or offset + maxlength -1 whichever\n                is smaller.\n\n Parameters:\n tvb - The tvbuff in which we are skipping whitespace.\n offset - The offset in tvb from which we begin trying to skip whitespace.\n maxlength - The maximum distance from offset that we may try to skip\n whitespace.\n\n Returns: The position in tvb of the first non-whitespace\n          character following offset or offset + maxlength -1 whichever\n          is smaller."]
    pub fn tvb_skip_wsp(tvb: *mut tvbuff_t, offset: gint, maxlength: gint) -> gint;
}
extern "C" {
    pub fn tvb_skip_wsp_return(tvb: *mut tvbuff_t, offset: gint) -> gint;
}
extern "C" {
    pub fn tvb_skip_guint8(
        tvb: *mut tvbuff_t,
        offset: ::std::os::raw::c_int,
        maxlength: ::std::os::raw::c_int,
        ch: guint8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Given a tvbuff, an offset into the tvbuff, and a length that starts\n at that offset (which may be -1 for \"all the way to the end of the\n tvbuff\"), find the end of the token that starts at the\n specified offset in the tvbuff, going no further than the specified\n length.\n\n Return the length of the token, or, if we don't find a terminator:\n\n  if \"deseg\" is true, return -1;\n\n  if \"deseg\" is false, return the amount of data remaining in\n  the buffer.\n\n Set \"*next_offset\" to the offset of the character past the\n terminator, or past the end of the buffer if we don't find a line\n terminator.  (It's not set if we return -1.)"]
    pub fn tvb_get_token_len(
        tvb: *mut tvbuff_t,
        offset: gint,
        len: ::std::os::raw::c_int,
        next_offset: *mut gint,
        desegment: gboolean,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Call strncmp after checking if enough chars left, returning 0 if\n it returns 0 (meaning \"equal\") and -1 otherwise, otherwise return -1."]
    pub fn tvb_strneql(tvb: *mut tvbuff_t, offset: gint, str_: *const gchar, size: usize) -> gint;
}
extern "C" {
    #[doc = " Call g_ascii_strncasecmp after checking if enough chars left, returning\n 0 if it returns 0 (meaning \"equal\") and -1 otherwise, otherwise return -1."]
    pub fn tvb_strncaseeql(
        tvb: *mut tvbuff_t,
        offset: gint,
        str_: *const gchar,
        size: usize,
    ) -> gint;
}
extern "C" {
    #[doc = " Call memcmp after checking if enough chars left, returning 0 if\n it returns 0 (meaning \"equal\") and -1 otherwise, otherwise return -1."]
    pub fn tvb_memeql(tvb: *mut tvbuff_t, offset: gint, str_: *const guint8, size: usize) -> gint;
}
extern "C" {
    #[doc = " Format a bunch of data from a tvbuff as bytes, returning a pointer\n to the string with the formatted data, with \"punct\" as a byte\n separator."]
    pub fn tvb_bytes_to_str_punct(
        scope: *mut wmem_allocator_t,
        tvb: *mut tvbuff_t,
        offset: gint,
        len: gint,
        punct: gchar,
    ) -> *mut gchar;
}
extern "C" {
    #[doc = " Format a bunch of data from a tvbuff as bytes, returning a pointer\n to the string with the formatted data."]
    pub fn tvb_bytes_to_str(
        allocator: *mut wmem_allocator_t,
        tvb: *mut tvbuff_t,
        offset: gint,
        len: gint,
    ) -> *mut gchar;
}
#[doc = " Given a tvbuff, an offset into the tvbuff, and a length that starts\n at that offset (which may be -1 for \"all the way to the end of the\n tvbuff\"), fetch BCD encoded digits from a tvbuff starting from either\n the low or high half byte, formatting the digits according to an input digit\n set, if NUL a default digit set of 0-9 returning \"?\" for overdecadic digits\n will be used.  A pointer to the WMEM-allocated string will\n be returned. Note a tvbuff content of 0xf is considered a 'filler' and will\n end the conversion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dgt_set_t {
    pub out: [::std::os::raw::c_uchar; 16usize],
}
#[test]
fn bindgen_test_layout_dgt_set_t() {
    const UNINIT: ::std::mem::MaybeUninit<dgt_set_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dgt_set_t>(),
        16usize,
        concat!("Size of: ", stringify!(dgt_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<dgt_set_t>(),
        1usize,
        concat!("Alignment of ", stringify!(dgt_set_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dgt_set_t),
            "::",
            stringify!(out)
        )
    );
}
extern "C" {
    pub fn tvb_bcd_dig_to_str(
        scope: *mut wmem_allocator_t,
        tvb: *mut tvbuff_t,
        offset: gint,
        len: gint,
        dgt: *const dgt_set_t,
        skip_first: gboolean,
    ) -> *const gchar;
}
extern "C" {
    #[doc = " Given a tvbuff, an offset into the tvbuff, and a length that starts\n at that offset (which may be -1 for \"all the way to the end of the\n tvbuff\"), fetch BCD encoded digits from a tvbuff starting from either\n the low or high half byte, formatting the digits according to an input digit\n set, if NUL a default digit set of 0-9 returning \"?\" for overdecadic digits\n will be used.  A pointer to the WMEM-allocated string will\n be returned. Note a tvbuff content of 0xf is considered a 'filler' and will\n end the conversion. Function uses big endian convetion: first digit is based\n on high order nibble, second digit is based on low order nibble."]
    pub fn tvb_bcd_dig_to_str_be(
        scope: *mut wmem_allocator_t,
        tvb: *mut tvbuff_t,
        offset: gint,
        len: gint,
        dgt: *const dgt_set_t,
        skip_first: gboolean,
    ) -> *const gchar;
}
extern "C" {
    #[doc = " Given a wmem scope, a tvbuff, an offset, a length, an input digit\n set, and a boolean indicator, fetch BCD-encoded digits from a\n tvbuff starting from either the low or high half byte of the\n first byte depending on the boolean indicator (TRUE means \"start\n with the high half byte, ignoring the low half byte\", and FALSE\n means \"start with the low half byte and proceed to the high half\n byte), formating the digits into characters according to the\n input digit set, and return a pointer to a UTF-8 string, allocated\n using the wmem scope.  A high-order nibble of 0xf is considered a\n 'filler' and will end the conversion. If odd is set the high order\n nibble in the last octet will be skipped. If bigendian is set then\n high order nibble is taken as first digit of a byte and low order\n nibble as second digit."]
    pub fn tvb_get_bcd_string(
        scope: *mut wmem_allocator_t,
        tvb: *mut tvbuff_t,
        offset: gint,
        len: gint,
        dgt: *const dgt_set_t,
        skip_first: gboolean,
        odd: gboolean,
        bigendian: gboolean,
    ) -> *mut gchar;
}
extern "C" {
    #[doc = " Locate a sub-tvbuff within another tvbuff, starting at position\n 'haystack_offset'. Returns the index of the beginning of 'needle' within\n 'haystack', or -1 if 'needle' is not found. The index is relative\n to the start of 'haystack', not 'haystack_offset'."]
    pub fn tvb_find_tvb(
        haystack_tvb: *mut tvbuff_t,
        needle_tvb: *mut tvbuff_t,
        haystack_offset: gint,
    ) -> gint;
}
extern "C" {
    #[doc = " Uncompresses a zlib compressed packet inside a tvbuff at offset with\n length comprlen.  Returns an uncompressed tvbuffer if uncompression\n succeeded or NULL if uncompression failed.\n\n The returned tvbuffer must be freed with `tvb_free` or added to the\n chain of another tvbuffer to avoid a memory leak. Consider using\n tvb_child_uncompress to simplify memory management."]
    pub fn tvb_uncompress(
        tvb: *mut tvbuff_t,
        offset: ::std::os::raw::c_int,
        comprlen: ::std::os::raw::c_int,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Uncompresses a zlib compressed packet inside a tvbuff at offset with\n length comprlen.  Returns an uncompressed tvbuffer attached to parent if\n uncompression succeeded or NULL if uncompression failed."]
    pub fn tvb_child_uncompress(
        parent: *mut tvbuff_t,
        tvb: *mut tvbuff_t,
        offset: ::std::os::raw::c_int,
        comprlen: ::std::os::raw::c_int,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Uncompresses a brotli compressed packet inside a tvbuff at offset with\n length comprlen.  Returns an uncompressed tvbuffer if uncompression\n succeeded or NULL if uncompression failed.\n\n The returned tvbuffer must be freed with `tvb_free` or added to the\n chain of another tvbuffer to avoid a memory leak. Consider using\n tvb_child_uncompress_brotli to simplify memory management."]
    pub fn tvb_uncompress_brotli(
        tvb: *mut tvbuff_t,
        offset: ::std::os::raw::c_int,
        comprlen: ::std::os::raw::c_int,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Uncompresses a brotli compressed packet inside a tvbuff at offset with\n length comprlen.  Returns an uncompressed tvbuffer attached to parent if\n uncompression succeeded or NULL if uncompression failed."]
    pub fn tvb_child_uncompress_brotli(
        parent: *mut tvbuff_t,
        tvb: *mut tvbuff_t,
        offset: ::std::os::raw::c_int,
        comprlen: ::std::os::raw::c_int,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Uncompresses a Microsoft Plain LZ77 compressed payload inside a\n tvbuff at offset with length comprlen.  Returns an uncompressed\n tvbuffer if uncompression succeeded or NULL if uncompression\n failed.\n\n The returned tvbuffer must be freed with `tvb_free` or added to the\n chain of another tvbuffer to avoid a memory leak. Consider using\n tvb_child_uncompress_lz77 to simplify memory management."]
    pub fn tvb_uncompress_lz77(
        tvb: *mut tvbuff_t,
        offset: ::std::os::raw::c_int,
        comprlen: ::std::os::raw::c_int,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Uncompresses a Microsoft Plain LZ77 compressed payload inside a\n tvbuff at offset with length comprlen.  Returns an uncompressed\n tvbuffer attached to parent if uncompression succeeded or NULL if\n uncompression failed."]
    pub fn tvb_child_uncompress_lz77(
        parent: *mut tvbuff_t,
        tvb: *mut tvbuff_t,
        offset: ::std::os::raw::c_int,
        comprlen: ::std::os::raw::c_int,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Uncompresses a Microsoft LZ77+Huffman compressed payload inside a\n tvbuff at offset with length comprlen.  Returns an uncompressed\n tvbuffer if uncompression succeeded or NULL if uncompression\n failed.\n\n The returned tvbuffer must be freed with `tvb_free` or added to the\n chain of another tvbuffer to avoid a memory leak. Consider using\n tvb_child_uncompress_lz77huff to simplify memory management."]
    pub fn tvb_uncompress_lz77huff(
        tvb: *mut tvbuff_t,
        offset: ::std::os::raw::c_int,
        comprlen: ::std::os::raw::c_int,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Uncompresses a Microsoft LZ77+Huffman compressed payload inside a\n tvbuff at offset with length comprlen.  Returns an uncompressed\n tvbuffer attached to parent if uncompression succeeded or NULL if\n uncompression failed."]
    pub fn tvb_child_uncompress_lz77huff(
        parent: *mut tvbuff_t,
        tvb: *mut tvbuff_t,
        offset: ::std::os::raw::c_int,
        comprlen: ::std::os::raw::c_int,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Uncompresses a Microsoft LZNT1 compressed payload inside\n a tvbuff at offset with length comprlen.  Returns an uncompressed\n tvbuffer if uncompression succeeded or NULL if uncompression\n failed.\n\n The returned tvbuffer must be freed with `tvb_free` or added to the\n chain of another tvbuffer to avoid a memory leak. Consider using\n tvb_child_uncompress_lznt1 to simplify memory management."]
    pub fn tvb_uncompress_lznt1(
        tvb: *mut tvbuff_t,
        offset: ::std::os::raw::c_int,
        comprlen: ::std::os::raw::c_int,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Uncompresses a Microsoft LZNT1 compressed payload inside\n a tvbuff at offset with length comprlen.  Returns an uncompressed\n tvbuffer attached to parent if uncompression succeeded or NULL if\n uncompression failed."]
    pub fn tvb_child_uncompress_lznt1(
        parent: *mut tvbuff_t,
        tvb: *mut tvbuff_t,
        offset: ::std::os::raw::c_int,
        comprlen: ::std::os::raw::c_int,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Uncompresses a ZSTD compressed payload inside a\n tvbuff at offset with length comprlen.  Returns an uncompressed\n tvbuffer if uncompression succeeded or NULL if uncompression\n failed.\n\n The returned tvbuffer must be freed with `tvb_free` or added to the\n chain of another tvbuffer to avoid a memory leak. Consider using\n tvb_child_uncompress_zstd to simplify memory management."]
    pub fn tvb_uncompress_zstd(
        tvb: *mut tvbuff_t,
        offset: ::std::os::raw::c_int,
        comprlen: ::std::os::raw::c_int,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Uncompresses a ZSTD compressed payload inside a\n tvbuff at offset with length comprlen.  Returns an uncompressed\n tvbuffer attached to parent if uncompression succeeded or NULL\n if uncompression failed."]
    pub fn tvb_child_uncompress_zstd(
        parent: *mut tvbuff_t,
        tvb: *mut tvbuff_t,
        offset: ::std::os::raw::c_int,
        comprlen: ::std::os::raw::c_int,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Return a tvb that contains the binary representation of a base64\n  string as a child of the indicated tvb.\n\n @param parent The parent tvbuff.\n @param base64 The base64 encoded string which binary representation will be\n               returned in the child tvb.\n\n @return   A tvb with the binary representation of the base64 decoded string."]
    pub fn base64_to_tvb(
        parent: *mut tvbuff_t,
        base64: *const ::std::os::raw::c_char,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Return a tvb that contains the binary representation of a base64\n  encoded string in the parent tvb as a child of the indicated tvb.\n\n @param parent The parent tvbuff.\n @param offset Start of the base64 string in the tvb\n @param length Length of the base64 string in the tvb\n\n @return   A tvb with the binary representation of the base64 decoded string."]
    pub fn base64_tvb_to_new_tvb(
        parent: *mut tvbuff_t,
        offset: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> *mut tvbuff_t;
}
extern "C" {
    pub fn base64uri_tvb_to_new_tvb(
        parent: *mut tvbuff_t,
        offset: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Extract a variable length integer from a tvbuff.\n Each byte in a varint, except the last byte, has the most significant bit (msb)\n set -- this indicates that there are further bytes to come. For example,\n   1010 1100 0000 0010 is 300\n\n @param tvb The tvbuff in which we are extracting integer.\n @param offset The offset in tvb from which we begin trying to extract integer.\n @param maxlen The maximum distance from offset that we may try to extract integer\n @param value  if parsing succeeds, parsed varint will store here.\n @param encoding The ENC_* that defines the format (e.g., ENC_VARINT_PROTOBUF, ENC_VARINT_QUIC, ENC_VARINT_ZIGZAG, ENC_VARINT_SDNV)\n @return   the length of this varint in tvb. 0 means parsing failed."]
    pub fn tvb_get_varint(
        tvb: *mut tvbuff_t,
        offset: guint,
        maxlen: guint,
        value: *mut guint64,
        encoding: guint,
    ) -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _value_string {
    pub value: guint32,
    pub strptr: *const gchar,
}
#[test]
fn bindgen_test_layout__value_string() {
    const UNINIT: ::std::mem::MaybeUninit<_value_string> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_value_string>(),
        16usize,
        concat!("Size of: ", stringify!(_value_string))
    );
    assert_eq!(
        ::std::mem::align_of::<_value_string>(),
        8usize,
        concat!("Alignment of ", stringify!(_value_string))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_value_string),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_value_string),
            "::",
            stringify!(strptr)
        )
    );
}
pub type value_string = _value_string;
extern "C" {
    pub fn val_to_str(
        val: guint32,
        vs: *const value_string,
        fmt: *const ::std::os::raw::c_char,
    ) -> *const gchar;
}
extern "C" {
    pub fn val_to_str_wmem(
        scope: *mut wmem_allocator_t,
        val: guint32,
        vs: *const value_string,
        fmt: *const ::std::os::raw::c_char,
    ) -> *mut gchar;
}
extern "C" {
    pub fn val_to_str_const(
        val: guint32,
        vs: *const value_string,
        unknown_str: *const ::std::os::raw::c_char,
    ) -> *const gchar;
}
extern "C" {
    pub fn try_val_to_str(val: guint32, vs: *const value_string) -> *const gchar;
}
extern "C" {
    pub fn try_val_to_str_idx(
        val: guint32,
        vs: *const value_string,
        idx: *mut gint,
    ) -> *const gchar;
}
extern "C" {
    pub fn char_val_to_str(
        val: ::std::os::raw::c_char,
        vs: *const value_string,
        msg: *const ::std::os::raw::c_char,
    ) -> *const gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _val64_string {
    pub value: guint64,
    pub strptr: *const gchar,
}
#[test]
fn bindgen_test_layout__val64_string() {
    const UNINIT: ::std::mem::MaybeUninit<_val64_string> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_val64_string>(),
        16usize,
        concat!("Size of: ", stringify!(_val64_string))
    );
    assert_eq!(
        ::std::mem::align_of::<_val64_string>(),
        8usize,
        concat!("Alignment of ", stringify!(_val64_string))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_val64_string),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_val64_string),
            "::",
            stringify!(strptr)
        )
    );
}
pub type val64_string = _val64_string;
extern "C" {
    pub fn val64_to_str(
        val: guint64,
        vs: *const val64_string,
        fmt: *const ::std::os::raw::c_char,
    ) -> *const gchar;
}
extern "C" {
    pub fn val64_to_str_const(
        val: guint64,
        vs: *const val64_string,
        unknown_str: *const ::std::os::raw::c_char,
    ) -> *const gchar;
}
extern "C" {
    pub fn try_val64_to_str(val: guint64, vs: *const val64_string) -> *const gchar;
}
extern "C" {
    pub fn try_val64_to_str_idx(
        val: guint64,
        vs: *const val64_string,
        idx: *mut gint,
    ) -> *const gchar;
}
extern "C" {
    pub fn str_to_val(val: *const gchar, vs: *const value_string, err_val: guint32) -> guint32;
}
extern "C" {
    pub fn str_to_val_idx(val: *const gchar, vs: *const value_string) -> gint;
}
pub type value_string_ext = _value_string_ext;
pub type _value_string_match2_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: guint32, arg2: *mut value_string_ext) -> *const value_string,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _value_string_ext {
    pub _vs_match2: _value_string_match2_t,
    pub _vs_first_value: guint32,
    pub _vs_num_entries: guint,
    pub _vs_p: *const value_string,
    pub _vs_name: *const gchar,
}
#[test]
fn bindgen_test_layout__value_string_ext() {
    const UNINIT: ::std::mem::MaybeUninit<_value_string_ext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_value_string_ext>(),
        32usize,
        concat!("Size of: ", stringify!(_value_string_ext))
    );
    assert_eq!(
        ::std::mem::align_of::<_value_string_ext>(),
        8usize,
        concat!("Alignment of ", stringify!(_value_string_ext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vs_match2) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_value_string_ext),
            "::",
            stringify!(_vs_match2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vs_first_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_value_string_ext),
            "::",
            stringify!(_vs_first_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vs_num_entries) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_value_string_ext),
            "::",
            stringify!(_vs_num_entries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vs_p) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_value_string_ext),
            "::",
            stringify!(_vs_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vs_name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_value_string_ext),
            "::",
            stringify!(_vs_name)
        )
    );
}
extern "C" {
    pub fn _try_val_to_str_ext_init(
        val: guint32,
        vse: *mut value_string_ext,
    ) -> *const value_string;
}
extern "C" {
    pub fn value_string_ext_new(
        vs: *const value_string,
        vs_tot_num_entries: guint,
        vs_name: *const gchar,
    ) -> *mut value_string_ext;
}
extern "C" {
    pub fn value_string_ext_free(vse: *mut value_string_ext);
}
extern "C" {
    pub fn val_to_str_ext(
        val: guint32,
        vse: *mut value_string_ext,
        fmt: *const ::std::os::raw::c_char,
    ) -> *const gchar;
}
extern "C" {
    pub fn val_to_str_ext_wmem(
        scope: *mut wmem_allocator_t,
        val: guint32,
        vse: *mut value_string_ext,
        fmt: *const ::std::os::raw::c_char,
    ) -> *mut gchar;
}
extern "C" {
    pub fn val_to_str_ext_const(
        val: guint32,
        vs: *mut value_string_ext,
        unknown_str: *const ::std::os::raw::c_char,
    ) -> *const gchar;
}
extern "C" {
    pub fn try_val_to_str_ext(val: guint32, vse: *mut value_string_ext) -> *const gchar;
}
extern "C" {
    pub fn try_val_to_str_idx_ext(
        val: guint32,
        vse: *mut value_string_ext,
        idx: *mut gint,
    ) -> *const gchar;
}
pub type val64_string_ext = _val64_string_ext;
pub type _val64_string_match2_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: guint64, arg2: *mut val64_string_ext) -> *const val64_string,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _val64_string_ext {
    pub _vs_match2: _val64_string_match2_t,
    pub _vs_first_value: guint64,
    pub _vs_num_entries: guint,
    pub _vs_p: *const val64_string,
    pub _vs_name: *const gchar,
}
#[test]
fn bindgen_test_layout__val64_string_ext() {
    const UNINIT: ::std::mem::MaybeUninit<_val64_string_ext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_val64_string_ext>(),
        40usize,
        concat!("Size of: ", stringify!(_val64_string_ext))
    );
    assert_eq!(
        ::std::mem::align_of::<_val64_string_ext>(),
        8usize,
        concat!("Alignment of ", stringify!(_val64_string_ext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vs_match2) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_val64_string_ext),
            "::",
            stringify!(_vs_match2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vs_first_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_val64_string_ext),
            "::",
            stringify!(_vs_first_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vs_num_entries) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_val64_string_ext),
            "::",
            stringify!(_vs_num_entries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vs_p) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_val64_string_ext),
            "::",
            stringify!(_vs_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vs_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_val64_string_ext),
            "::",
            stringify!(_vs_name)
        )
    );
}
extern "C" {
    pub fn _try_val64_to_str_ext_init(
        val: guint64,
        vse: *mut val64_string_ext,
    ) -> *const val64_string;
}
extern "C" {
    pub fn val64_string_ext_new(
        vs: *const val64_string,
        vs_tot_num_entries: guint,
        vs_name: *const gchar,
    ) -> *mut val64_string_ext;
}
extern "C" {
    pub fn val64_string_ext_free(vse: *mut val64_string_ext);
}
extern "C" {
    pub fn val64_to_str_ext(
        val: guint64,
        vse: *mut val64_string_ext,
        fmt: *const ::std::os::raw::c_char,
    ) -> *const gchar;
}
extern "C" {
    pub fn val64_to_str_ext_wmem(
        scope: *mut wmem_allocator_t,
        val: guint64,
        vse: *mut val64_string_ext,
        fmt: *const ::std::os::raw::c_char,
    ) -> *mut gchar;
}
extern "C" {
    pub fn val64_to_str_ext_const(
        val: guint64,
        vs: *mut val64_string_ext,
        unknown_str: *const ::std::os::raw::c_char,
    ) -> *const gchar;
}
extern "C" {
    pub fn try_val64_to_str_ext(val: guint64, vse: *mut val64_string_ext) -> *const gchar;
}
extern "C" {
    pub fn try_val64_to_str_idx_ext(
        val: guint64,
        vse: *mut val64_string_ext,
        idx: *mut gint,
    ) -> *const gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _string_string {
    pub value: *const gchar,
    pub strptr: *const gchar,
}
#[test]
fn bindgen_test_layout__string_string() {
    const UNINIT: ::std::mem::MaybeUninit<_string_string> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_string_string>(),
        16usize,
        concat!("Size of: ", stringify!(_string_string))
    );
    assert_eq!(
        ::std::mem::align_of::<_string_string>(),
        8usize,
        concat!("Alignment of ", stringify!(_string_string))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_string_string),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_string_string),
            "::",
            stringify!(strptr)
        )
    );
}
pub type string_string = _string_string;
extern "C" {
    pub fn str_to_str(
        val: *const gchar,
        vs: *const string_string,
        fmt: *const ::std::os::raw::c_char,
    ) -> *const gchar;
}
extern "C" {
    pub fn try_str_to_str(val: *const gchar, vs: *const string_string) -> *const gchar;
}
extern "C" {
    pub fn try_str_to_str_idx(
        val: *const gchar,
        vs: *const string_string,
        idx: *mut gint,
    ) -> *const gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _range_string {
    pub value_min: u64,
    pub value_max: u64,
    pub strptr: *const gchar,
}
#[test]
fn bindgen_test_layout__range_string() {
    const UNINIT: ::std::mem::MaybeUninit<_range_string> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_range_string>(),
        24usize,
        concat!("Size of: ", stringify!(_range_string))
    );
    assert_eq!(
        ::std::mem::align_of::<_range_string>(),
        8usize,
        concat!("Alignment of ", stringify!(_range_string))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_min) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_range_string),
            "::",
            stringify!(value_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_range_string),
            "::",
            stringify!(value_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strptr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_range_string),
            "::",
            stringify!(strptr)
        )
    );
}
pub type range_string = _range_string;
extern "C" {
    pub fn rval_to_str(
        val: guint32,
        rs: *const range_string,
        fmt: *const ::std::os::raw::c_char,
    ) -> *const gchar;
}
extern "C" {
    pub fn rval_to_str_const(
        val: guint32,
        rs: *const range_string,
        unknown_str: *const ::std::os::raw::c_char,
    ) -> *const gchar;
}
extern "C" {
    pub fn try_rval_to_str(val: guint32, rs: *const range_string) -> *const gchar;
}
extern "C" {
    pub fn try_rval_to_str_idx(
        val: guint32,
        rs: *const range_string,
        idx: *mut gint,
    ) -> *const gchar;
}
extern "C" {
    pub fn try_rval64_to_str(val: guint64, rs: *const range_string) -> *const gchar;
}
extern "C" {
    pub fn try_rval64_to_str_idx(
        val: guint64,
        rs: *const range_string,
        idx: *mut gint,
    ) -> *const gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bytes_string {
    pub value: *const guint8,
    pub value_length: usize,
    pub strptr: *const gchar,
}
#[test]
fn bindgen_test_layout__bytes_string() {
    const UNINIT: ::std::mem::MaybeUninit<_bytes_string> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_bytes_string>(),
        24usize,
        concat!("Size of: ", stringify!(_bytes_string))
    );
    assert_eq!(
        ::std::mem::align_of::<_bytes_string>(),
        8usize,
        concat!("Alignment of ", stringify!(_bytes_string))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bytes_string),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_bytes_string),
            "::",
            stringify!(value_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strptr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_bytes_string),
            "::",
            stringify!(strptr)
        )
    );
}
pub type bytes_string = _bytes_string;
extern "C" {
    pub fn bytesval_to_str(
        val: *const guint8,
        val_len: usize,
        bs: *const bytes_string,
        fmt: *const ::std::os::raw::c_char,
    ) -> *const gchar;
}
extern "C" {
    pub fn try_bytesval_to_str(
        val: *const guint8,
        val_len: usize,
        bs: *const bytes_string,
    ) -> *const gchar;
}
extern "C" {
    pub fn bytesprefix_to_str(
        haystack: *const guint8,
        haystack_len: usize,
        bs: *const bytes_string,
        fmt: *const ::std::os::raw::c_char,
    ) -> *const gchar;
}
extern "C" {
    pub fn try_bytesprefix_to_str(
        haystack: *const guint8,
        haystack_len: usize,
        bs: *const bytes_string,
    ) -> *const gchar;
}
extern "C" {
    pub fn value_string_ext_validate(vse: *const value_string_ext) -> gboolean;
}
extern "C" {
    pub fn value_string_ext_match_type_str(vse: *const value_string_ext) -> *const gchar;
}
extern "C" {
    pub fn val64_string_ext_validate(vse: *const val64_string_ext) -> gboolean;
}
extern "C" {
    pub fn val64_string_ext_match_type_str(vse: *const val64_string_ext) -> *const gchar;
}
#[doc = " Struct for boolean representation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct true_false_string {
    #[doc = "< The string presented when true"]
    pub true_string: *const ::std::os::raw::c_char,
    #[doc = "< The string presented when false"]
    pub false_string: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_true_false_string() {
    const UNINIT: ::std::mem::MaybeUninit<true_false_string> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<true_false_string>(),
        16usize,
        concat!("Size of: ", stringify!(true_false_string))
    );
    assert_eq!(
        ::std::mem::align_of::<true_false_string>(),
        8usize,
        concat!("Alignment of ", stringify!(true_false_string))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).true_string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(true_false_string),
            "::",
            stringify!(true_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).false_string) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(true_false_string),
            "::",
            stringify!(false_string)
        )
    );
}
extern "C" {
    #[doc = " Returns the string representing the true or false value.\n\n From the given true_false_string return the appropriate string pointer\n @param[in] value The boolean value for which the string representation is sought\n @param[in] tfs   The true_false_string containing the relevant strings\n @return          Pointer to the appropriate string"]
    pub fn tfs_get_string(
        value: gboolean,
        tfs: *const true_false_string,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub static tfs_yes_no: true_false_string;
}
extern "C" {
    pub static tfs_no_yes: true_false_string;
}
extern "C" {
    pub static tfs_set_notset: true_false_string;
}
extern "C" {
    pub static tfs_enabled_disabled: true_false_string;
}
extern "C" {
    pub static tfs_disabled_enabled: true_false_string;
}
extern "C" {
    pub static tfs_ok_error: true_false_string;
}
extern "C" {
    pub static tfs_error_ok: true_false_string;
}
extern "C" {
    pub static tfs_success_fail: true_false_string;
}
extern "C" {
    pub static tfs_fail_success: true_false_string;
}
extern "C" {
    pub static tfs_on_off: true_false_string;
}
extern "C" {
    pub static tfs_ack_nack: true_false_string;
}
extern "C" {
    pub static tfs_odd_even: true_false_string;
}
extern "C" {
    pub static tfs_allow_block: true_false_string;
}
extern "C" {
    pub static tfs_restricted_allowed: true_false_string;
}
extern "C" {
    pub static tfs_restricted_not_restricted: true_false_string;
}
extern "C" {
    pub static tfs_not_restricted_restricted: true_false_string;
}
extern "C" {
    pub static tfs_accept_reject: true_false_string;
}
extern "C" {
    pub static tfs_more_nomore: true_false_string;
}
extern "C" {
    pub static tfs_present_absent: true_false_string;
}
extern "C" {
    pub static tfs_present_not_present: true_false_string;
}
extern "C" {
    pub static tfs_active_inactive: true_false_string;
}
extern "C" {
    pub static tfs_activated_deactivated: true_false_string;
}
extern "C" {
    pub static tfs_found_not_found: true_false_string;
}
extern "C" {
    pub static tfs_command_response: true_false_string;
}
extern "C" {
    pub static tfs_response_command: true_false_string;
}
extern "C" {
    pub static tfs_capable_not_capable: true_false_string;
}
extern "C" {
    pub static tfs_supported_not_supported: true_false_string;
}
extern "C" {
    pub static tfs_not_supported_supported: true_false_string;
}
extern "C" {
    pub static tfs_used_notused: true_false_string;
}
extern "C" {
    pub static tfs_high_low: true_false_string;
}
extern "C" {
    pub static tfs_high_normal: true_false_string;
}
extern "C" {
    pub static tfs_low_normal: true_false_string;
}
extern "C" {
    pub static tfs_pressed_not_pressed: true_false_string;
}
extern "C" {
    pub static tfs_implemented_not_implemented: true_false_string;
}
extern "C" {
    pub static tfs_requested_not_requested: true_false_string;
}
extern "C" {
    pub static tfs_reliable_not_reliable: true_false_string;
}
extern "C" {
    pub static tfs_allowed_not_allowed: true_false_string;
}
extern "C" {
    pub static tfs_not_allowed_allowed: true_false_string;
}
extern "C" {
    pub static tfs_accepted_not_accepted: true_false_string;
}
extern "C" {
    pub static tfs_detected_not_detected: true_false_string;
}
extern "C" {
    pub static tfs_available_not_available: true_false_string;
}
extern "C" {
    pub static tfs_shared_independent: true_false_string;
}
extern "C" {
    pub static tfs_valid_invalid: true_false_string;
}
extern "C" {
    pub static tfs_invalid_valid: true_false_string;
}
extern "C" {
    pub static tfs_group_unique_name: true_false_string;
}
extern "C" {
    pub static tfs_inuse_not_inuse: true_false_string;
}
extern "C" {
    pub static tfs_critical_not_critical: true_false_string;
}
extern "C" {
    pub static tfs_complete_incomplete: true_false_string;
}
extern "C" {
    pub static tfs_valid_not_valid: true_false_string;
}
extern "C" {
    pub static tfs_do_not_clear_clear: true_false_string;
}
extern "C" {
    pub static tfs_confirmed_unconfirmed: true_false_string;
}
extern "C" {
    pub static tfs_enforced_not_enforced: true_false_string;
}
extern "C" {
    pub static tfs_possible_not_possible: true_false_string;
}
extern "C" {
    pub static tfs_required_not_required: true_false_string;
}
extern "C" {
    pub static tfs_registered_not_registered: true_false_string;
}
extern "C" {
    pub static tfs_provisioned_not_provisioned: true_false_string;
}
extern "C" {
    pub static tfs_included_not_included: true_false_string;
}
extern "C" {
    pub static tfs_allocated_by_receiver_sender: true_false_string;
}
extern "C" {
    pub static tfs_asynchronous_synchronous: true_false_string;
}
extern "C" {
    pub static tfs_protocol_sensative_bit_transparent: true_false_string;
}
extern "C" {
    pub static tfs_full_half: true_false_string;
}
extern "C" {
    pub static tfs_acknowledged_not_acknowledged: true_false_string;
}
extern "C" {
    pub static tfs_segmentation_no_segmentation: true_false_string;
}
extern "C" {
    pub static tfs_response_request: true_false_string;
}
extern "C" {
    pub static tfs_defined_not_defined: true_false_string;
}
extern "C" {
    pub static tfs_constructed_primitive: true_false_string;
}
extern "C" {
    pub static tfs_client_server: true_false_string;
}
extern "C" {
    pub static tfs_server_client: true_false_string;
}
extern "C" {
    pub static tfs_preferred_no_preference: true_false_string;
}
extern "C" {
    pub static tfs_encrypt_do_not_encrypt: true_false_string;
}
extern "C" {
    pub static tfs_down_up: true_false_string;
}
extern "C" {
    pub static tfs_up_down: true_false_string;
}
extern "C" {
    pub static tfs_downlink_uplink: true_false_string;
}
extern "C" {
    pub static tfs_uplink_downlink: true_false_string;
}
extern "C" {
    pub static tfs_s2c_c2s: true_false_string;
}
extern "C" {
    pub static tfs_c2s_s2c: true_false_string;
}
extern "C" {
    pub static tfs_open_closed: true_false_string;
}
extern "C" {
    pub static tfs_external_internal: true_false_string;
}
extern "C" {
    pub static tfs_changed_not_changed: true_false_string;
}
extern "C" {
    pub static tfs_needed_not_needed: true_false_string;
}
extern "C" {
    pub static tfs_selected_not_selected: true_false_string;
}
extern "C" {
    pub static tfs_add_drop: true_false_string;
}
extern "C" {
    pub static tfs_no_extension_extension: true_false_string;
}
extern "C" {
    pub static tfs_user_provider: true_false_string;
}
extern "C" {
    pub static tfs_applicable_not_applicable: true_false_string;
}
extern "C" {
    pub static tfs_current_not_yet: true_false_string;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epan_session {
    _unused: [u8; 0],
}
pub const packet_char_enc_PACKET_CHAR_ENC_CHAR_ASCII: packet_char_enc = 0;
pub const packet_char_enc_PACKET_CHAR_ENC_CHAR_EBCDIC: packet_char_enc = 1;
#[doc = " @todo XXX - some of this stuff is used only while a packet is being dissected;\nshould we keep that stuff in the \"packet_info\" structure, instead, to\nsave memory?"]
pub type packet_char_enc = ::std::os::raw::c_int;
#[doc = " The frame number is the ordinal number of the frame in the capture, so\nit's 1-origin.  In various contexts, 0 as a frame number means \"frame\nnumber unknown\".\n\nThere is one of these structures for every frame in the capture.\nThat means a lot of memory if we have a lot of frames.\nThey are packed into power-of-2 chunks, so their size is effectively\nrounded up to a power of 2.\nTry to keep it close to, and less than or equal to, a power of 2.\n\"Smaller than a power of 2\" is OK for ILP32 platforms.\n\nXXX - shuffle the fields to try to keep the most commonly-accessed\nfields within the first 16 or 32 bytes, so they all fit in a cache\nline?"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _color_filter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _frame_data {
    #[doc = "< Frame number"]
    pub num: guint32,
    #[doc = "< Packet length"]
    pub pkt_len: guint32,
    #[doc = "< Amount actually captured"]
    pub cap_len: guint32,
    #[doc = "< Cumulative bytes into the capture"]
    pub cum_bytes: guint32,
    #[doc = "< File offset"]
    pub file_off: gint64,
    #[doc = "< Per frame proto data"]
    pub pfd: *mut GSList,
    #[doc = "< A hash table of frames which this one depends on"]
    pub dependent_frames: *mut GHashTable,
    #[doc = "< Per-packet matching color_filter_t object"]
    pub color_filter: *const _color_filter,
    #[doc = "< subframe number, for protocols that require this"]
    pub subnum: guint16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    #[doc = "< Absolute timestamp"]
    pub abs_ts: nstime_t,
    #[doc = "< How much the abs_tm of the frame is shifted"]
    pub shift_offset: nstime_t,
    #[doc = "< Previous reference frame (0 if this is one)"]
    pub frame_ref_num: guint32,
    #[doc = "< Previous displayed frame (0 if first one)"]
    pub prev_dis_num: guint32,
    #[doc = "< TCP SEQ Analysis Overriding, 0 = none, 1 = OOO, 2 = RET , 3 = Fast RET, 4 = Spurious RET"]
    pub tcp_snd_manual_analysis: guint8,
}
#[test]
fn bindgen_test_layout__frame_data() {
    const UNINIT: ::std::mem::MaybeUninit<_frame_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_frame_data>(),
        104usize,
        concat!("Size of: ", stringify!(_frame_data))
    );
    assert_eq!(
        ::std::mem::align_of::<_frame_data>(),
        8usize,
        concat!("Alignment of ", stringify!(_frame_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_frame_data),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pkt_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_frame_data),
            "::",
            stringify!(pkt_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_frame_data),
            "::",
            stringify!(cap_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cum_bytes) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_frame_data),
            "::",
            stringify!(cum_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_off) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_frame_data),
            "::",
            stringify!(file_off)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfd) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_frame_data),
            "::",
            stringify!(pfd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dependent_frames) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_frame_data),
            "::",
            stringify!(dependent_frames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_filter) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_frame_data),
            "::",
            stringify!(color_filter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subnum) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_frame_data),
            "::",
            stringify!(subnum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abs_ts) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_frame_data),
            "::",
            stringify!(abs_ts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shift_offset) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_frame_data),
            "::",
            stringify!(shift_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_ref_num) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_frame_data),
            "::",
            stringify!(frame_ref_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev_dis_num) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_frame_data),
            "::",
            stringify!(prev_dis_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcp_snd_manual_analysis) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_frame_data),
            "::",
            stringify!(tcp_snd_manual_analysis)
        )
    );
}
impl _frame_data {
    #[inline]
    pub fn passed_dfilter(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_passed_dfilter(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dependent_of_displayed(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dependent_of_displayed(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encoding(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_encoding(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn visited(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_visited(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn marked(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_marked(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_time(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ref_time(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ignored(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ignored(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_ts(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_ts(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_modified_block(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_modified_block(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn need_colorize(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_need_colorize(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tsprec(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_tsprec(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        passed_dfilter: ::std::os::raw::c_uint,
        dependent_of_displayed: ::std::os::raw::c_uint,
        encoding: ::std::os::raw::c_uint,
        visited: ::std::os::raw::c_uint,
        marked: ::std::os::raw::c_uint,
        ref_time: ::std::os::raw::c_uint,
        ignored: ::std::os::raw::c_uint,
        has_ts: ::std::os::raw::c_uint,
        has_modified_block: ::std::os::raw::c_uint,
        need_colorize: ::std::os::raw::c_uint,
        tsprec: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let passed_dfilter: u32 = unsafe { ::std::mem::transmute(passed_dfilter) };
            passed_dfilter as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dependent_of_displayed: u32 =
                unsafe { ::std::mem::transmute(dependent_of_displayed) };
            dependent_of_displayed as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let encoding: u32 = unsafe { ::std::mem::transmute(encoding) };
            encoding as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let visited: u32 = unsafe { ::std::mem::transmute(visited) };
            visited as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let marked: u32 = unsafe { ::std::mem::transmute(marked) };
            marked as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ref_time: u32 = unsafe { ::std::mem::transmute(ref_time) };
            ref_time as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ignored: u32 = unsafe { ::std::mem::transmute(ignored) };
            ignored as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let has_ts: u32 = unsafe { ::std::mem::transmute(has_ts) };
            has_ts as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let has_modified_block: u32 = unsafe { ::std::mem::transmute(has_modified_block) };
            has_modified_block as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let need_colorize: u32 = unsafe { ::std::mem::transmute(need_colorize) };
            need_colorize as u64
        });
        __bindgen_bitfield_unit.set(10usize, 4u8, {
            let tsprec: u32 = unsafe { ::std::mem::transmute(tsprec) };
            tsprec as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type frame_data = _frame_data;
extern "C" {
    #[doc = " compare two frame_datas"]
    pub fn frame_data_compare(
        epan: *const epan_session,
        fdata1: *const frame_data,
        fdata2: *const frame_data,
        field: ::std::os::raw::c_int,
    ) -> gint;
}
extern "C" {
    pub fn frame_data_reset(fdata: *mut frame_data);
}
extern "C" {
    pub fn frame_data_destroy(fdata: *mut frame_data);
}
extern "C" {
    pub fn frame_data_init(
        fdata: *mut frame_data,
        num: guint32,
        rec: *const wtap_rec,
        offset: gint64,
        cum_bytes: guint32,
    );
}
extern "C" {
    pub fn frame_delta_abs_time(
        epan: *const epan_session,
        fdata: *const frame_data,
        prev_num: guint32,
        delta: *mut nstime_t,
    );
}
extern "C" {
    #[doc = " Sets the frame data struct values before dissection."]
    pub fn frame_data_set_before_dissect(
        fdata: *mut frame_data,
        elapsed_time: *mut nstime_t,
        frame_ref: *mut *const frame_data,
        prev_dis: *const frame_data,
    );
}
extern "C" {
    pub fn frame_data_set_after_dissect(fdata: *mut frame_data, cum_bytes: *mut guint32);
}
pub const address_type_AT_NONE: address_type = 0;
pub const address_type_AT_ETHER: address_type = 1;
pub const address_type_AT_IPv4: address_type = 2;
pub const address_type_AT_IPv6: address_type = 3;
pub const address_type_AT_IPX: address_type = 4;
pub const address_type_AT_FC: address_type = 5;
pub const address_type_AT_FCWWN: address_type = 6;
pub const address_type_AT_STRINGZ: address_type = 7;
pub const address_type_AT_EUI64: address_type = 8;
pub const address_type_AT_IB: address_type = 9;
pub const address_type_AT_AX25: address_type = 10;
pub const address_type_AT_VINES: address_type = 11;
pub const address_type_AT_NUMERIC: address_type = 12;
pub const address_type_AT_MCTP: address_type = 13;
pub const address_type_AT_END_OF_LIST: address_type = 14;
pub type address_type = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _address {
    pub type_: ::std::os::raw::c_int,
    pub len: ::std::os::raw::c_int,
    pub data: *const ::std::os::raw::c_void,
    pub priv_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__address() {
    const UNINIT: ::std::mem::MaybeUninit<_address> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_address>(),
        24usize,
        concat!("Size of: ", stringify!(_address))
    );
    assert_eq!(
        ::std::mem::align_of::<_address>(),
        8usize,
        concat!("Alignment of ", stringify!(_address))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_address),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_address),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_address),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_address),
            "::",
            stringify!(priv_)
        )
    );
}
pub type address = _address;
extern "C" {
    pub fn address_to_bytes(addr: *const address, buf: *mut guint8, buf_len: guint) -> guint;
}
pub const port_type_PT_NONE: port_type = 0;
pub const port_type_PT_SCTP: port_type = 1;
pub const port_type_PT_TCP: port_type = 2;
pub const port_type_PT_UDP: port_type = 3;
pub const port_type_PT_DCCP: port_type = 4;
pub const port_type_PT_IPX: port_type = 5;
pub const port_type_PT_DDP: port_type = 6;
pub const port_type_PT_IDP: port_type = 7;
pub const port_type_PT_USB: port_type = 8;
pub const port_type_PT_I2C: port_type = 9;
pub const port_type_PT_IBQP: port_type = 10;
pub const port_type_PT_BLUETOOTH: port_type = 11;
pub const port_type_PT_IWARP_MPA: port_type = 12;
pub const port_type_PT_MCTP: port_type = 13;
pub type port_type = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conversation_element {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _packet_info {
    #[doc = "< name of protocol currently being dissected"]
    pub current_proto: *const ::std::os::raw::c_char,
    #[doc = "< Column formatting information"]
    pub cinfo: *mut epan_column_info,
    #[doc = "< Presence flags for some items"]
    pub presence_flags: guint32,
    #[doc = "< Frame number"]
    pub num: guint32,
    #[doc = "< Packet absolute time stamp"]
    pub abs_ts: nstime_t,
    #[doc = "< Relative timestamp (yes, it can be negative)"]
    pub rel_ts: nstime_t,
    #[doc = "< Relative timestamp from capture start (might be negative for broken files)"]
    pub rel_cap_ts: nstime_t,
    #[doc = "< Relative timestamp from capture start valid"]
    pub rel_cap_ts_present: gboolean,
    pub fd: *mut frame_data,
    pub pseudo_header: *mut wtap_pseudo_header,
    #[doc = "< Record metadata"]
    pub rec: *mut wtap_rec,
    #[doc = "< Frame data sources"]
    pub data_src: *mut GSList,
    #[doc = "< link-layer source address"]
    pub dl_src: address,
    #[doc = "< link-layer destination address"]
    pub dl_dst: address,
    #[doc = "< network-layer source address"]
    pub net_src: address,
    #[doc = "< network-layer destination address"]
    pub net_dst: address,
    #[doc = "< source address (net if present, DL otherwise )"]
    pub src: address,
    #[doc = "< destination address (net if present, DL otherwise )"]
    pub dst: address,
    #[doc = "< First encountered VLAN Id if present otherwise 0"]
    pub vlan_id: guint32,
    #[doc = "< reason why reassembly wasn't done, if any"]
    pub noreassembly_reason: *const ::std::os::raw::c_char,
    #[doc = "< TRUE if the protocol is only a fragment"]
    pub fragmented: gboolean,
    pub flags: _packet_info__bindgen_ty_1,
    #[doc = "< type of the following two port numbers"]
    pub ptype: port_type,
    #[doc = "< source port"]
    pub srcport: guint32,
    #[doc = "< destination port"]
    pub destport: guint32,
    #[doc = "< matched uint for calling subdissector from table"]
    pub match_uint: guint32,
    #[doc = "< matched string for calling subdissector from table"]
    pub match_string: *const ::std::os::raw::c_char,
    #[doc = "< TRUE if address/port endpoints member should be used for conversations"]
    pub use_conv_addr_port_endpoints: gboolean,
    #[doc = "< Data that can be used for address+port conversations, including wildcarding"]
    pub conv_addr_port_endpoints: *mut conversation_addr_port_endpoints,
    #[doc = "< Arbritrary conversation identifier; can't be wildcarded"]
    pub conv_elements: *mut conversation_element,
    #[doc = "< >0 if this segment could be desegmented.\nA dissector that can offer this API (e.g.\nTCP) sets can_desegment=2, then\ncan_desegment is decremented by 1 each time\nwe pass to the next subdissector. Thus only\nthe dissector immediately above the\nprotocol which sets the flag can use it"]
    pub can_desegment: guint16,
    #[doc = "< Value of can_desegment before current\ndissector was called.  Supplied so that\ndissectors for proxy protocols such as\nSOCKS can restore it, allowing the\ndissectors that they call to use the\nTCP dissector's desegmentation (SOCKS\njust retransmits TCP segments once it's\nfinished setting things up, so the TCP\ndesegmentor can desegment its payload)."]
    pub saved_can_desegment: guint16,
    #[doc = "< offset to stuff needing desegmentation"]
    pub desegment_offset: ::std::os::raw::c_int,
    #[doc = "< requested desegmentation additional length\nor\nDESEGMENT_ONE_MORE_SEGMENT:\nDesegment one more full segment\n(warning! only partially implemented)\nDESEGMENT_UNTIL_FIN:\nDesgment all data for this tcp session\nuntil the FIN segment."]
    pub desegment_len: guint32,
    #[doc = "< >0 if the subdissector has specified\na value in 'bytes_until_next_pdu'.\nWhen a dissector detects that the next PDU\nwill start beyond the start of the next\nsegment, it can set this value to 2\nand 'bytes_until_next_pdu' to the number of\nbytes beyond the next segment where the\nnext PDU starts.\n\nIf the protocol dissector below this\none is capable of PDU tracking it can\nuse this hint to detect PDUs that starts\nunaligned to the segment boundaries.\nThe TCP dissector is using this hint from\n(some) protocols to detect when a new PDU\nstarts in the middle of a tcp segment.\n\nThere is intelligence in the glue between\ndissector layers to make sure that this\nrequest is only passed down to the protocol\nimmediately below the current one and not\nany further."]
    pub want_pdu_tracking: guint16,
    pub bytes_until_next_pdu: guint32,
    #[doc = "< Packet was captured as an\noutbound (P2P_DIR_SENT)\ninbound (P2P_DIR_RECV)\nunknown (P2P_DIR_UNKNOWN)"]
    pub p2p_dir: ::std::os::raw::c_int,
    #[doc = "< a hash table passed from one dissector to another"]
    pub private_table: *mut GHashTable,
    #[doc = "< layers of each protocol"]
    pub layers: *mut wmem_list_t,
    pub proto_layers: *mut wmem_map_t,
    #[doc = "< The current \"depth\" or layer number in the current frame"]
    pub curr_layer_num: guint8,
    #[doc = "< The current \"depth\" or layer number for this dissector in the current frame"]
    pub curr_proto_layer_num: guint8,
    pub link_number: guint16,
    #[doc = "< clnp/cotp source reference (can't use srcport, this would confuse tpkt)"]
    pub clnp_srcref: guint16,
    #[doc = "< clnp/cotp destination reference (can't use dstport, this would confuse tpkt)"]
    pub clnp_dstref: guint16,
    #[doc = "< 3GPP messages are sometime different UP link(UL) or Downlink(DL)"]
    pub link_dir: ::std::os::raw::c_int,
    #[doc = "< Rcv.Wind.Shift src applies when sending segments; -1 unknown; -2 disabled"]
    pub src_win_scale: gint16,
    #[doc = "< Rcv.Wind.Shift dst applies when sending segments; -1 unknown; -2 disabled"]
    pub dst_win_scale: gint16,
    #[doc = "< Per packet proto data"]
    pub proto_data: *mut GSList,
    pub frame_end_routines: *mut GSList,
    #[doc = "< Memory pool scoped to the pinfo struct"]
    pub pool: *mut wmem_allocator_t,
    pub epan: *mut epan_session,
    #[doc = "< name of heur list if this packet is being heuristically dissected"]
    pub heur_list_name: *const gchar,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _packet_info__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout__packet_info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_packet_info__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_packet_info__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_packet_info__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_packet_info__bindgen_ty_1))
    );
}
impl _packet_info__bindgen_ty_1 {
    #[inline]
    pub fn in_error_pkt(&self) -> guint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_error_pkt(&mut self, val: guint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_gre_pkt(&self) -> guint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_gre_pkt(&mut self, val: guint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        in_error_pkt: guint32,
        in_gre_pkt: guint32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let in_error_pkt: u32 = unsafe { ::std::mem::transmute(in_error_pkt) };
            in_error_pkt as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let in_gre_pkt: u32 = unsafe { ::std::mem::transmute(in_gre_pkt) };
            in_gre_pkt as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__packet_info() {
    const UNINIT: ::std::mem::MaybeUninit<_packet_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_packet_info>(),
        432usize,
        concat!("Size of: ", stringify!(_packet_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_packet_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_packet_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_proto) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(current_proto)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cinfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(cinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).presence_flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(presence_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abs_ts) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(abs_ts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rel_ts) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(rel_ts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rel_cap_ts) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(rel_cap_ts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rel_cap_ts_present) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(rel_cap_ts_present)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pseudo_header) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(pseudo_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rec) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(rec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_src) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(data_src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dl_src) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(dl_src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dl_dst) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(dl_dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).net_src) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(net_src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).net_dst) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(net_dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vlan_id) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(vlan_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).noreassembly_reason) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(noreassembly_reason)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fragmented) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(fragmented)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptype) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(ptype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcport) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(srcport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destport) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(destport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).match_uint) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(match_uint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).match_string) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(match_string)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).use_conv_addr_port_endpoints) as usize - ptr as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(use_conv_addr_port_endpoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conv_addr_port_endpoints) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(conv_addr_port_endpoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conv_elements) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(conv_elements)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_desegment) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(can_desegment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).saved_can_desegment) as usize - ptr as usize },
        330usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(saved_can_desegment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desegment_offset) as usize - ptr as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(desegment_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desegment_len) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(desegment_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).want_pdu_tracking) as usize - ptr as usize },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(want_pdu_tracking)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes_until_next_pdu) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(bytes_until_next_pdu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p2p_dir) as usize - ptr as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(p2p_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_table) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(private_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).layers) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(layers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proto_layers) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(proto_layers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).curr_layer_num) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(curr_layer_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).curr_proto_layer_num) as usize - ptr as usize },
        377usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(curr_proto_layer_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).link_number) as usize - ptr as usize },
        378usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(link_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clnp_srcref) as usize - ptr as usize },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(clnp_srcref)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clnp_dstref) as usize - ptr as usize },
        382usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(clnp_dstref)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).link_dir) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(link_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_win_scale) as usize - ptr as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(src_win_scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst_win_scale) as usize - ptr as usize },
        390usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(dst_win_scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proto_data) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(proto_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_end_routines) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(frame_end_routines)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).epan) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(epan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heur_list_name) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(heur_list_name)
        )
    );
}
pub type packet_info = _packet_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ws_regex {
    _unused: [u8; 0],
}
pub type ws_regex_t = _ws_regex;
extern "C" {
    pub fn ws_regex_compile(
        patt: *const ::std::os::raw::c_char,
        errmsg: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ws_regex_t;
}
extern "C" {
    pub fn ws_regex_compile_ex(
        patt: *const ::std::os::raw::c_char,
        size: isize,
        errmsg: *mut *mut ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> *mut ws_regex_t;
}
extern "C" {
    #[doc = " Matches a null-terminated subject string."]
    pub fn ws_regex_matches(re: *const ws_regex_t, subj: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " Matches a subject string length in 8 bit code units."]
    pub fn ws_regex_matches_length(
        re: *const ws_regex_t,
        subj: *const ::std::os::raw::c_char,
        subj_length: isize,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns start and end position of the matched substring.\n\n  pos_vect[0] is first codepoint in the matched substring.\n  pos_vect[1] is the next to last codepoint in the matched substring.\n  pos_vect[1] - pos_vect[0] is the matched substring length."]
    pub fn ws_regex_matches_pos(
        re: *const ws_regex_t,
        subj: *const ::std::os::raw::c_char,
        subj_length: isize,
        pos_vect: *mut usize,
    ) -> bool;
}
extern "C" {
    pub fn ws_regex_free(re: *mut ws_regex_t);
}
extern "C" {
    pub fn ws_regex_pattern(re: *const ws_regex_t) -> *const ::std::os::raw::c_char;
}
pub const ftenum_FT_NONE: ftenum = 0;
pub const ftenum_FT_PROTOCOL: ftenum = 1;
pub const ftenum_FT_BOOLEAN: ftenum = 2;
pub const ftenum_FT_CHAR: ftenum = 3;
pub const ftenum_FT_UINT8: ftenum = 4;
pub const ftenum_FT_UINT16: ftenum = 5;
pub const ftenum_FT_UINT24: ftenum = 6;
pub const ftenum_FT_UINT32: ftenum = 7;
pub const ftenum_FT_UINT40: ftenum = 8;
pub const ftenum_FT_UINT48: ftenum = 9;
pub const ftenum_FT_UINT56: ftenum = 10;
pub const ftenum_FT_UINT64: ftenum = 11;
pub const ftenum_FT_INT8: ftenum = 12;
pub const ftenum_FT_INT16: ftenum = 13;
pub const ftenum_FT_INT24: ftenum = 14;
pub const ftenum_FT_INT32: ftenum = 15;
pub const ftenum_FT_INT40: ftenum = 16;
pub const ftenum_FT_INT48: ftenum = 17;
pub const ftenum_FT_INT56: ftenum = 18;
pub const ftenum_FT_INT64: ftenum = 19;
pub const ftenum_FT_IEEE_11073_SFLOAT: ftenum = 20;
pub const ftenum_FT_IEEE_11073_FLOAT: ftenum = 21;
pub const ftenum_FT_FLOAT: ftenum = 22;
pub const ftenum_FT_DOUBLE: ftenum = 23;
pub const ftenum_FT_ABSOLUTE_TIME: ftenum = 24;
pub const ftenum_FT_RELATIVE_TIME: ftenum = 25;
pub const ftenum_FT_STRING: ftenum = 26;
pub const ftenum_FT_STRINGZ: ftenum = 27;
pub const ftenum_FT_UINT_STRING: ftenum = 28;
pub const ftenum_FT_ETHER: ftenum = 29;
pub const ftenum_FT_BYTES: ftenum = 30;
pub const ftenum_FT_UINT_BYTES: ftenum = 31;
pub const ftenum_FT_IPv4: ftenum = 32;
pub const ftenum_FT_IPv6: ftenum = 33;
pub const ftenum_FT_IPXNET: ftenum = 34;
pub const ftenum_FT_FRAMENUM: ftenum = 35;
pub const ftenum_FT_GUID: ftenum = 36;
pub const ftenum_FT_OID: ftenum = 37;
pub const ftenum_FT_EUI64: ftenum = 38;
pub const ftenum_FT_AX25: ftenum = 39;
pub const ftenum_FT_VINES: ftenum = 40;
pub const ftenum_FT_REL_OID: ftenum = 41;
pub const ftenum_FT_SYSTEM_ID: ftenum = 42;
pub const ftenum_FT_STRINGZPAD: ftenum = 43;
pub const ftenum_FT_FCWWN: ftenum = 44;
pub const ftenum_FT_STRINGZTRUNC: ftenum = 45;
pub const ftenum_FT_NUM_TYPES: ftenum = 46;
pub type ftenum = ::std::os::raw::c_int;
pub use self::ftenum as ftenum_t;
pub const ft_framenum_type_FT_FRAMENUM_NONE: ft_framenum_type = 0;
pub const ft_framenum_type_FT_FRAMENUM_REQUEST: ft_framenum_type = 1;
pub const ft_framenum_type_FT_FRAMENUM_RESPONSE: ft_framenum_type = 2;
pub const ft_framenum_type_FT_FRAMENUM_ACK: ft_framenum_type = 3;
pub const ft_framenum_type_FT_FRAMENUM_DUP_ACK: ft_framenum_type = 4;
pub const ft_framenum_type_FT_FRAMENUM_RETRANS_PREV: ft_framenum_type = 5;
pub const ft_framenum_type_FT_FRAMENUM_RETRANS_NEXT: ft_framenum_type = 6;
pub const ft_framenum_type_FT_FRAMENUM_NUM_TYPES: ft_framenum_type = 7;
pub type ft_framenum_type = ::std::os::raw::c_int;
pub use self::ft_framenum_type as ft_framenum_type_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ftype_t {
    _unused: [u8; 0],
}
pub type ftype_t = _ftype_t;
pub const ft_result_FT_OK: ft_result = 0;
pub const ft_result_FT_OVERFLOW: ft_result = 1;
pub const ft_result_FT_BADARG: ft_result = 2;
pub const ft_result_FT_ERROR: ft_result = 3;
pub type ft_result = ::std::os::raw::c_int;
pub type ft_bool_t = bool;
pub const ftrepr_FTREPR_DISPLAY: ftrepr = 0;
pub const ftrepr_FTREPR_DFILTER: ftrepr = 1;
pub const ftrepr_FTREPR_JSON: ftrepr = 2;
pub type ftrepr = ::std::os::raw::c_int;
pub use self::ftrepr as ftrepr_t;
extern "C" {
    pub fn ftypes_initialize();
}
extern "C" {
    pub fn ftypes_register_pseudofields();
}
extern "C" {
    pub fn ftype_similar_types(ftype_a: ftenum, ftype_b: ftenum) -> bool;
}
extern "C" {
    pub fn ftype_name(ftype: ftenum_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ftype_pretty_name(ftype: ftenum_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ftype_wire_size(ftype: ftenum_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftype_can_length(ftype: ftenum) -> bool;
}
extern "C" {
    pub fn ftype_can_slice(ftype: ftenum) -> bool;
}
extern "C" {
    pub fn ftype_can_eq(ftype: ftenum) -> bool;
}
extern "C" {
    pub fn ftype_can_cmp(ftype: ftenum) -> bool;
}
extern "C" {
    pub fn ftype_can_bitwise_and(ftype: ftenum) -> bool;
}
extern "C" {
    pub fn ftype_can_unary_minus(ftype: ftenum) -> bool;
}
extern "C" {
    pub fn ftype_can_add(ftype: ftenum) -> bool;
}
extern "C" {
    pub fn ftype_can_subtract(ftype: ftenum) -> bool;
}
extern "C" {
    pub fn ftype_can_multiply(ftype: ftenum) -> bool;
}
extern "C" {
    pub fn ftype_can_divide(ftype: ftenum) -> bool;
}
extern "C" {
    pub fn ftype_can_modulo(ftype: ftenum) -> bool;
}
extern "C" {
    pub fn ftype_can_contains(ftype: ftenum) -> bool;
}
extern "C" {
    pub fn ftype_can_matches(ftype: ftenum) -> bool;
}
extern "C" {
    pub fn ftype_can_is_zero(ftype: ftenum) -> bool;
}
extern "C" {
    pub fn ftype_can_is_negative(ftype: ftenum) -> bool;
}
extern "C" {
    pub fn ftype_can_val_to_sinteger(ftype: ftenum) -> bool;
}
extern "C" {
    pub fn ftype_can_val_to_uinteger(ftype: ftenum) -> bool;
}
extern "C" {
    pub fn ftype_can_val_to_sinteger64(ftype: ftenum) -> bool;
}
extern "C" {
    pub fn ftype_can_val_to_uinteger64(ftype: ftenum) -> bool;
}
pub const drange_node_end_t_DRANGE_NODE_END_T_UNINITIALIZED: drange_node_end_t = 0;
pub const drange_node_end_t_DRANGE_NODE_END_T_LENGTH: drange_node_end_t = 1;
pub const drange_node_end_t_DRANGE_NODE_END_T_OFFSET: drange_node_end_t = 2;
pub const drange_node_end_t_DRANGE_NODE_END_T_TO_THE_END: drange_node_end_t = 3;
pub type drange_node_end_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _drange_node {
    pub start_offset: ::std::os::raw::c_int,
    pub length: ::std::os::raw::c_int,
    pub end_offset: ::std::os::raw::c_int,
    pub ending: drange_node_end_t,
}
#[test]
fn bindgen_test_layout__drange_node() {
    const UNINIT: ::std::mem::MaybeUninit<_drange_node> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_drange_node>(),
        16usize,
        concat!("Size of: ", stringify!(_drange_node))
    );
    assert_eq!(
        ::std::mem::align_of::<_drange_node>(),
        4usize,
        concat!("Alignment of ", stringify!(_drange_node))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_drange_node),
            "::",
            stringify!(start_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_drange_node),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_drange_node),
            "::",
            stringify!(end_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ending) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_drange_node),
            "::",
            stringify!(ending)
        )
    );
}
pub type drange_node = _drange_node;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _drange {
    pub range_list: *mut GSList,
    pub has_total_length: bool,
    pub total_length: ::std::os::raw::c_int,
    pub min_start_offset: ::std::os::raw::c_int,
    pub max_start_offset: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__drange() {
    const UNINIT: ::std::mem::MaybeUninit<_drange> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_drange>(),
        24usize,
        concat!("Size of: ", stringify!(_drange))
    );
    assert_eq!(
        ::std::mem::align_of::<_drange>(),
        8usize,
        concat!("Alignment of ", stringify!(_drange))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range_list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_drange),
            "::",
            stringify!(range_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_total_length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_drange),
            "::",
            stringify!(has_total_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_length) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_drange),
            "::",
            stringify!(total_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_start_offset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_drange),
            "::",
            stringify!(min_start_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_start_offset) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_drange),
            "::",
            stringify!(max_start_offset)
        )
    );
}
pub type drange_t = _drange;
extern "C" {
    pub fn drange_node_new() -> *mut drange_node;
}
extern "C" {
    pub fn drange_node_from_str(
        range_str: *const ::std::os::raw::c_char,
        err_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut drange_node;
}
extern "C" {
    pub fn drange_node_free(drnode: *mut drange_node);
}
extern "C" {
    pub fn drange_node_free_list(list: *mut GSList);
}
extern "C" {
    pub fn drange_node_get_start_offset(drnode: *mut drange_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drange_node_get_length(drnode: *mut drange_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drange_node_get_end_offset(drnode: *mut drange_node) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drange_node_get_ending(drnode: *mut drange_node) -> drange_node_end_t;
}
extern "C" {
    pub fn drange_node_set_start_offset(drnode: *mut drange_node, offset: ::std::os::raw::c_int);
}
extern "C" {
    pub fn drange_node_set_length(drnode: *mut drange_node, length: ::std::os::raw::c_int);
}
extern "C" {
    pub fn drange_node_set_end_offset(drnode: *mut drange_node, offset: ::std::os::raw::c_int);
}
extern "C" {
    pub fn drange_node_set_to_the_end(drnode: *mut drange_node);
}
extern "C" {
    pub fn drange_new(drnode: *mut drange_node) -> *mut drange_t;
}
extern "C" {
    pub fn drange_new_from_list(list: *mut GSList) -> *mut drange_t;
}
extern "C" {
    pub fn drange_dup(org: *mut drange_t) -> *mut drange_t;
}
extern "C" {
    pub fn drange_free(dr: *mut drange_t);
}
extern "C" {
    pub fn drange_has_total_length(dr: *mut drange_t) -> bool;
}
extern "C" {
    pub fn drange_get_total_length(dr: *mut drange_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drange_get_min_start_offset(dr: *mut drange_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drange_get_max_start_offset(dr: *mut drange_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drange_append_drange_node(dr: *mut drange_t, drnode: *mut drange_node);
}
extern "C" {
    pub fn drange_prepend_drange_node(dr: *mut drange_t, drnode: *mut drange_node);
}
extern "C" {
    pub fn drange_foreach_drange_node(
        dr: *mut drange_t,
        func: GFunc,
        funcdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn drange_node_tostr(rn: *const drange_node) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn drange_tostr(dr: *const drange_t) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _protocol_value_t {
    pub tvb: *mut tvbuff_t,
    pub length: ::std::os::raw::c_int,
    pub proto_string: *mut ::std::os::raw::c_char,
    pub tvb_is_private: bool,
}
#[test]
fn bindgen_test_layout__protocol_value_t() {
    const UNINIT: ::std::mem::MaybeUninit<_protocol_value_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_protocol_value_t>(),
        32usize,
        concat!("Size of: ", stringify!(_protocol_value_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_protocol_value_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_protocol_value_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tvb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_protocol_value_t),
            "::",
            stringify!(tvb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_protocol_value_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proto_string) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_protocol_value_t),
            "::",
            stringify!(proto_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tvb_is_private) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_protocol_value_t),
            "::",
            stringify!(tvb_is_private)
        )
    );
}
pub type protocol_value_t = _protocol_value_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fvalue_t {
    _unused: [u8; 0],
}
pub type fvalue_t = _fvalue_t;
extern "C" {
    pub fn fvalue_new(ftype: ftenum_t) -> *mut fvalue_t;
}
extern "C" {
    pub fn fvalue_dup(fv: *const fvalue_t) -> *mut fvalue_t;
}
extern "C" {
    pub fn fvalue_init(fv: *mut fvalue_t, ftype: ftenum_t);
}
extern "C" {
    pub fn fvalue_cleanup(fv: *mut fvalue_t);
}
extern "C" {
    pub fn fvalue_free(fv: *mut fvalue_t);
}
extern "C" {
    pub fn fvalue_from_literal(
        ftype: ftenum_t,
        s: *const ::std::os::raw::c_char,
        allow_partial_value: bool,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> *mut fvalue_t;
}
extern "C" {
    pub fn fvalue_from_string(
        ftype: ftenum_t,
        s: *const ::std::os::raw::c_char,
        len: usize,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> *mut fvalue_t;
}
extern "C" {
    pub fn fvalue_from_charconst(
        ftype: ftenum_t,
        number: ::std::os::raw::c_ulong,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> *mut fvalue_t;
}
extern "C" {
    pub fn fvalue_to_string_repr(
        scope: *mut wmem_allocator_t,
        fv: *const fvalue_t,
        rtype: ftrepr_t,
        field_display: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fvalue_to_uinteger(fv: *const fvalue_t, repr: *mut u32) -> ft_result;
}
extern "C" {
    pub fn fvalue_to_sinteger(fv: *const fvalue_t, repr: *mut i32) -> ft_result;
}
extern "C" {
    pub fn fvalue_to_uinteger64(fv: *const fvalue_t, repr: *mut u64) -> ft_result;
}
extern "C" {
    pub fn fvalue_to_sinteger64(fv: *const fvalue_t, repr: *mut i64) -> ft_result;
}
extern "C" {
    pub fn fvalue_type_ftenum(fv: *mut fvalue_t) -> ftenum_t;
}
extern "C" {
    pub fn fvalue_type_name(fv: *const fvalue_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fvalue_set_bytes(fv: *mut fvalue_t, value: *mut GBytes);
}
extern "C" {
    pub fn fvalue_set_byte_array(fv: *mut fvalue_t, value: *mut GByteArray);
}
extern "C" {
    pub fn fvalue_set_bytes_data(
        fv: *mut fvalue_t,
        data: *const ::std::os::raw::c_void,
        size: usize,
    );
}
extern "C" {
    pub fn fvalue_set_fcwwn(fv: *mut fvalue_t, value: *const u8);
}
extern "C" {
    pub fn fvalue_set_ax25(fv: *mut fvalue_t, value: *const u8);
}
extern "C" {
    pub fn fvalue_set_vines(fv: *mut fvalue_t, value: *const u8);
}
extern "C" {
    pub fn fvalue_set_ether(fv: *mut fvalue_t, value: *const u8);
}
extern "C" {
    pub fn fvalue_set_guid(fv: *mut fvalue_t, value: *const e_guid_t);
}
extern "C" {
    pub fn fvalue_set_time(fv: *mut fvalue_t, value: *const nstime_t);
}
extern "C" {
    pub fn fvalue_set_string(fv: *mut fvalue_t, value: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fvalue_set_strbuf(fv: *mut fvalue_t, value: *mut wmem_strbuf_t);
}
extern "C" {
    pub fn fvalue_set_protocol(
        fv: *mut fvalue_t,
        value: *mut tvbuff_t,
        name: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn fvalue_set_uinteger(fv: *mut fvalue_t, value: u32);
}
extern "C" {
    pub fn fvalue_set_sinteger(fv: *mut fvalue_t, value: i32);
}
extern "C" {
    pub fn fvalue_set_uinteger64(fv: *mut fvalue_t, value: u64);
}
extern "C" {
    pub fn fvalue_set_sinteger64(fv: *mut fvalue_t, value: i64);
}
extern "C" {
    pub fn fvalue_set_floating(fv: *mut fvalue_t, value: f64);
}
extern "C" {
    pub fn fvalue_set_ipv6(fv: *mut fvalue_t, value: *const ws_in6_addr);
}
extern "C" {
    pub fn fvalue_get_bytes(fv: *mut fvalue_t) -> *mut GBytes;
}
extern "C" {
    pub fn fvalue_get_bytes_size(fv: *mut fvalue_t) -> usize;
}
extern "C" {
    pub fn fvalue_get_bytes_data(fv: *mut fvalue_t) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn fvalue_get_guid(fv: *mut fvalue_t) -> *const e_guid_t;
}
extern "C" {
    pub fn fvalue_get_time(fv: *mut fvalue_t) -> *const nstime_t;
}
extern "C" {
    pub fn fvalue_get_string(fv: *mut fvalue_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fvalue_get_strbuf(fv: *mut fvalue_t) -> *const wmem_strbuf_t;
}
extern "C" {
    pub fn fvalue_get_protocol(fv: *mut fvalue_t) -> *mut tvbuff_t;
}
extern "C" {
    pub fn fvalue_get_uinteger(fv: *mut fvalue_t) -> u32;
}
extern "C" {
    pub fn fvalue_get_sinteger(fv: *mut fvalue_t) -> i32;
}
extern "C" {
    pub fn fvalue_get_uinteger64(fv: *mut fvalue_t) -> u64;
}
extern "C" {
    pub fn fvalue_get_sinteger64(fv: *mut fvalue_t) -> i64;
}
extern "C" {
    pub fn fvalue_get_floating(fv: *mut fvalue_t) -> f64;
}
extern "C" {
    pub fn fvalue_get_ipv6(fv: *mut fvalue_t) -> *const ws_in6_addr;
}
extern "C" {
    pub fn fvalue_eq(a: *const fvalue_t, b: *const fvalue_t) -> ft_bool_t;
}
extern "C" {
    pub fn fvalue_ne(a: *const fvalue_t, b: *const fvalue_t) -> ft_bool_t;
}
extern "C" {
    pub fn fvalue_gt(a: *const fvalue_t, b: *const fvalue_t) -> ft_bool_t;
}
extern "C" {
    pub fn fvalue_ge(a: *const fvalue_t, b: *const fvalue_t) -> ft_bool_t;
}
extern "C" {
    pub fn fvalue_lt(a: *const fvalue_t, b: *const fvalue_t) -> ft_bool_t;
}
extern "C" {
    pub fn fvalue_le(a: *const fvalue_t, b: *const fvalue_t) -> ft_bool_t;
}
extern "C" {
    pub fn fvalue_contains(a: *const fvalue_t, b: *const fvalue_t) -> ft_bool_t;
}
extern "C" {
    pub fn fvalue_matches(a: *const fvalue_t, re: *const ws_regex_t) -> ft_bool_t;
}
extern "C" {
    pub fn fvalue_is_zero(a: *const fvalue_t) -> bool;
}
extern "C" {
    pub fn fvalue_is_negative(a: *const fvalue_t) -> bool;
}
extern "C" {
    pub fn fvalue_length2(fv: *mut fvalue_t) -> usize;
}
extern "C" {
    pub fn fvalue_slice(fv: *mut fvalue_t, dr: *mut drange_t) -> *mut fvalue_t;
}
extern "C" {
    pub fn fvalue_bitwise_and(
        a: *const fvalue_t,
        b: *const fvalue_t,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> *mut fvalue_t;
}
extern "C" {
    pub fn fvalue_unary_minus(
        fv: *const fvalue_t,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> *mut fvalue_t;
}
extern "C" {
    pub fn fvalue_add(
        a: *const fvalue_t,
        b: *const fvalue_t,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> *mut fvalue_t;
}
extern "C" {
    pub fn fvalue_subtract(
        a: *const fvalue_t,
        b: *const fvalue_t,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> *mut fvalue_t;
}
extern "C" {
    pub fn fvalue_multiply(
        a: *const fvalue_t,
        b: *const fvalue_t,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> *mut fvalue_t;
}
extern "C" {
    pub fn fvalue_divide(
        a: *const fvalue_t,
        b: *const fvalue_t,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> *mut fvalue_t;
}
extern "C" {
    pub fn fvalue_modulo(
        a: *const fvalue_t,
        b: *const fvalue_t,
        err_msg: *mut *mut ::std::os::raw::c_char,
    ) -> *mut fvalue_t;
}
extern "C" {
    pub fn fvalue_hash(fv: *const fvalue_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn fvalue_equal(a: *const fvalue_t, b: *const fvalue_t) -> bool;
}
pub const register_action_e_RA_NONE: register_action_e = 0;
pub const register_action_e_RA_DISSECTORS: register_action_e = 1;
pub const register_action_e_RA_LISTENERS: register_action_e = 2;
pub const register_action_e_RA_EXTCAP: register_action_e = 3;
pub const register_action_e_RA_REGISTER: register_action_e = 4;
pub const register_action_e_RA_PLUGIN_REGISTER: register_action_e = 5;
pub const register_action_e_RA_HANDOFF: register_action_e = 6;
pub const register_action_e_RA_PLUGIN_HANDOFF: register_action_e = 7;
pub const register_action_e_RA_LUA_PLUGINS: register_action_e = 8;
pub const register_action_e_RA_LUA_DEREGISTER: register_action_e = 9;
pub const register_action_e_RA_PREFERENCES: register_action_e = 10;
pub const register_action_e_RA_INTERFACES: register_action_e = 11;
pub const register_action_e_RA_PREFERENCES_APPLY: register_action_e = 12;
pub type register_action_e = ::std::os::raw::c_int;
pub type register_cb = ::std::option::Option<
    unsafe extern "C" fn(
        action: register_action_e,
        message: *const ::std::os::raw::c_char,
        client_data: gpointer,
    ),
>;
extern "C" {
    #[doc = " The header-field index for the special text pseudo-field. Exported by libwireshark.dll"]
    pub static mut hf_text_only: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct expert_field {
    _unused: [u8; 0],
}
pub type custom_fmt_func_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut gchar, arg2: guint32)>;
pub type custom_fmt_func_64_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut gchar, arg2: guint64)>;
pub type custom_fmt_func_double_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut gchar, arg2: f64)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _protocol {
    _unused: [u8; 0],
}
#[doc = " Structure for information about a protocol"]
pub type protocol_t = _protocol;
extern "C" {
    #[doc = " Function used for reporting errors in dissectors; it throws a\n DissectorError exception, with a string generated from the format\n and arguments to the format, as the message for the exception, so\n that it can show up in the Info column and the protocol tree.\n\n If the WIRESHARK_ABORT_ON_DISSECTOR_BUG environment variable is set,\n it will call abort(), instead, to make it easier to get a stack trace.\n\n @param format format string to use for the message"]
    pub fn proto_report_dissector_bug(format: *const ::std::os::raw::c_char, ...);
}
#[doc = "< none"]
pub const field_display_e_BASE_NONE: field_display_e = 0;
#[doc = "< decimal [integer, float]"]
pub const field_display_e_BASE_DEC: field_display_e = 1;
#[doc = "< hexadecimal [integer, float]"]
pub const field_display_e_BASE_HEX: field_display_e = 2;
#[doc = "< octal [integer]"]
pub const field_display_e_BASE_OCT: field_display_e = 3;
#[doc = "< decimal (hexadecimal) [integer]"]
pub const field_display_e_BASE_DEC_HEX: field_display_e = 4;
#[doc = "< hexadecimal (decimal) [integer]"]
pub const field_display_e_BASE_HEX_DEC: field_display_e = 5;
#[doc = "< call custom routine to format [integer, float]"]
pub const field_display_e_BASE_CUSTOM: field_display_e = 6;
#[doc = "< exponential [float]"]
pub const field_display_e_BASE_EXP: field_display_e = 7;
#[doc = "< hexadecimal bytes with a period (.) between each byte"]
pub const field_display_e_SEP_DOT: field_display_e = 8;
#[doc = "< hexadecimal bytes with a dash (-) between each byte"]
pub const field_display_e_SEP_DASH: field_display_e = 9;
#[doc = "< hexadecimal bytes with a colon (:) between each byte"]
pub const field_display_e_SEP_COLON: field_display_e = 10;
#[doc = "< hexadecimal bytes with a space between each byte"]
pub const field_display_e_SEP_SPACE: field_display_e = 11;
#[doc = "< Used for IPv4 address that shouldn't be resolved (like for netmasks)"]
pub const field_display_e_BASE_NETMASK: field_display_e = 12;
#[doc = "< UDP port"]
pub const field_display_e_BASE_PT_UDP: field_display_e = 13;
#[doc = "< TCP port"]
pub const field_display_e_BASE_PT_TCP: field_display_e = 14;
#[doc = "< DCCP port"]
pub const field_display_e_BASE_PT_DCCP: field_display_e = 15;
#[doc = "< SCTP port"]
pub const field_display_e_BASE_PT_SCTP: field_display_e = 16;
#[doc = "< OUI resolution"]
pub const field_display_e_BASE_OUI: field_display_e = 17;
#[doc = "< local time in our time zone, with month and day"]
pub const field_display_e_ABSOLUTE_TIME_LOCAL: field_display_e = 18;
#[doc = "< UTC, with month and day"]
pub const field_display_e_ABSOLUTE_TIME_UTC: field_display_e = 19;
#[doc = "< UTC, with 1-origin day-of-year"]
pub const field_display_e_ABSOLUTE_TIME_DOY_UTC: field_display_e = 20;
#[doc = "< UTC, with \"NULL\" when timestamp is all zeros"]
pub const field_display_e_ABSOLUTE_TIME_NTP_UTC: field_display_e = 21;
#[doc = "< Unix time"]
pub const field_display_e_ABSOLUTE_TIME_UNIX: field_display_e = 22;
#[doc = "< Replace all whitespace characters (newline, formfeed, etc) with \"space\"."]
pub const field_display_e_BASE_STR_WSP: field_display_e = 23;
pub type field_display_e = ::std::os::raw::c_int;
#[doc = "< Field is not referenced"]
pub const hf_ref_type_HF_REF_TYPE_NONE: hf_ref_type = 0;
#[doc = "< Field is indirectly referenced (only applicable for FT_PROTOCOL) via. its child"]
pub const hf_ref_type_HF_REF_TYPE_INDIRECT: hf_ref_type = 1;
#[doc = "< Field is directly referenced"]
pub const hf_ref_type_HF_REF_TYPE_DIRECT: hf_ref_type = 2;
pub type hf_ref_type = ::std::os::raw::c_int;
#[doc = " information describing a header field"]
pub type header_field_info = _header_field_info;
#[doc = " information describing a header field"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _header_field_info {
    #[doc = "< [FIELDNAME] full name of this field"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< [FIELDFILTERNAME] filter name of this field"]
    pub abbrev: *const ::std::os::raw::c_char,
    #[doc = "< [FIELDTYPE] field type, one of FT_ (from ftypes.h)"]
    pub type_: ftenum,
    #[doc = "< [FIELDDISPLAY] one of BASE_, or field bit-width if FT_BOOLEAN and non-zero bitmask"]
    pub display: ::std::os::raw::c_int,
    #[doc = "< [FIELDCONVERT] value_string, val64_string, range_string or true_false_string,\ntypically converted by VALS(), RVALS() or TFS().\nIf this is an FT_PROTOCOL or BASE_PROTOCOL_INFO then it points to the\nassociated protocol_t structure"]
    pub strings: *const ::std::os::raw::c_void,
    #[doc = "< [BITMASK] bitmask of interesting bits"]
    pub bitmask: guint64,
    #[doc = "< [FIELDDESCR] Brief description of field"]
    pub blurb: *const ::std::os::raw::c_char,
    #[doc = "< Field ID"]
    pub id: ::std::os::raw::c_int,
    #[doc = "< parent protocol tree"]
    pub parent: ::std::os::raw::c_int,
    #[doc = "< is this field referenced by a filter"]
    pub ref_type: hf_ref_type,
    #[doc = "< ID of previous hfinfo with same abbrev"]
    pub same_name_prev_id: ::std::os::raw::c_int,
    #[doc = "< Link to next hfinfo with same abbrev"]
    pub same_name_next: *mut header_field_info,
}
#[test]
fn bindgen_test_layout__header_field_info() {
    const UNINIT: ::std::mem::MaybeUninit<_header_field_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_header_field_info>(),
        72usize,
        concat!("Size of: ", stringify!(_header_field_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_header_field_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_header_field_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abbrev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(abbrev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strings) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(strings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitmask) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(bitmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blurb) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(blurb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_type) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(ref_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).same_name_prev_id) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(same_name_prev_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).same_name_next) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(same_name_next)
        )
    );
}
#[doc = " Used when registering many fields at once, using proto_register_field_array()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hf_register_info {
    #[doc = "< written to by register() function"]
    pub p_id: *mut ::std::os::raw::c_int,
    #[doc = "< the field info to be registered"]
    pub hfinfo: header_field_info,
}
#[test]
fn bindgen_test_layout_hf_register_info() {
    const UNINIT: ::std::mem::MaybeUninit<hf_register_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hf_register_info>(),
        80usize,
        concat!("Size of: ", stringify!(hf_register_info))
    );
    assert_eq!(
        ::std::mem::align_of::<hf_register_info>(),
        8usize,
        concat!("Alignment of ", stringify!(hf_register_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hf_register_info),
            "::",
            stringify!(p_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hfinfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hf_register_info),
            "::",
            stringify!(hfinfo)
        )
    );
}
#[doc = " string representation, if one of the proto_tree_add_..._format() functions used"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _item_label_t {
    pub representation: [::std::os::raw::c_char; 240usize],
}
#[test]
fn bindgen_test_layout__item_label_t() {
    const UNINIT: ::std::mem::MaybeUninit<_item_label_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_item_label_t>(),
        240usize,
        concat!("Size of: ", stringify!(_item_label_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_item_label_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_item_label_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).representation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_item_label_t),
            "::",
            stringify!(representation)
        )
    );
}
#[doc = " string representation, if one of the proto_tree_add_..._format() functions used"]
pub type item_label_t = _item_label_t;
#[doc = " Contains the field information for the proto_item."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct field_info {
    #[doc = "< pointer to registered field information"]
    pub hfinfo: *mut header_field_info,
    #[doc = "< current start of data in field_info.ds_tvb"]
    pub start: gint,
    #[doc = "< current data length of item in field_info.ds_tvb"]
    pub length: gint,
    #[doc = "< start of appendix data"]
    pub appendix_start: gint,
    #[doc = "< length of appendix data"]
    pub appendix_length: gint,
    #[doc = "< one of ETT_ or -1"]
    pub tree_type: gint,
    #[doc = "< bitfield like FI_GENERATED, ..."]
    pub flags: guint32,
    #[doc = "< string for GUI tree"]
    pub rep: *mut item_label_t,
    #[doc = "< data source tvbuff"]
    pub ds_tvb: *mut tvbuff_t,
    pub value: *mut fvalue_t,
    #[doc = "< Hierarchical layer number, for all protocols in the tree."]
    pub total_layer_num: ::std::os::raw::c_int,
    #[doc = "< Protocol layer number, so 1st, 2nd, 3rd, ... for protocol X."]
    pub proto_layer_num: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_field_info() {
    const UNINIT: ::std::mem::MaybeUninit<field_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<field_info>(),
        64usize,
        concat!("Size of: ", stringify!(field_info))
    );
    assert_eq!(
        ::std::mem::align_of::<field_info>(),
        8usize,
        concat!("Alignment of ", stringify!(field_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hfinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(field_info),
            "::",
            stringify!(hfinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(field_info),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(field_info),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appendix_start) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(field_info),
            "::",
            stringify!(appendix_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appendix_length) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(field_info),
            "::",
            stringify!(appendix_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tree_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(field_info),
            "::",
            stringify!(tree_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(field_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(field_info),
            "::",
            stringify!(rep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ds_tvb) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(field_info),
            "::",
            stringify!(ds_tvb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(field_info),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_layer_num) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(field_info),
            "::",
            stringify!(total_layer_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proto_layer_num) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(field_info),
            "::",
            stringify!(proto_layer_num)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crumb_spec_t {
    pub crumb_bit_offset: guint,
    pub crumb_bit_length: guint8,
}
#[test]
fn bindgen_test_layout_crumb_spec_t() {
    const UNINIT: ::std::mem::MaybeUninit<crumb_spec_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<crumb_spec_t>(),
        8usize,
        concat!("Size of: ", stringify!(crumb_spec_t))
    );
    assert_eq!(
        ::std::mem::align_of::<crumb_spec_t>(),
        4usize,
        concat!("Alignment of ", stringify!(crumb_spec_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crumb_bit_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crumb_spec_t),
            "::",
            stringify!(crumb_bit_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crumb_bit_length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(crumb_spec_t),
            "::",
            stringify!(crumb_bit_length)
        )
    );
}
#[doc = " One of these exists for the entire protocol tree. Each proto_node\n in the protocol tree points to the same copy."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tree_data_t {
    pub interesting_hfids: *mut GHashTable,
    pub visible: gboolean,
    pub fake_protocols: gboolean,
    pub count: guint,
    pub pinfo: *mut _packet_info,
}
#[test]
fn bindgen_test_layout_tree_data_t() {
    const UNINIT: ::std::mem::MaybeUninit<tree_data_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tree_data_t>(),
        32usize,
        concat!("Size of: ", stringify!(tree_data_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tree_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(tree_data_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interesting_hfids) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tree_data_t),
            "::",
            stringify!(interesting_hfids)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).visible) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tree_data_t),
            "::",
            stringify!(visible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fake_protocols) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tree_data_t),
            "::",
            stringify!(fake_protocols)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tree_data_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pinfo) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tree_data_t),
            "::",
            stringify!(pinfo)
        )
    );
}
#[doc = " Each proto_tree, proto_item is one of these."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _proto_node {
    pub first_child: *mut _proto_node,
    pub last_child: *mut _proto_node,
    pub next: *mut _proto_node,
    pub parent: *mut _proto_node,
    pub finfo: *mut field_info,
    pub tree_data: *mut tree_data_t,
}
#[test]
fn bindgen_test_layout__proto_node() {
    const UNINIT: ::std::mem::MaybeUninit<_proto_node> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_proto_node>(),
        48usize,
        concat!("Size of: ", stringify!(_proto_node))
    );
    assert_eq!(
        ::std::mem::align_of::<_proto_node>(),
        8usize,
        concat!("Alignment of ", stringify!(_proto_node))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_child) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_proto_node),
            "::",
            stringify!(first_child)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_child) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_proto_node),
            "::",
            stringify!(last_child)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_proto_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_proto_node),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finfo) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_proto_node),
            "::",
            stringify!(finfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tree_data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_proto_node),
            "::",
            stringify!(tree_data)
        )
    );
}
#[doc = " Each proto_tree, proto_item is one of these."]
pub type proto_node = _proto_node;
#[doc = " A protocol tree element."]
pub type proto_tree = proto_node;
#[doc = " A protocol item element."]
pub type proto_item = proto_node;
pub type proto_tree_foreach_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut proto_node, arg2: gpointer)>;
pub type proto_tree_traverse_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut proto_node, arg2: gpointer) -> gboolean>;
extern "C" {
    pub fn proto_tree_children_foreach(
        tree: *mut proto_tree,
        func: proto_tree_foreach_func,
        data: gpointer,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proto_plugin {
    pub register_protoinfo: ::std::option::Option<unsafe extern "C" fn()>,
    pub register_handoff: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_proto_plugin() {
    const UNINIT: ::std::mem::MaybeUninit<proto_plugin> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<proto_plugin>(),
        16usize,
        concat!("Size of: ", stringify!(proto_plugin))
    );
    assert_eq!(
        ::std::mem::align_of::<proto_plugin>(),
        8usize,
        concat!("Alignment of ", stringify!(proto_plugin))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_protoinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_plugin),
            "::",
            stringify!(register_protoinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_handoff) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_plugin),
            "::",
            stringify!(register_handoff)
        )
    );
}
extern "C" {
    #[doc = " Register dissector plugin with the plugin system."]
    pub fn proto_register_plugin(plugin: *const proto_plugin);
}
extern "C" {
    #[doc = " Sets up memory used by proto routines. Called at program startup"]
    pub fn proto_init(
        register_all_plugin_protocols_list: *mut GSList,
        register_all_plugin_handoffs_list: *mut GSList,
        cb: register_cb,
        client_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Frees memory used by proto routines. Called at program shutdown"]
    pub fn proto_cleanup();
}
extern "C" {
    #[doc = " This function takes a tree and a protocol id as parameter and\nwill return TRUE/FALSE for whether the protocol or any of the filterable\nfields in the protocol is referenced by any fitlers.\nIf this function returns FALSE then it is safe to skip any\nproto_tree_add_...() calls and just treat the call as if the\ndissector was called with tree==NULL.\nIf you reset the tree to NULL by this dissector returning FALSE,\nyou will still need to call any subdissector with the original value of\ntree or filtering will break.\n\nThe purpose of this is to optimize wireshark for speed and make it\nfaster for when filters are being used."]
    pub fn proto_field_is_referenced(
        tree: *mut proto_tree,
        proto_id: ::std::os::raw::c_int,
    ) -> gboolean;
}
extern "C" {
    #[doc = " Create a subtree under an existing item.\n@param pi the parent item of the new subtree\n@param idx one of the ett_ array elements registered with proto_register_subtree_array()\n@return the new subtree"]
    pub fn proto_item_add_subtree(pi: *mut proto_item, idx: gint) -> *mut proto_tree;
}
extern "C" {
    #[doc = " Get an existing subtree under an item.\n@param pi the parent item of the subtree\n@return the subtree or NULL"]
    pub fn proto_item_get_subtree(pi: *mut proto_item) -> *mut proto_tree;
}
extern "C" {
    #[doc = " Get the parent of a subtree item.\n@param pi the child item in the subtree\n@return parent item or NULL"]
    pub fn proto_item_get_parent(pi: *const proto_item) -> *mut proto_item;
}
extern "C" {
    #[doc = " Get Nth generation parent item.\n@param pi the child item in the subtree\n@param gen the generation to get (using 1 here is the same as using proto_item_get_parent())\n@return parent item"]
    pub fn proto_item_get_parent_nth(
        pi: *mut proto_item,
        gen: ::std::os::raw::c_int,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Replace text of item after it already has been created.\n@param pi the item to set the text\n@param format printf like format string\n@param ... printf like parameters"]
    pub fn proto_item_set_text(pi: *mut proto_item, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Append to text of item after it has already been created.\n@param pi the item to append the text to\n@param format printf like format string\n@param ... printf like parameters"]
    pub fn proto_item_append_text(pi: *mut proto_item, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Prepend to text of item after it has already been created.\n@param pi the item to prepend the text to\n@param format printf like format string\n@param ... printf like parameters"]
    pub fn proto_item_prepend_text(pi: *mut proto_item, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Set proto_item's length inside tvb, after it has already been created.\n@param pi the item to set the length\n@param length the new length of the item"]
    pub fn proto_item_set_len(pi: *mut proto_item, length: gint);
}
extern "C" {
    #[doc = " Sets the length of the item based on its start and on the specified\n offset, which is the offset past the end of the item; as the start\n in the item is relative to the beginning of the data source tvbuff,\n we need to pass in a tvbuff.\n\n Given an item created as:\n      ti = proto_tree_add_item(*, *, tvb, offset, -1, *);\n then\n      proto_item_set_end(ti, tvb, end);\n is equivalent to\n      proto_item_set_len(ti, end - offset);\n\n@param pi the item to set the length\n@param tvb end is relative to this tvbuff\n@param end this end offset is relative to the beginning of tvb\n@todo make usage clearer, I don't understand it!"]
    pub fn proto_item_set_end(pi: *mut proto_item, tvb: *mut tvbuff_t, end: gint);
}
extern "C" {
    #[doc = " Get length of a proto_item. Useful after using proto_tree_add_item()\n to add a variable-length field (e.g., FT_UINT_STRING).\n@param pi the item to get the length from\n@return the current length"]
    pub fn proto_item_get_len(pi: *const proto_item) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the bit offset and length for the specified proto_item.\n @param ti The item to set.\n @param bits_offset The number of bits from the beginning of the field.\n @param bits_len The new length in bits."]
    pub fn proto_item_set_bits_offset_len(
        ti: *mut proto_item,
        bits_offset: ::std::os::raw::c_int,
        bits_len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Get the display representation of a proto_item.\n Can be used, for example, to append that to the parent item of\n that item.\n@param scope the wmem scope to use to allocate the string\n@param pi the item from which to get the display representation\n@return the display representation"]
    pub fn proto_item_get_display_repr(
        scope: *mut wmem_allocator_t,
        pi: *mut proto_item,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Creates a new proto_tree root.\n@return the new tree root"]
    pub fn proto_tree_create_root(pinfo: *mut _packet_info) -> *mut proto_tree;
}
extern "C" {
    pub fn proto_tree_reset(tree: *mut proto_tree);
}
extern "C" {
    #[doc = " Clear memory for entry proto_tree. Clears proto_tree struct also.\n@param tree the tree to free"]
    pub fn proto_tree_free(tree: *mut proto_tree);
}
extern "C" {
    #[doc = " Set the tree visible or invisible.\nIs the parsing being done for a visible proto_tree or an invisible one?\nBy setting this correctly, the proto_tree creation is sped up by not\nhaving to call vsnprintf and copy strings around.\n@param tree the tree to be set\n@param visible ... or not\n@return the old value"]
    pub fn proto_tree_set_visible(tree: *mut proto_tree, visible: gboolean) -> gboolean;
}
extern "C" {
    #[doc = " Indicate whether we should fake protocols during dissection (default = TRUE)\n@param tree the tree to be set\n@param fake_protocols TRUE if we should fake protocols"]
    pub fn proto_tree_set_fake_protocols(tree: *mut proto_tree, fake_protocols: gboolean);
}
extern "C" {
    #[doc = " Mark a field/protocol ID as \"interesting\".\n@param tree the tree to be set (currently ignored)\n@param hfid the interesting field id\n@todo what *does* interesting mean?"]
    pub fn proto_tree_prime_with_hfid(tree: *mut proto_tree, hfid: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Get a parent item of a subtree.\n@param tree the tree to get the parent from\n@return parent item"]
    pub fn proto_tree_get_parent(tree: *mut proto_tree) -> *mut proto_item;
}
extern "C" {
    #[doc = " Get the parent tree of a subtree.\n@param tree the tree to get the parent from\n@return parent tree"]
    pub fn proto_tree_get_parent_tree(tree: *mut proto_tree) -> *mut proto_tree;
}
extern "C" {
    #[doc = " Get the root tree from any subtree.\n@param tree the tree to get the root from\n@return root tree"]
    pub fn proto_tree_get_root(tree: *mut proto_tree) -> *mut proto_tree;
}
extern "C" {
    #[doc = " Move an existing item behind another existing item.\n@param tree the tree to which both items belong\n@param fixed_item the item which keeps its position\n@param item_to_move the item which will be moved"]
    pub fn proto_tree_move_item(
        tree: *mut proto_tree,
        fixed_item: *mut proto_item,
        item_to_move: *mut proto_item,
    );
}
extern "C" {
    #[doc = " Set start and length of an appendix for a proto_tree.\n@param tree the tree to set the appendix start and length\n@param tvb the tv buffer of the current data\n@param start the start offset of the appendix\n@param length the length of the appendix"]
    pub fn proto_tree_set_appendix(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
    );
}
extern "C" {
    #[doc = " Add an item to a proto_tree, using the text label registered to that item.\nThe item is extracted from the tvbuff handed to it.\n@param tree the tree to append this item to\n@param hfinfo field\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param encoding data encoding\n@return the newly created item"]
    pub fn proto_tree_add_item_new(
        tree: *mut proto_tree,
        hfinfo: *mut header_field_info,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
    ) -> *mut proto_item;
}
extern "C" {
    pub fn proto_tree_add_item(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an item to a proto_tree, using the text label registered to that item.\nThe item is extracted from the tvbuff handed to it.\n\nReturn the length of the item through the pointer.\n@param tree the tree to append this item to\n@param hfinfo field\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param encoding data encoding\n@param[out] lenretval points to a gint that will be set to the item length\n@return the newly created item, and *lenretval is set to the item length"]
    pub fn proto_tree_add_item_new_ret_length(
        tree: *mut proto_tree,
        hfinfo: *mut header_field_info,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        lenretval: *mut gint,
    ) -> *mut proto_item;
}
extern "C" {
    pub fn proto_tree_add_item_ret_length(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        lenretval: *mut gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an integer data item to a proto_tree, using the text label registered to that item.\nThe item is extracted from the tvbuff handed to it, and the retrieved\nvalue is also set to *retval so the caller gets it back for other uses.\n\nThis function retrieves the value even if the passed-in tree param is NULL,\nso that it can be used by dissectors at all times to both get the value\nand set the tree item to it.\n\nLike other proto_tree_add functions, if there is a tree and the value cannot\nbe decoded from the tvbuff, then an expert info error is reported.\n\nThis function accepts ENC_LITTLE_ENDIAN and ENC_BIG_ENDIAN for native number\nencoding in the tvbuff\n\nThe length argument must\nbe set to the appropriate size of the native type as in other proto_add routines.\n\nIntegers of 8, 16, 24 and 32 bits can be retrieved with the _ret_int and\nret_uint functions; integers of 40, 48, 56, and 64 bits can be retrieved\nwith the _ret_uint64 function; Boolean values of 8, 16, 24, 32, 40, 48,\n56, and 64 bits can be retrieved with the _ret_boolean function.\n\n@param tree the tree to append this item to\n@param hfindex field\n@param tvb the tv buffer of the current data\n@param start start of data in tvb (cannot be negative)\n@param length length of data in tvb (for strings can be -1 for remaining)\n@param encoding data encoding (e.g, ENC_LITTLE_ENDIAN, ENC_BIG_ENDIAN, ENC_ASCII|ENC_STRING, etc.)\n@param[out] retval points to a gint32 or guint32 which will be set to the value\n@return the newly created item, and *retval is set to the decoded value masked/shifted according to bitmask"]
    pub fn proto_tree_add_item_ret_int(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut gint32,
    ) -> *mut proto_item;
}
extern "C" {
    pub fn proto_tree_add_item_ret_int64(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut gint64,
    ) -> *mut proto_item;
}
extern "C" {
    pub fn proto_tree_add_item_ret_uint(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut guint32,
    ) -> *mut proto_item;
}
extern "C" {
    pub fn proto_tree_add_item_ret_uint64(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut guint64,
    ) -> *mut proto_item;
}
extern "C" {
    pub fn proto_tree_add_item_ret_varint(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut guint64,
        lenretval: *mut gint,
    ) -> *mut proto_item;
}
extern "C" {
    pub fn proto_tree_add_item_ret_boolean(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut gboolean,
    ) -> *mut proto_item;
}
extern "C" {
    pub fn proto_tree_add_item_ret_ipv4(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut ws_in4_addr,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " @brief Parse an ipv6 address from the buffer and add it to the tree,\n writing the value to the pointer specified by the caller. The pointer\n must not be null.\n\n @param tree the tree\n @param hfindex the field\n @param tvb the tv buffer\n @param start the start index of data in tvb\n @param length the length of data. calls REPORT_DISSECTOR_BUG if not equal to FT_IPv6_LEN\n @param encoding encodings not yet supported. calls REPORT_DISSECTOR_BUG if not equal to 0\n @param retval where the address should be written, must not be null\n @return the newly created item"]
    pub fn proto_tree_add_item_ret_ipv6(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut ws_in6_addr,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " @brief Parse an ethernet address from the buffer and add it to the tree,\n writing the value to the pointer specified by the caller. The pointer\n must not be null.\n\n @param tree the tree\n @param hfindex the field\n @param tvb the tv buffer\n @param start the start index of data in tvb\n @param length the length of data. calls REPORT_DISSECTOR_BUG if not equal to FT_ETHER_LEN\n @param encoding encodings not yet supported. calls REPORT_DISSECTOR_BUG if not equal to 0\n @param retval a buffer of at least FT_ETHER_LEN bytes for the address, must not be null\n @return the newly created item"]
    pub fn proto_tree_add_item_ret_ether(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut guint8,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " @brief Parse a float from the buffer and add it to the tree,\n returning the item added and the parsed value via retval.\n\n @param tree the tree\n @param hfindex the field\n @param tvb the tv buffer\n @param start start index of data in tvb\n @param length the length of data. calls REPORT_DISSECTOR_BUG if not equal to 4\n @param encoding ENC_LITTLE_ENDIAN or ENC_BIG_ENDIAN\n @param[out] retval for the decoded value\n @return the newly created item"]
    pub fn proto_tree_add_item_ret_float(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut gfloat,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " @brief Parse a double from the buffer and add it to the tree,\n returning the item added and the parsed value via retval\n\n @param tree the tree\n @param hfindex the field\n @param tvb the tv buffer\n @param start start index of data in tvb\n @param length length of data. calls REPORT_DISSECTOR_BUG if not equal to 8\n @param encoding ENC_LITTLE_ENDIAN or ENC_BIG_ENDIAN\n @param[out] retval for the decoded value\n @return the newly created item and retval is set to the decoded value"]
    pub fn proto_tree_add_item_ret_double(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut gdouble,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an string item to a proto_tree, using the text label registered to\nthat item.\n\nThe item is extracted from the tvbuff handed to it, and the retrieved\nvalue and its length are returned through pointers so the caller can use\nthem.  The value is allocated using the wmem scope passed in.\n\nThis function retrieves the value and length even if the passed-in tree\nparam is NULL, so that then can be used by dissectors at all times to\nboth get the value and set the tree item to it.\n\nLike other proto_tree_add functions, if there is a tree and the value cannot\nbe decoded from the tvbuff, then an expert info error is reported.\n\nThis function accepts string encodings.\n\n@param scope the wmem scope to use to allocate the string\n@param tree the tree to append this item to\n@param hfindex field\n@param tvb the tv buffer of the current data\n@param start start of data in tvb (cannot be negative)\n@param length length of data in tvb (for strings can be -1 for remaining)\n@param encoding data encoding (e.g, ENC_ASCII, ENC_UTF_8, etc.)\n@param[out] retval points to a guint8 * that will be set to point to the\nstring value\n@param[out] lenretval points to a gint that will be set to the item length\n@return the newly created item, *retval is set to the decoded value,\nand *lenretval is set to the item length"]
    pub fn proto_tree_add_item_ret_string_and_length(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        scope: *mut wmem_allocator_t,
        retval: *mut *const guint8,
        lenretval: *mut gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an string item to a proto_tree, using the text label registered to\nthat item.\n\nThe item is extracted from the tvbuff handed to it, and the retrieved\nvalue is returned through a pointer so the caller can use it.  The value\nis allocated using the wmem scope passed in.\n\nThis function retrieves the value even if the passed-in tree param is NULL,\nso that it can be used by dissectors at all times to both get the value\nand set the tree item to it.\n\nLike other proto_tree_add functions, if there is a tree and the value cannot\nbe decoded from the tvbuff, then an expert info error is reported.\n\nThis function accepts string encodings.\n\n@param scope the wmem scope to use to allocate the string\n@param tree the tree to append this item to\n@param hfindex field\n@param tvb the tv buffer of the current data\n@param start start of data in tvb (cannot be negative)\n@param length length of data in tvb (for strings can be -1 for remaining)\n@param encoding data encoding (e.g, ENC_ASCII, ENC_UTF_8, etc.)\n@param[out] retval points to a guint8 * that will be set to point to the\nstring value\n@return the newly created item, and *retval is set to the decoded value"]
    pub fn proto_tree_add_item_ret_string(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        scope: *mut wmem_allocator_t,
        retval: *mut *const guint8,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an string or byte array item to a proto_tree, using the\ntext label registered to that item.\n\nThis provides a string that is a display representation of the value,\nand the length of the item, similar to what\nproto_tree_add_item_ret_string_and_length() does.\n\n@param scope the wmem scope to use to allocate the string\n@param tree the tree to append this item to\n@param hfindex field\n@param tvb the tv buffer of the current data\n@param start start of data in tvb (cannot be negative)\n@param length length of data in tvb (for strings can be -1 for remaining)\n@param encoding data encoding (e.g, ENC_ASCII, ENC_UTF_8, etc.)\n@param[out] retval points to a guint8 * that will be set to point to the\nstring value\n@param[out] lenretval points to a gint that will be set to the item length\n@return the newly created item, *retval is set to the display string,\nand *lenretval is set to the item length"]
    pub fn proto_tree_add_item_ret_display_string_and_length(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        scope: *mut wmem_allocator_t,
        retval: *mut *mut ::std::os::raw::c_char,
        lenretval: *mut gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an string or byte array item to a proto_tree, using the\ntext label registered to that item.\n\nThis provides a string that is a display representation of the value,\nsimilar to what proto_tree_add_item_ret_string() does.\n\n@param tree the tree to append this item to\n@param hfindex field\n@param tvb the tv buffer of the current data\n@param start start of data in tvb (cannot be negative)\n@param length length of data in tvb (for strings can be -1 for remaining)\n@param encoding data encoding (e.g, ENC_ASCII, ENC_UTF_8, etc.)\n@param scope the wmem scope to use to allocate the string\n@param[out] retval points to a guint8 * that will be set to point to the\nstring value\n@return the newly created item, *retval is set to the display string"]
    pub fn proto_tree_add_item_ret_display_string(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        scope: *mut wmem_allocator_t,
        retval: *mut *mut ::std::os::raw::c_char,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a time item to a proto_tree, using thetext label registered to that item.\n\nThis provides a string that is a display representation of the time value\n\n@param tree the tree to append this item to\n@param hfindex field\n@param tvb the tv buffer of the current data\n@param start start of data in tvb (cannot be negative)\n@param length length of data in tvb (for strings can be -1 for remaining)\n@param encoding data encoding (e.g, ENC_ASCII, ENC_UTF_8, etc.)\n@param scope the wmem scope to use to allocate the string\n@param[out] retval points to a guint8 * that will be set to point to the\nstring value\n@return the newly created item, *retval is set to the display string"]
    pub fn proto_tree_add_item_ret_time_string(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        scope: *mut wmem_allocator_t,
        retval: *mut *mut ::std::os::raw::c_char,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " (INTERNAL USE ONLY) Add a text-only node to a proto_tree.\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_text_internal(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " (INTERNAL USE ONLY) Add a text-only node to a proto_tree using a variable argument list.\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param format printf like format string\n@param ap variable argument list\n@return the newly created item"]
    pub fn proto_tree_add_text_valist_internal(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        format: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a text-only node that creates a subtree underneath.\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param idx one of the ett_ array elements registered with proto_register_subtree_array()\n@param tree_item item returned with tree creation. Can be NULL if going to be unused\n@param text label for the tree\n@return the newly created tree"]
    pub fn proto_tree_add_subtree(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        idx: gint,
        tree_item: *mut *mut proto_item,
        text: *const ::std::os::raw::c_char,
    ) -> *mut proto_tree;
}
extern "C" {
    #[doc = " Add a text-only node that creates a subtree underneath.\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param idx one of the ett_ array elements registered with proto_register_subtree_array()\n@param tree_item item returned with tree creation. Can be NULL if going to be unused\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created tree"]
    pub fn proto_tree_add_subtree_format(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        idx: gint,
        tree_item: *mut *mut proto_item,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_tree;
}
extern "C" {
    #[doc = " Add a text-only node to a proto_tree with tvb_format_text() string."]
    pub fn proto_tree_add_format_text(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a text-only node to a proto_tree with tvb_format_text_wsp() string."]
    pub fn proto_tree_add_format_wsp_text(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_NONE field to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_none_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_PROTOCOL to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_protocol_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_BYTES to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param start_ptr pointer to the data to display\n@return the newly created item"]
    pub fn proto_tree_add_bytes(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        start_ptr: *const guint8,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_BYTES to a proto_tree like proto_tree_add_bytes,\nbut used when the tvb data length does not match the bytes length.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param start_ptr pointer to the data to display\n@param ptr_length length of data in start_ptr\n@return the newly created item"]
    pub fn proto_tree_add_bytes_with_length(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        start_ptr: *const guint8,
        ptr_length: gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Get and add a byte-array-based FT_* to a proto_tree.\n\nSupported: FT_BYTES, FT_UINT_BYTES, FT_OID, FT_REL_OID, and FT_SYSTEM_ID.\n\nThe item is extracted from the tvbuff handed to it, based on the ENC_* passed\nin for the encoding, and the retrieved byte array is also set to *retval so the\ncaller gets it back for other uses.\n\nThis function retrieves the value even if the passed-in tree param is NULL,\nso that it can be used by dissectors at all times to both get the value\nand set the tree item to it.\n\nLike other proto_tree_add functions, if there is a tree and the value cannot\nbe decoded from the tvbuff, then an expert info error is reported. For string\nencoding, this means that a failure to decode the hex value from the string\nresults in an expert info error being added to the tree.\n\nIf encoding is string-based, it will convert using tvb_get_string_bytes(); see\nthat function's comments for details.\n\n@note The GByteArray retval must be pre-constructed using g_byte_array_new().\n\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param encoding data encoding (e.g, ENC_LITTLE_ENDIAN, or ENC_UTF_8|ENC_STR_HEX)\n@param[in,out] retval points to a GByteArray which will be set to the bytes from the Tvb.\n@param[in,out] endoff if not NULL, gets set to the character after those consumed.\n@param[in,out] err if not NULL, gets set to 0 if no failure, else the errno code (e.g., EINVAL).\n@return the newly created item, and retval is set to the decoded value"]
    pub fn proto_tree_add_bytes_item(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut GByteArray,
        endoff: *mut gint,
        err: *mut gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_BYTES to a proto_tree, with the format generating\nthe string for the value and with the field name being included\nautomatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param start_ptr pointer to the data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_bytes_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        start_ptr: *const guint8,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_BYTES to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param start_ptr pointer to the data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_bytes_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        start_ptr: *const guint8,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_ABSOLUTE_TIME or FT_RELATIVE_TIME to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value_ptr pointer to the data to display\n@return the newly created item"]
    pub fn proto_tree_add_time(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const nstime_t,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Get and add a FT_ABSOLUTE_TIME or FT_RELATIVE_TIME to a proto_tree.\nThe item is extracted from the tvbuff handed to it, based on the ENC_* passed\nin for the encoding, and the retrieved value is also set to *retval so the\ncaller gets it back for other uses.\n\nThis function retrieves the value even if the passed-in tree param is NULL,\nso that it can be used by dissectors at all times to both get the value\nand set the tree item to it.\n\nLike other proto_tree_add functions, if there is a tree and the value cannot\nbe decoded from the tvbuff, then an expert info error is reported. For string\nencoding, this means that a failure to decode the time value from the string\nresults in an expert info error being added to the tree.\n\nIf encoding is string-based, it will convert using tvb_get_string_time(); see\nthat function's comments for details.\n\n@note The nstime_t *retval must be pre-allocated as a nstime_t.\n\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param encoding data encoding (e.g, ENC_LITTLE_ENDIAN, ENC_UTF_8|ENC_ISO_8601_DATE_TIME, etc.)\n@param[in,out] retval points to a nstime_t which will be set to the value\n@param[in,out] endoff if not NULL, gets set to the character after those consumed.\n@param[in,out] err if not NULL, gets set to 0 if no failure, else EINVAL.\n@return the newly created item, and retval is set to the decoded value"]
    pub fn proto_tree_add_time_item(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut nstime_t,
        endoff: *mut gint,
        err: *mut gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_ABSOLUTE_TIME or FT_RELATIVE_TIME to a proto_tree, with\nthe format generating the string for the value and with the field name\nbeing included automatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value_ptr pointer to the data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_time_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *mut nstime_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_ABSOLUTE_TIME or FT_RELATIVE_TIME to a proto_tree, with\nthe format generating the entire string for the entry, including any field\nname.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value_ptr pointer to the data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_time_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *mut nstime_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_IPXNET to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_ipxnet(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_IPXNET to a proto_tree, with the format generating\nthe string for the value and with the field name being included\nautomatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_ipxnet_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_IPXNET to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_ipxnet_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_IPv4 to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_ipv4(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: ws_in4_addr,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_IPv4 to a proto_tree, with the format generating\nthe string for the value and with the field name being included\nautomatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_ipv4_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: ws_in4_addr,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_IPv4 to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_ipv4_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: ws_in4_addr,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_IPv6 to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value_ptr data to display\n@return the newly created item"]
    pub fn proto_tree_add_ipv6(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const ws_in6_addr,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_IPv6 to a proto_tree, with the format generating\nthe string for the value and with the field name being included\nautomatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value_ptr data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_ipv6_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const ws_in6_addr,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_IPv6 to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value_ptr data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_ipv6_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const ws_in6_addr,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_ETHER to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_ether(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: *const guint8,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_ETHER to a proto_tree, with the format generating\nthe string for the value and with the field name being included\nautomatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_ether_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: *const guint8,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_ETHER to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_ether_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: *const guint8,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_GUID to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value_ptr data to display\n@return the newly created item"]
    pub fn proto_tree_add_guid(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const e_guid_t,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_GUID to a proto_tree, with the format generating\nthe string for the value and with the field name being included\nautomatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value_ptr data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_guid_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const e_guid_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_GUID to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value_ptr data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_guid_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const e_guid_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_OID to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value_ptr data to display\n@return the newly created item"]
    pub fn proto_tree_add_oid(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const guint8,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_OID to a proto_tree, with the format generating\nthe string for the value and with the field name being included\nautomatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value_ptr data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_oid_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const guint8,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_OID to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value_ptr data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_oid_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const guint8,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an FT_STRING, FT_STRINGZ, FT_STRINGZPAD, or FT_STRINGZTRUNC to a\nproto_tree. The value passed in should be a UTF-8 encoded null terminated\nstring, such as produced by tvb_get_string_enc(), regardless of the original\npacket data.\n\nThis function is used to add a custom string *value* to the protocol tree.\nDo not format the string value for display, for example by using format_text().\nThe input string represents packet data, not a display label. Formatting\nlabels is a concern of the UI. Doing that here would change the meaning of the packet\ndata, restrict the options for formatting later and make display filtering unintuitive\nfor whitespace and other special characters.\n\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_string(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: *const ::std::os::raw::c_char,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_STRING, FT_STRINGZ, FT_STRINGZPAD, or FT_STRINGZTRUNC\nto a proto_tree, with the format generating the string for the value\nand with the field name being included automatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_string_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_STRING, FT_STRINGZ, FT_STRINGZPAD, or FT_STRINGZTRUNC\nto a proto_tree, with the format generating the entire string for the\nentry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_string_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_BOOLEAN to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_boolean(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_BOOLEAN to a proto_tree, with the format generating\nthe string for the value and with the field name being included\nautomatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_boolean_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_BOOLEAN to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_boolean_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_FLOAT to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_float(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: f32,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_FLOAT to a proto_tree, with the format generating\nthe string for the value and with the field name being included\nautomatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_float_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: f32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_FLOAT to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_float_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: f32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_DOUBLE to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_double(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: f64,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_DOUBLE to a proto_tree, with the format generating\nthe string for the value and with the field name being included\nautomatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_double_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: f64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_DOUBLE to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_double_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: f64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add one of FT_UINT8, FT_UINT16, FT_UINT24 or FT_UINT32 to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_uint(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_UINT8, FT_UINT16, FT_UINT24 or FT_UINT32 to a proto_tree,\nwith the format generating the string for the value and with the field\nname being included automatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_uint_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_UINT8, FT_UINT16, FT_UINT24 or FT_UINT32 to a proto_tree,\nwith the format generating the entire string for the entry, including any\nfield name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_uint_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an FT_UINT64 to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_uint64(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint64,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_UINT64 to a proto_tree, with the format generating\nthe string for the value and with the field name being included\nautomatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_uint64_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_UINT64 to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_uint64_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add one of FT_INT8, FT_INT16, FT_INT24 or FT_INT32 to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_int(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: gint32,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_INT8, FT_INT16, FT_INT24 or FT_INT32 to a proto_tree,\nwith the format generating the string for the value and with the field\nname being included automatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_int_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: gint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_INT8, FT_INT16, FT_INT24 or FT_INT32 to a proto_tree,\nwith the format generating the entire string for the entry, including\nany field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_int_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: gint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an FT_INT64 to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_int64(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: gint64,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_INT64 to a proto_tree, with the format generating\nthe string for the value and with the field name being included\nautomatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_int64_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: gint64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_INT64 to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_int64_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: gint64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_EUI64 to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_eui64(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint64,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_EUI64 to a proto_tree, with the format generating\nthe string for the value and with the field name being included\nautomatically.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_eui64_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_EUI64 to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_eui64_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Useful for quick debugging. Also sends string to STDOUT, so don't\nleave call to this function in production code.\n@param tree the tree to append the text to\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_debug_text(
        tree: *mut proto_tree,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Fill given label_str with a simple string representation of field.\n@param finfo the item to get the info from\n@param label_str the string to fill\n@todo think about changing the parameter profile"]
    pub fn proto_item_fill_label(finfo: *mut field_info, label_str: *mut gchar);
}
extern "C" {
    #[doc = " Fill the given display_label_str with the string representation of a field\n formatted according to its type and field display specifier.\n Used to display custom columns and packet diagram values.\n@param fi The item to get the info from\n@param display_label_str The string to fill\n@return The length of the label excluding the terminating '\\0'."]
    pub fn proto_item_fill_display_label(
        fi: *mut field_info,
        display_label_str: *mut gchar,
        label_str_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register a new protocol.\n@param name the full name of the new protocol\n@param short_name abbreviated name of the new protocol\n@param filter_name protocol name used for a display filter string\n@return the new protocol handle"]
    pub fn proto_register_protocol(
        name: *const ::std::os::raw::c_char,
        short_name: *const ::std::os::raw::c_char,
        filter_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register a \"helper\" protocol (pino - protocol in name only).\nThis is for dissectors that need distinguishing names and don't need the other\nfeatures (like enable/disable).  One use case is a protocol with multiple dissection\nfunctions in a single dissector table needing unique \"dissector names\" to remove\nconfusion with Decode As dialog.  Another use case is for a dissector table set\nup to handle TLVs within a single protocol (and allow \"external\" TLVs being\nregistered through the dissector table).\n@param name the full name of the new protocol\n@param short_name abbreviated name of the new protocol\n@param filter_name protocol name used for a display filter string\n@param parent_proto the \"real\" protocol for the helper.  The parent decides enable/disable\n@param field_type FT_PROTOCOL or FT_BYTES.  Allows removal of \"protocol highlighting\" (FT_BYTES)\nif pino is part of TLV.\n@return the new protocol handle"]
    pub fn proto_register_protocol_in_name_only(
        name: *const ::std::os::raw::c_char,
        short_name: *const ::std::os::raw::c_char,
        filter_name: *const ::std::os::raw::c_char,
        parent_proto: ::std::os::raw::c_int,
        field_type: ftenum,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Deregister a protocol.\nThis is only used internally for reloading Lua plugins and must not be used\nby dissectors or plugins.\n@param short_name abbreviated name of the protocol\n@return TRUE if protocol is removed"]
    pub fn proto_deregister_protocol(short_name: *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    #[doc = " Register a protocol alias.\nThis is for dissectors whose original name has changed, e.g. BOOTP to DHCP.\n@param proto_id protocol id returned by proto_register_protocol (0-indexed)\n@param alias_name alias for the protocol's filter name"]
    pub fn proto_register_alias(
        proto_id: ::std::os::raw::c_int,
        alias_name: *const ::std::os::raw::c_char,
    );
}
#[doc = " This type of function can be registered to get called whenever\na given field was not found but a its prefix is matched;\nIt can be used to procrastinate the hf array registration.\n@param match  what's being matched"]
pub type prefix_initializer_t =
    ::std::option::Option<unsafe extern "C" fn(match_: *const ::std::os::raw::c_char)>;
extern "C" {
    #[doc = " Register a new prefix for delayed initialization of field arrays\nNote that the initializer function MAY NOT be called before the dissector\nis first called.  That is, dissectors using this function must be prepared\nto call the initializer before beginning dissection; they should do this by\ncalling proto_registrar_get_byname() on one of the dissector's field names.\n@param prefix the prefix for the new protocol\n@param initializer function that will initialize the field array for the given prefix"]
    pub fn proto_register_prefix(
        prefix: *const ::std::os::raw::c_char,
        initializer: prefix_initializer_t,
    );
}
extern "C" {
    #[doc = " Initialize every remaining uninitialized prefix."]
    pub fn proto_initialize_all_prefixes();
}
extern "C" {
    #[doc = " Register a header_field array.\n@param parent the protocol handle from proto_register_protocol()\n@param hf the hf_register_info array\n@param num_records the number of records in hf"]
    pub fn proto_register_field_array(
        parent: ::std::os::raw::c_int,
        hf: *mut hf_register_info,
        num_records: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Deregister an already registered field.\n@param parent the protocol handle from proto_register_protocol()\n@param hf_id the field to deregister"]
    pub fn proto_deregister_field(parent: ::std::os::raw::c_int, hf_id: gint);
}
extern "C" {
    #[doc = " Add data to be freed when deregistered fields are freed.\n@param data a pointer to data to free"]
    pub fn proto_add_deregistered_data(data: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Add a memory slice to be freed when deregistered fields are freed.\n@param block_size the size of the block\n@param mem_block a pointer to the block to free"]
    pub fn proto_add_deregistered_slice(block_size: gsize, mem_block: gpointer);
}
extern "C" {
    #[doc = " Free strings in a field.\n@param field_type the field type (one of FT_ values)\n@param field_display field display value (one of BASE_ values)\n@param field_strings field strings"]
    pub fn proto_free_field_strings(
        field_type: ftenum_t,
        field_display: ::std::os::raw::c_uint,
        field_strings: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Free fields deregistered in proto_deregister_field()."]
    pub fn proto_free_deregistered_fields();
}
extern "C" {
    #[doc = " Register a protocol subtree (ett) array.\n@param indices array of ett indices\n@param num_indices the number of records in indices"]
    pub fn proto_register_subtree_array(
        indices: *const *mut gint,
        num_indices: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Get name of registered header_field number n.\n@param n item # n (0-indexed)\n@return the name of this registered item"]
    pub fn proto_registrar_get_name(n: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get abbreviation of registered header_field number n.\n@param n item # n (0-indexed)\n@return the abbreviation of this registered item"]
    pub fn proto_registrar_get_abbrev(n: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the header_field information based upon a field or protocol id.\n@param hfindex item # n (0-indexed)\n@return the registered item"]
    pub fn proto_registrar_get_nth(hfindex: guint) -> *mut header_field_info;
}
extern "C" {
    #[doc = " Get the header_field information based upon a field name.\n@param field_name the field name to search for\n@return the registered item"]
    pub fn proto_registrar_get_byname(
        field_name: *const ::std::os::raw::c_char,
    ) -> *mut header_field_info;
}
extern "C" {
    #[doc = " Get the header_field information based upon a field alias.\n@param alias_name the aliased field name to search for\n@return the registered item"]
    pub fn proto_registrar_get_byalias(
        alias_name: *const ::std::os::raw::c_char,
    ) -> *mut header_field_info;
}
extern "C" {
    #[doc = " Get the header_field id based upon a field name.\n@param field_name the field name to search for\n@return the field id for the registered item"]
    pub fn proto_registrar_get_id_byname(
        field_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get enum ftenum FT_ of registered header_field number n.\n@param n item # n (0-indexed)\n@return the registered item"]
    pub fn proto_registrar_get_ftype(n: ::std::os::raw::c_int) -> ftenum;
}
extern "C" {
    #[doc = " Get parent protocol of registered header_field number n.\n@param n item # n (0-indexed)\n@return -1 if item _is_ a protocol"]
    pub fn proto_registrar_get_parent(n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Is item # n a protocol?\n@param n item # n (0-indexed)\n@return TRUE if it's a protocol, FALSE if it's not"]
    pub fn proto_registrar_is_protocol(n: ::std::os::raw::c_int) -> gboolean;
}
extern "C" {
    #[doc = " Get length of registered field according to field type.\n@param n item # n (0-indexed)\n@return 0 means undeterminable at registration time, -1 means unknown field"]
    pub fn proto_registrar_get_length(n: ::std::os::raw::c_int) -> gint;
}
extern "C" {
    #[doc = " Routines to use to iterate over the protocols and their fields;\n they return the item number of the protocol in question or the\n appropriate hfinfo pointer, and keep state in \"*cookie\"."]
    pub fn proto_get_first_protocol(
        cookie: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proto_get_data_protocol(cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proto_get_next_protocol(
        cookie: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proto_get_first_protocol_field(
        proto_id: ::std::os::raw::c_int,
        cookie: *mut *mut ::std::os::raw::c_void,
    ) -> *mut header_field_info;
}
extern "C" {
    pub fn proto_get_next_protocol_field(
        proto_id: ::std::os::raw::c_int,
        cookie: *mut *mut ::std::os::raw::c_void,
    ) -> *mut header_field_info;
}
extern "C" {
    #[doc = " Check if a protocol name is already registered.\n@param name the name to search for\n@return proto_id"]
    pub fn proto_name_already_registered(name: *const gchar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Given a protocol's filter_name.\n@param filter_name the filter name to search for\n@return proto_id"]
    pub fn proto_get_id_by_filter_name(filter_name: *const gchar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Given a protocol's short name.\n@param short_name the protocol short name to search for\n@return proto_id"]
    pub fn proto_get_id_by_short_name(short_name: *const gchar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Can item # n decoding be disabled?\n@param proto_id protocol id (0-indexed)\n@return TRUE if it's a protocol, FALSE if it's not"]
    pub fn proto_can_toggle_protocol(proto_id: ::std::os::raw::c_int) -> gboolean;
}
extern "C" {
    #[doc = " Get the \"protocol_t\" structure for the given protocol's item number.\n@param proto_id protocol id (0-indexed)"]
    pub fn find_protocol_by_id(proto_id: ::std::os::raw::c_int) -> *mut protocol_t;
}
extern "C" {
    #[doc = " Get the protocol's name for the given protocol's item number.\n@param proto_id protocol id (0-indexed)\n@return its name"]
    pub fn proto_get_protocol_name(
        proto_id: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the protocol's item number, for the given protocol's \"protocol_t\".\n@return its proto_id"]
    pub fn proto_get_id(protocol: *const protocol_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the protocol's short name, for the given protocol's \"protocol_t\".\n@return its short name."]
    pub fn proto_get_protocol_short_name(
        protocol: *const protocol_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the protocol's long name, for the given protocol's \"protocol_t\".\n@return its long name."]
    pub fn proto_get_protocol_long_name(
        protocol: *const protocol_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Is protocol's decoding enabled ?\n@return TRUE if decoding is enabled, FALSE if not"]
    pub fn proto_is_protocol_enabled(protocol: *const protocol_t) -> gboolean;
}
extern "C" {
    #[doc = " Is protocol's enabled by default (most are)?\n@return TRUE if decoding is enabled by default, FALSE if not"]
    pub fn proto_is_protocol_enabled_by_default(protocol: *const protocol_t) -> gboolean;
}
extern "C" {
    #[doc = " Is this a protocol in name only (i.e. not a real one)?\n@return TRUE if helper, FALSE if not"]
    pub fn proto_is_pino(protocol: *const protocol_t) -> gboolean;
}
extern "C" {
    #[doc = " Get a protocol's filter name by its item number.\n@param proto_id protocol id (0-indexed)\n@return its filter name."]
    pub fn proto_get_protocol_filter_name(
        proto_id: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Associate a heuristic dissector with a protocol\n INTERNAL USE ONLY!!!\n @param protocol to associate the heuristic with\n @param short_name heuristic dissector's short name"]
    pub fn proto_add_heuristic_dissector(
        protocol: *mut protocol_t,
        short_name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Apply func to all heuristic dissectors of a protocol\n @param protocol to iterate over heuristics\n @param func function to execute on heuristics\n @param user_data user-specific data for function"]
    pub fn proto_heuristic_dissector_foreach(
        protocol: *const protocol_t,
        func: GFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " Find commonly-used protocols in a layer list.\n @param layers Protocol layer list\n @param is_ip Set to TRUE if the layer list contains IPv4 or IPv6, otherwise\n unchanged. May be NULL.\n @param is_tcp Set to TRUE if the layer list contains TCP, otherwise\n unchanged. May be NULL.\n @param is_udp Set to TRUE if the layer list contains UDP, otherwise\n unchanged. May be NULL.\n @param is_sctp Set to TRUE if the layer list contains SCTP, otherwise\n unchanged. May be NULL.\n @param is_tls Set to TRUE if the layer list contains SSL/TLS, otherwise\n unchanged. May be NULL.\n @param is_rtp Set to TRUE if the layer list contains RTP, otherwise\n unchanged. May be NULL.\n @param is_lte_rlc Set to TRUE if the layer list contains LTE RLC, otherwise\n unchanged. May be NULL."]
    pub fn proto_get_frame_protocols(
        layers: *const wmem_list_t,
        is_ip: *mut gboolean,
        is_tcp: *mut gboolean,
        is_udp: *mut gboolean,
        is_sctp: *mut gboolean,
        is_tls: *mut gboolean,
        is_rtp: *mut gboolean,
        is_lte_rlc: *mut gboolean,
    );
}
extern "C" {
    #[doc = " Check whether a protocol, specified by name, is in a layer list.\n @param layers Protocol layer list\n @param proto_name Name of protocol to find\n @return TRUE if the protocol is found, FALSE if it isn't"]
    pub fn proto_is_frame_protocol(
        layers: *const wmem_list_t,
        proto_name: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    #[doc = " Create a string of all layers in the packet.\n @param pinfo Pointer to packet info\n @return string of layer names"]
    pub fn proto_list_layers(pinfo: *const packet_info) -> *mut gchar;
}
extern "C" {
    #[doc = " Mark protocol with the given item number as disabled by default.\n@param proto_id protocol id (0-indexed)"]
    pub fn proto_disable_by_default(proto_id: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Enable / Disable protocol of the given item number.\n@param proto_id protocol id (0-indexed)\n@param enabled enable / disable the protocol"]
    pub fn proto_set_decoding(proto_id: ::std::os::raw::c_int, enabled: gboolean);
}
extern "C" {
    #[doc = " Disable all protocols."]
    pub fn proto_disable_all();
}
extern "C" {
    #[doc = " Re-enable all protocols that are not marked as disabled by default."]
    pub fn proto_reenable_all();
}
extern "C" {
    #[doc = " Disable disabling/enabling of protocol of the given item number.\n@param proto_id protocol id (0-indexed)"]
    pub fn proto_set_cant_toggle(proto_id: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Checks for existence any protocol or field within a tree.\n@param tree \"Protocols\" are assumed to be a child of the [empty] root node.\n@param id hfindex of protocol or field\n@return TRUE = found, FALSE = not found\n@todo add explanation of id parameter"]
    pub fn proto_check_for_protocol_or_field(
        tree: *const proto_tree,
        id: ::std::os::raw::c_int,
    ) -> gboolean;
}
extern "C" {
    #[doc = " Return GPtrArray* of field_info pointers for all hfindex that appear in\ntree. Only works with primed trees, and is fast.\n@param tree tree of interest\n@param hfindex primed hfindex\n@return GPtrArray pointer"]
    pub fn proto_get_finfo_ptr_array(
        tree: *const proto_tree,
        hfindex: ::std::os::raw::c_int,
    ) -> *mut GPtrArray;
}
extern "C" {
    #[doc = " Return whether we're tracking any interesting fields.\nOnly works with primed trees, and is fast.\n@param tree tree of interest\n@return TRUE if we're tracking interesting fields"]
    pub fn proto_tracking_interesting_fields(tree: *const proto_tree) -> gboolean;
}
extern "C" {
    #[doc = " Return GPtrArray* of field_info pointers for all hfindex that appear in\ntree. Works with any tree, primed or unprimed, and is slower than\nproto_get_finfo_ptr_array because it has to search through the tree.\n@param tree tree of interest\n@param hfindex index of field info of interest\n@return GPtrArry pointer"]
    pub fn proto_find_finfo(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
    ) -> *mut GPtrArray;
}
extern "C" {
    #[doc = " Return GPtrArray* of field_info pointer for first hfindex that appear in\ntree. Works with any tree, primed or unprimed, and is slower than\nproto_get_finfo_ptr_array because it has to search through the tree.\n@param tree tree of interest\n@param hfindex index of field info of interest\n@return GPtrArry pointer"]
    pub fn proto_find_first_finfo(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
    ) -> *mut GPtrArray;
}
extern "C" {
    #[doc = " Return GPtrArray* of field_info pointers containg all hfindexes that appear\nin tree.\n@param tree tree of interest\n@return GPtrArry pointer"]
    pub fn proto_all_finfos(tree: *mut proto_tree) -> *mut GPtrArray;
}
extern "C" {
    #[doc = " Dumps a glossary of the protocol registrations to STDOUT"]
    pub fn proto_registrar_dump_protocols();
}
extern "C" {
    #[doc = " Dumps a glossary of the field value strings or true/false strings to STDOUT"]
    pub fn proto_registrar_dump_values();
}
extern "C" {
    #[doc = " Dumps a mapping file for loading tshark output into ElasticSearch"]
    pub fn proto_registrar_dump_elastic(filter: *const gchar);
}
extern "C" {
    #[doc = " Dumps the number of protocol and field registrations to STDOUT.\n@return FALSE if we pre-allocated enough fields, TRUE otherwise."]
    pub fn proto_registrar_dump_fieldcount() -> gboolean;
}
extern "C" {
    #[doc = " Dumps a glossary of the protocol and field registrations to STDOUT."]
    pub fn proto_registrar_dump_fields();
}
extern "C" {
    #[doc = " Dumps protocol and field abbreviations to STDOUT which start with prefix."]
    pub fn proto_registrar_dump_field_completions(prefix: *mut ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    #[doc = " Dumps a glossary field types and descriptive names to STDOUT"]
    pub fn proto_registrar_dump_ftypes();
}
extern "C" {
    #[doc = " Get string representation of display field value\n@param field_display field display value (one of BASE_ values)\n@return string representation of display field value or \"Unknown\" if doesn't exist"]
    pub fn proto_field_display_to_string(
        field_display: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Number of elements in the tree_is_expanded array. With MSVC and a\n libwireshark.dll, we need a special declaration."]
    pub static mut num_tree_types: ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns TRUE if subtrees of that type are to be expanded."]
    pub fn tree_expanded(tree_type: ::std::os::raw::c_int) -> gboolean;
}
extern "C" {
    #[doc = " Sets if subtrees of that type are to be expanded."]
    pub fn tree_expanded_set(tree_type: ::std::os::raw::c_int, value: gboolean);
}
extern "C" {
    pub fn hfinfo_bitshift(hfinfo: *const header_field_info) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epan_dissect {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Can we do a \"match selected\" on this field.\n@param finfo field_info\n@param edt epan dissecting\n@return TRUE if we can do a \"match selected\" on the field, FALSE otherwise."]
    pub fn proto_can_match_selected(finfo: *mut field_info, edt: *mut epan_dissect) -> gboolean;
}
extern "C" {
    #[doc = " Construct a \"match selected\" display filter string.\n@param finfo field_info\n@param edt epan dissecting\n@return the wmem NULL alloced display filter string.  Needs to be freed with wmem_free(NULL, ...)"]
    pub fn proto_construct_match_selected_string(
        finfo: *mut field_info,
        edt: *mut epan_dissect,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Find field from offset in tvb.\n@param tree tree of interest\n@param offset offset in the tvb\n@param tvb the tv buffer\n@return the corresponding field_info"]
    pub fn proto_find_field_from_offset(
        tree: *mut proto_tree,
        offset: guint,
        tvb: *mut tvbuff_t,
    ) -> *mut field_info;
}
extern "C" {
    #[doc = " Find undecoded bytes in a tree\n@param tree tree of interest\n@param length the length of the frame\n@return an array to be used as bitmap of decoded bytes"]
    pub fn proto_find_undecoded_data(tree: *mut proto_tree, length: guint) -> *mut gchar;
}
extern "C" {
    #[doc = " This function will dissect a sequence of bytes that describe a bitmask.\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param offset start of data in tvb\n@param hf_hdr an 8/16/24/32/40/48/56/64 bit integer that describes the\nbitmask to be dissected.\nThis field will form an expansion under which the individual fields\nof the bitmask are dissected and displayed.\nThis field must be of the type FT_[U]INT{8|16|24|32|40|48|56|64}.\n@param ett subtree index\n@param fields an array of pointers to int that lists all the fields of the\nbitmask. These fields can be either of the type FT_BOOLEAN for flags\nor another integer of the same type/size as hf_hdr with a mask specified.\nThis array is terminated by a NULL entry.\nFT_BOOLEAN bits that are set to 1 will have the name added to the expansion.\nFT_integer fields that have a value_string attached will have the\nmatched string displayed on the expansion line.\n@param encoding big or little endian byte representation (ENC_BIG_ENDIAN/ENC_LITTLE_ENDIAN/ENC_HOST_ENDIAN)\n@return the newly created item"]
    pub fn proto_tree_add_bitmask(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        hf_hdr: ::std::os::raw::c_int,
        ett: gint,
        fields: *const *mut ::std::os::raw::c_int,
        encoding: guint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " This function will dissect a sequence of bytes that describe a bitmask.\nThe value of the integer containing the bitmask is returned through\na pointer.\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param offset start of data in tvb\n@param hf_hdr an 8/16/24/32/40/48/56/64 bit integer that describes the\nbitmask to be dissected.\nThis field will form an expansion under which the individual fields\nof the bitmask are dissected and displayed.\nThis field must be of the type FT_[U]INT{8|16|24|32|40|48|56|64}.\n@param ett subtree index\n@param fields an array of pointers to int that lists all the fields of the\nbitmask. These fields can be either of the type FT_BOOLEAN for flags\nor another integer of the same type/size as hf_hdr with a mask specified.\nThis array is terminated by a NULL entry.\nFT_BOOLEAN bits that are set to 1 will have the name added to the expansion.\nFT_integer fields that have a value_string attached will have the\nmatched string displayed on the expansion line.\n@param encoding big or little endian byte representation (ENC_BIG_ENDIAN/ENC_LITTLE_ENDIAN/ENC_HOST_ENDIAN)\n@param[out] retval points to a guint64 which will be set\n@return the newly created item, and *retval is set to the decoded value masked/shifted according to bitmask"]
    pub fn proto_tree_add_bitmask_ret_uint64(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        hf_hdr: ::std::os::raw::c_int,
        ett: gint,
        fields: *const *mut ::std::os::raw::c_int,
        encoding: guint,
        retval: *mut guint64,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " This function will dissect a sequence of bytes that describe a bitmask.\nThis has \"filterable\" bitmask header functionality of proto_tree_add_bitmask\nwith the ability to control what data is appended to the header like\nproto_tree_add_bitmask_text\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param offset start of data in tvb\n@param hf_hdr an 8/16/24/32/40/48/56/64 bit integer that describes the\nbitmask to be dissected.\nThis field will form an expansion under which the individual fields\nof the bitmask are dissected and displayed.\nThis field must be of the type FT_[U]INT{8|16|24|32|40|48|56|64}.\n@param ett subtree index\n@param fields an array of pointers to int that lists all the fields of the\nbitmask. These fields can be either of the type FT_BOOLEAN for flags\nor another integer of the same type/size as hf_hdr with a mask specified.\nThis array is terminated by a NULL entry.\nFT_BOOLEAN bits that are set to 1 will have the name added to the expansion.\nFT_integer fields that have a value_string attached will have the\nmatched string displayed on the expansion line.\n@param encoding big or little endian byte representation (ENC_BIG_ENDIAN/ENC_LITTLE_ENDIAN/ENC_HOST_ENDIAN)\n@param flags bitmask field using BMT_NO_* flags to determine behavior\n@return the newly created item"]
    pub fn proto_tree_add_bitmask_with_flags(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        hf_hdr: ::std::os::raw::c_int,
        ett: gint,
        fields: *const *mut ::std::os::raw::c_int,
        encoding: guint,
        flags: ::std::os::raw::c_int,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " This function will dissect a sequence of bytes that describe a bitmask.\nThis has \"filterable\" bitmask header functionality of proto_tree_add_bitmask\nwith the ability to control what data is appended to the header like\nproto_tree_add_bitmask_text\nThe value of the integer containing the bitmask is returned through\na pointer.\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param offset start of data in tvb\n@param hf_hdr an 8/16/24/32/40/48/56/64 bit integer that describes the\nbitmask to be dissected.\nThis field will form an expansion under which the individual fields\nof the bitmask are dissected and displayed.\nThis field must be of the type FT_[U]INT{8|16|24|32|40|48|56|64}.\n@param ett subtree index\n@param fields an array of pointers to int that lists all the fields of the\nbitmask. These fields can be either of the type FT_BOOLEAN for flags\nor another integer of the same type/size as hf_hdr with a mask specified.\nThis array is terminated by a NULL entry.\nFT_BOOLEAN bits that are set to 1 will have the name added to the expansion.\nFT_integer fields that have a value_string attached will have the\nmatched string displayed on the expansion line.\n@param encoding big or little endian byte representation (ENC_BIG_ENDIAN/ENC_LITTLE_ENDIAN/ENC_HOST_ENDIAN)\n@param flags bitmask field using BMT_NO_* flags to determine behavior\n@param[out] retval points to a guint64 which will be set\n@return the newly created item, and *retval is set to the decoded value masked/shifted according to bitmask"]
    pub fn proto_tree_add_bitmask_with_flags_ret_uint64(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        hf_hdr: ::std::os::raw::c_int,
        ett: gint,
        fields: *const *mut ::std::os::raw::c_int,
        encoding: guint,
        flags: ::std::os::raw::c_int,
        retval: *mut guint64,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " This function will dissect a value that describe a bitmask. Similar to proto_tree_add_bitmask(),\nbut with a passed in value (presumably because it can't be retrieved directly from tvb)\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param offset start of data in tvb\n@param hf_hdr an 8/16/24/32/64 bit integer that describes the bitmask to be dissected.\nThis field will form an expansion under which the individual fields of the\nbitmask is dissected and displayed.\nThis field must be of the type FT_[U]INT{8|16|24|32|64}.\n@param ett subtree index\n@param fields an array of pointers to int that lists all the fields of the\nbitmask. These fields can be either of the type FT_BOOLEAN for flags\nor another integer of the same type/size as hf_hdr with a mask specified.\nThis array is terminated by a NULL entry.\nFT_BOOLEAN bits that are set to 1 will have the name added to the expansion.\nFT_integer fields that have a value_string attached will have the\nmatched string displayed on the expansion line.\n@param value bitmask value\n@return the newly created item"]
    pub fn proto_tree_add_bitmask_value(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        hf_hdr: ::std::os::raw::c_int,
        ett: gint,
        fields: *const *mut ::std::os::raw::c_int,
        value: guint64,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " This function will dissect a value that describe a bitmask. Similar to proto_tree_add_bitmask(),\nbut with a passed in value (presumably because it can't be retrieved directly from tvb)\nThis has \"filterable\" bitmask header functionality of proto_tree_add_bitmask_value\nwith the ability to control what data is appended to the header like\nproto_tree_add_bitmask_text\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param offset start of data in tvb\n@param hf_hdr an 8/16/24/32/64 bit integer that describes the bitmask to be dissected.\nThis field will form an expansion under which the individual fields of the\nbitmask is dissected and displayed.\nThis field must be of the type FT_[U]INT{8|16|24|32|64}.\n@param ett subtree index\n@param fields an array of pointers to int that lists all the fields of the\nbitmask. These fields can be either of the type FT_BOOLEAN for flags\nor another integer of the same type/size as hf_hdr with a mask specified.\nThis array is terminated by a NULL entry.\nFT_BOOLEAN bits that are set to 1 will have the name added to the expansion.\nFT_integer fields that have a value_string attached will have the\nmatched string displayed on the expansion line.\n@param value bitmask value\n@param flags bitmask field using BMT_NO_* flags to determine behavior\n@return the newly created item"]
    pub fn proto_tree_add_bitmask_value_with_flags(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        hf_hdr: ::std::os::raw::c_int,
        ett: gint,
        fields: *const *mut ::std::os::raw::c_int,
        value: guint64,
        flags: ::std::os::raw::c_int,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " This function will dissect a sequence of bytes that describe a bitmask. Similar\nto proto_tree_add_bitmask(), but with no \"header\" item to group all of the fields\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param offset start of data in tvb\n@param len number of bytes of data\n@param fields an array of pointers to int that lists all the fields of the\nbitmask. These fields can be either of the type FT_BOOLEAN for flags\nor another integer of the same type/size as hf_hdr with a mask specified.\nThis array is terminated by a NULL entry.\nFT_BOOLEAN bits that are set to 1 will have the name added to the expansion.\nFT_integer fields that have a value_string attached will have the\nmatched string displayed on the expansion line.\n@param encoding big or little endian byte representation (ENC_BIG_ENDIAN/ENC_LITTLE_ENDIAN/ENC_HOST_ENDIAN)"]
    pub fn proto_tree_add_bitmask_list(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        len: ::std::os::raw::c_int,
        fields: *const *mut ::std::os::raw::c_int,
        encoding: guint,
    );
}
extern "C" {
    #[doc = " This function will dissect a value that describe a bitmask. Similar to proto_tree_add_bitmask_list(),\nbut with a return value\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param offset start of data in tvb\n@param len number of bytes of data\n@param fields an array of pointers to int that lists all the fields of the\nbitmask. These fields can be either of the type FT_BOOLEAN for flags\nor another integer of the same type/size as hf_hdr with a mask specified.\nThis array is terminated by a NULL entry.\nFT_BOOLEAN bits that are set to 1 will have the name added to the expansion.\nFT_integer fields that have a value_string attached will have the\nmatched string displayed on the expansion line.\n@param encoding big or little endian byte representation (ENC_BIG_ENDIAN/ENC_LITTLE_ENDIAN/ENC_HOST_ENDIAN)\n@param retval if a pointer is passed here the value is returned."]
    pub fn proto_tree_add_bitmask_list_ret_uint64(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        len: ::std::os::raw::c_int,
        fields: *const *mut ::std::os::raw::c_int,
        encoding: guint,
        retval: *mut guint64,
    );
}
extern "C" {
    #[doc = " This function will dissect a value that describe a bitmask. Similar to proto_tree_add_bitmask_list(),\nbut with a passed in value (presumably because it can't be retrieved directly from tvb)\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param offset start of data in tvb\n@param len number of bytes of data\n@param fields an array of pointers to int that lists all the fields of the\nbitmask. These fields can be either of the type FT_BOOLEAN for flags\nor another integer of the same type/size as hf_hdr with a mask specified.\nThis array is terminated by a NULL entry.\nFT_BOOLEAN bits that are set to 1 will have the name added to the expansion.\nFT_integer fields that have a value_string attached will have the\nmatched string displayed on the expansion line.\n@param value bitmask value"]
    pub fn proto_tree_add_bitmask_list_value(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        len: ::std::os::raw::c_int,
        fields: *const *mut ::std::os::raw::c_int,
        value: guint64,
    );
}
extern "C" {
    #[doc = " This function will dissect a sequence of bytes that describe a bitmask.\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param offset start of data in tvb\n@param len number of bytes of data\n@param hf_hdr an 8/16/24/32 bit integer that describes the bitmask to be dissected.\nThis field will form an expansion under which the individual fields of the\nbitmask are dissected and displayed.\nThis field must be of the type FT_[U]INT{8|16|24|32}.\n@param ett subtree index\n@param fields an array of pointers to int that lists all the fields of the\nbitmask. These fields can be either of the type FT_BOOLEAN for flags\nor another integer with a mask specified.\nThis array is terminated by a NULL entry.\nFT_BOOLEAN bits that are set to 1 will have the name added to the expansion.\nFT_integer fields that have a value_string attached will have the\nmatched string displayed on the expansion line.\n@param exp expert info field used when decodable_len < len.  This also means this function\nshould be called even when tree == NULL\n@param encoding big or little endian byte representation (ENC_BIG_ENDIAN/ENC_LITTLE_ENDIAN/ENC_HOST_ENDIAN)\n@return the newly created item"]
    pub fn proto_tree_add_bitmask_len(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        len: guint,
        hf_hdr: ::std::os::raw::c_int,
        ett: gint,
        fields: *const *mut ::std::os::raw::c_int,
        exp: *mut expert_field,
        encoding: guint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a text with a subtree of bitfields.\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param offset start of data in tvb\n@param len length of the field name\n@param name field name (NULL if bitfield contents should be used)\n@param fallback field name if none of bitfields were usable\n@param ett subtree index\n@param fields NULL-terminated array of bitfield indexes\n@param encoding big or little endian byte representation (ENC_BIG_ENDIAN/ENC_LITTLE_ENDIAN/ENC_HOST_ENDIAN)\n@param flags bitmask field\n@return the newly created item"]
    pub fn proto_tree_add_bitmask_text(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        len: guint,
        name: *const ::std::os::raw::c_char,
        fallback: *const ::std::os::raw::c_char,
        ett: gint,
        fields: *const *mut ::std::os::raw::c_int,
        encoding: guint,
        flags: ::std::os::raw::c_int,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits to a proto_tree, using the text label registered to that item.\nThe item is extracted from the tvbuff handed to it.\n@param tree the tree to append this item to\n@param hf_index field index. Fields for use with this function should have bitmask==0.\n@param tvb the tv buffer of the current data\n@param bit_offset start of data in tvb expressed in bits\n@param no_of_bits length of data in tvb expressed in bits\n@param encoding data encoding\n@return the newly created item"]
    pub fn proto_tree_add_bits_item(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        encoding: guint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits to a proto_tree, using the text label registered to that item.\n  The item is extracted from the tvbuff handed to it as a set\n  of crumbs (segments) of contiguous bits, specified by an\n  array of crumb_spec elements.  The crumbs are assembled to\n  create the value.  There may be any number of crumbs\n  specifying up to a total of 64 bits which may occur anywhere\n  within the tvb. If the span of the crumbs within the tvb is 4\n  octets or less, a bitmap of the crumbs is produced.\n@param tree the tree to append this item to\n@param hf_index field index. Fields for use with this function should have bitmask==0.\n@param tvb the tv buffer of the current data\n@param bit_offset of the first crumb in tvb expressed in bits\n@param crumb_spec pointer to crumb_spec array\n@param return_value if a pointer is passed here the value is returned.\n@return the newly created item"]
    pub fn proto_tree_add_split_bits_item_ret_val(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        crumb_spec: *const crumb_spec_t,
        return_value: *mut guint64,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bitmap text for a split-bits crumb to a proto_tree,\n  using the text label registered to an item. The bitmap is\n  extracted from the tvbuff handed to it as a crumb (segment)\n  of contiguous bits, specified by one of an array of\n  crumb_spec elements. This function is normally called once\n  per crumb, after the call to\nproto_tree_add_split_bits_item_ret_val\n@param tree the tree to append this item to\n@param hf_index field index. Fields for use with this function should have bitmask==0.\n@param tvb the tv buffer of the current data\n@param bit_offset of the first crumb in tvb expressed in bits\n@param crumb_spec pointer to crumb_spec array\n@param crumb_index into the crumb_spec array for this crumb"]
    pub fn proto_tree_add_split_bits_crumb(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        crumb_spec: *const crumb_spec_t,
        crumb_index: guint16,
    );
}
extern "C" {
    #[doc = " Add bits to a proto_tree, using the text label registered to that item.\nThe item is extracted from the tvbuff handed to it.\n@param tree the tree to append this item to\n@param hf_index field index. Fields for use with this function should have bitmask==0.\n@param tvb the tv buffer of the current data\n@param bit_offset start of data in tvb expressed in bits\n@param no_of_bits length of data in tvb expressed in bits\n@param return_value if a pointer is passed here the value is returned.\n@param encoding data encoding\n@return the newly created item"]
    pub fn proto_tree_add_bits_ret_val(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        return_value: *mut guint64,
        encoding: guint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits for a FT_UINT8, FT_UINT16, FT_UINT24 or FT_UINT32\nheader field to a proto_tree, with the format generating the\nstring for the value and with the field name being included automatically.\n@param tree the tree to append this item to\n@param hf_index field index\n@param tvb the tv buffer of the current data\n@param bit_offset start of data in tvb expressed in bits\n@param no_of_bits length of data in tvb expressed in bit\n@param value data to display\n@param encoding data encoding\n@param format printf like format string\n@return the newly created item"]
    pub fn proto_tree_add_uint_bits_format_value(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        value: guint32,
        encoding: guint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits for a FT_UINT8, FT_UINT16, FT_UINT24 or FT_UINT32\nheader field to a proto_tree, with the format generating the\nstring for the value and with the field name being included automatically.\n@param tree the tree to append this item to\n@param hf_index field index\n@param tvb the tv buffer of the current data\n@param bit_offset start of data in tvb expressed in bits\n@param no_of_bits length of data in tvb expressed in bit\n@param value data to display\n@param encoding data encoding\n@param format printf like format string\n@return the newly created item"]
    pub fn proto_tree_add_uint64_bits_format_value(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        value: guint64,
        encoding: guint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits for a FT_BOOLEAN header field to a proto_tree, with\nthe format generating the string for the value and with the field\nname being included automatically.\n@param tree the tree to append this item to\n@param hf_index field index\n@param tvb the tv buffer of the current data\n@param bit_offset start of data in tvb expressed in bits\n@param no_of_bits length of data in tvb expressed in bit\n@param value data to display\n@param encoding data encoding\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_boolean_bits_format_value(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        value: guint32,
        encoding: guint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits for a FT_BOOLEAN header field to a proto_tree, with\nthe format generating the string for the value and with the field\nname being included automatically.\n@param tree the tree to append this item to\n@param hf_index field index\n@param tvb the tv buffer of the current data\n@param bit_offset start of data in tvb expressed in bits\n@param no_of_bits length of data in tvb expressed in bit\n@param value data to display\n@param encoding data encoding\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_boolean_bits_format_value64(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        value: guint64,
        encoding: guint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits for a FT_INT8, FT_INT16, FT_INT24 or FT_INT32\nheader field to a proto_tree, with the format generating the\nstring for the value and with the field name being included automatically.\n@param tree the tree to append this item to\n@param hf_index field index\n@param tvb the tv buffer of the current data\n@param bit_offset start of data in tvb expressed in bits\n@param no_of_bits length of data in tvb expressed in bit\n@param value data to display\n@param encoding data encoding\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_int_bits_format_value(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        value: gint32,
        encoding: guint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits for a FT_INT8, FT_INT16, FT_INT24 or FT_INT32\nheader field to a proto_tree, with the format generating the\nstring for the value and with the field name being included automatically.\n@param tree the tree to append this item to\n@param hf_index field index\n@param tvb the tv buffer of the current data\n@param bit_offset start of data in tvb expressed in bits\n@param no_of_bits length of data in tvb expressed in bit\n@param value data to display\n@param encoding data encoding\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_int64_bits_format_value(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        value: gint64,
        encoding: guint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits for a FT_FLOAT header field to a proto_tree, with\nthe format generating the string for the value and with the field\nname being included automatically.\n@param tree the tree to append this item to\n@param hf_index field index\n@param tvb the tv buffer of the current data\n@param bit_offset start of data in tvb expressed in bits\n@param no_of_bits length of data in tvb expressed in bit\n@param value data to display\n@param encoding data encoding\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_float_bits_format_value(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        value: f32,
        encoding: guint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_STRING with ENC_3GPP_TS_23_038_7BITS_PACKED encoding to a\nproto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param bit_offset start of data in tvb expressed in bits\n@param no_of_chars number of 7bits characters to display\n@return the newly created item"]
    pub fn proto_tree_add_ts_23_038_7bits_packed_item(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_chars: gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_STRING with ENC_ASCII_7BITS encoding to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param bit_offset start of data in tvb expressed in bits\n@param no_of_chars number of 7bits characters to display\n@return the newly created item"]
    pub fn proto_tree_add_ascii_7bits_item(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_chars: gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a checksum filed to a proto_tree.\nThis standardizes the display of a checksum field as well as any\nstatus and expert info supporting it.\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param offset start of data in tvb\n@param hf_checksum checksum field index\n@param hf_checksum_status optional checksum status field index.  If none\nexists, just pass -1\n@param bad_checksum_expert optional expert info for a bad checksum.  If\nnone exists, just pass NULL\n@param pinfo Packet info used for optional expert info.  If unused, NULL can\nbe passed\n@param computed_checksum Checksum to verify against\n@param encoding data encoding of checksum from tvb\n@param flags bitmask field of PROTO_CHECKSUM_ options\n@return the newly created item"]
    pub fn proto_tree_add_checksum(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        hf_checksum: ::std::os::raw::c_int,
        hf_checksum_status: ::std::os::raw::c_int,
        bad_checksum_expert: *mut expert_field,
        pinfo: *mut packet_info,
        computed_checksum: guint32,
        encoding: guint,
        flags: guint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a checksum bytes arry filed to a proto_tree.\nThis standardizes the display of a checksum field as well as any\nstatus and expert info supporting it.\n@param tree the tree to append this item to\n@param tvb the tv buffer of the current data\n@param offset start of data in tvb\n@param hf_checksum checksum field index\n@param hf_checksum_status optional checksum status field index.  If none\nexists, just pass -1\n@param bad_checksum_expert optional expert info for a bad checksum.  If\nnone exists, just pass NULL\n@param pinfo Packet info used for optional expert info.  If unused, NULL can\nbe passed\n@param computed_checksum Checksum as bytes array to verify against\n@param checksum_len Checksum size in bytes\n@param flags bitmask field of PROTO_CHECKSUM_ options. PROTO_CHECKSUM_IN_CKSUM is ignored\n@return the newly created item"]
    pub fn proto_tree_add_checksum_bytes(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        hf_checksum: ::std::os::raw::c_int,
        hf_checksum_status: ::std::os::raw::c_int,
        bad_checksum_expert: *mut expert_field,
        pinfo: *mut packet_info,
        computed_checksum: *const u8,
        checksum_len: usize,
        flags: guint,
    ) -> *mut proto_item;
}
pub const proto_checksum_enum_e_PROTO_CHECKSUM_E_BAD: proto_checksum_enum_e = 0;
pub const proto_checksum_enum_e_PROTO_CHECKSUM_E_GOOD: proto_checksum_enum_e = 1;
pub const proto_checksum_enum_e_PROTO_CHECKSUM_E_UNVERIFIED: proto_checksum_enum_e = 2;
pub const proto_checksum_enum_e_PROTO_CHECKSUM_E_NOT_PRESENT: proto_checksum_enum_e = 3;
pub const proto_checksum_enum_e_PROTO_CHECKSUM_E_ILLEGAL: proto_checksum_enum_e = 4;
pub type proto_checksum_enum_e = ::std::os::raw::c_int;
extern "C" {
    pub static proto_checksum_vals: [value_string; 0usize];
}
extern "C" {
    #[doc = " Check if given string is a valid field name\n@param field_name the field name to check\n@return 0 if valid, else first illegal character"]
    pub fn proto_check_field_name(field_name: *const gchar) -> guchar;
}
extern "C" {
    #[doc = " Check if given string is a valid field name. Accepts only lower case\n characters.\n@param field_name the field name to check\n@return 0 if valid, else first illegal character"]
    pub fn proto_check_field_name_lower(field_name: *const gchar) -> guchar;
}
extern "C" {
    #[doc = " Set the column text for a custom column\n@param tree the tree to append this item to\n@param field_id the field ids used for custom column\n@param occurrence the occurrence of the field used for custom column\n@param result the buffer to fill with the field string\n@param expr the filter expression\n@param size the size of the string buffer"]
    pub fn proto_custom_set(
        tree: *mut proto_tree,
        field_id: *mut GSList,
        occurrence: gint,
        result: *mut gchar,
        expr: *mut gchar,
        size: ::std::os::raw::c_int,
    ) -> *const gchar;
}
extern "C" {
    #[doc = " Construct a display filter string for a custom column\n@param edt epan dissecting\n@param field_id the field ids used for custom column\n@param occurrence the occurrence of the field used for custom column\n@return allocated display filter string.  Needs to be freed with g_free(...)"]
    pub fn proto_custom_get_filter(
        edt: *mut epan_dissect,
        field_id: *mut GSList,
        occurrence: gint,
    ) -> *mut gchar;
}
extern "C" {
    #[doc = " @}"]
    pub fn hfinfo_char_value_format_display(
        display: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        value: guint32,
    ) -> *const ::std::os::raw::c_char;
}
pub type feature_list = *mut *mut GList;
pub type gather_feature_func = ::std::option::Option<unsafe extern "C" fn(l: feature_list)>;
extern "C" {
    pub fn with_feature(l: feature_list, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn without_feature(l: feature_list, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn sort_features(l: feature_list);
}
extern "C" {
    pub fn free_features(l: feature_list);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct enum_val_t {
    pub name: *const ::std::os::raw::c_char,
    pub description: *const ::std::os::raw::c_char,
    pub value: gint,
}
#[test]
fn bindgen_test_layout_enum_val_t() {
    const UNINIT: ::std::mem::MaybeUninit<enum_val_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<enum_val_t>(),
        24usize,
        concat!("Size of: ", stringify!(enum_val_t))
    );
    assert_eq!(
        ::std::mem::align_of::<enum_val_t>(),
        8usize,
        concat!("Alignment of ", stringify!(enum_val_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(enum_val_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(enum_val_t),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(enum_val_t),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct range_admin_tag {
    pub low: guint32,
    pub high: guint32,
}
#[test]
fn bindgen_test_layout_range_admin_tag() {
    const UNINIT: ::std::mem::MaybeUninit<range_admin_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<range_admin_tag>(),
        8usize,
        concat!("Size of: ", stringify!(range_admin_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<range_admin_tag>(),
        4usize,
        concat!("Alignment of ", stringify!(range_admin_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(range_admin_tag),
            "::",
            stringify!(low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(range_admin_tag),
            "::",
            stringify!(high)
        )
    );
}
pub type range_admin_t = range_admin_tag;
#[doc = " user specified range(s)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epan_range {
    #[doc = "< number of entries in ranges"]
    pub nranges: guint,
    #[doc = "< variable-length array"]
    pub ranges: [range_admin_t; 1usize],
}
#[test]
fn bindgen_test_layout_epan_range() {
    const UNINIT: ::std::mem::MaybeUninit<epan_range> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<epan_range>(),
        12usize,
        concat!("Size of: ", stringify!(epan_range))
    );
    assert_eq!(
        ::std::mem::align_of::<epan_range>(),
        4usize,
        concat!("Alignment of ", stringify!(epan_range))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nranges) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(epan_range),
            "::",
            stringify!(nranges)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ranges) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(epan_range),
            "::",
            stringify!(ranges)
        )
    );
}
#[doc = " user specified range(s)"]
pub type range_t = epan_range;
pub const convert_ret_t_CVT_NO_ERROR: convert_ret_t = 0;
pub const convert_ret_t_CVT_SYNTAX_ERROR: convert_ret_t = 1;
pub const convert_ret_t_CVT_NUMBER_TOO_BIG: convert_ret_t = 2;
#[doc = " Return value from range_convert_str()."]
pub type convert_ret_t = ::std::os::raw::c_int;
extern "C" {
    pub fn range_empty(scope: *mut wmem_allocator_t) -> *mut range_t;
}
extern "C" {
    #[doc = " Converts a range string to a fast comparable array of ranges.\n This function allocates a range_t large enough to hold the number\n of ranges specified, and fills the array range->ranges containing\n low and high values with the number of ranges being range->nranges.\n After having called this function, the function value_is_in_range()\n determines whether a given number is within the range or not.<BR>\n In case of a single number, we make a range where low is equal to high.\n We take care on wrongly entered ranges; opposite order will be taken\n care of.\n\n The following syntax is accepted :\n\n   1-20,30-40     Range from 1 to 20, and packets 30 to 40\n   -20,30         Range from 1 to 20, and packet 30\n   20,30,40-      20, 30, and the range from 40 to the end\n   20-10,30-25    Range from 10 to 20, and from 25 to 30\n   -              All values\n @param scope memory scope for the range\n @param range the range\n @param es points to the string to be converted.\n @param max_value specifies the maximum value in a range.\n @return convert_ret_t"]
    pub fn range_convert_str(
        scope: *mut wmem_allocator_t,
        range: *mut *mut range_t,
        es: *const gchar,
        max_value: guint32,
    ) -> convert_ret_t;
}
extern "C" {
    pub fn range_convert_str_work(
        scope: *mut wmem_allocator_t,
        range: *mut *mut range_t,
        es: *const gchar,
        max_value: guint32,
        err_on_max: gboolean,
    ) -> convert_ret_t;
}
extern "C" {
    #[doc = " This function returns TRUE if a given value is within one of the ranges\n stored in the ranges array.\n @param range the range\n @param val the value to check\n @return TRUE if the value is in range"]
    pub fn value_is_in_range(range: *const range_t, val: guint32) -> gboolean;
}
extern "C" {
    #[doc = " This function returns TRUE if val has successfully been added to\n a range.  This may extend an existing range or create a new one\n @param scope memory scope of range (in case of reallocation)\n @param range to add value\n @param val value to add to range\n @return TRUE if the value is successsfully added to range"]
    pub fn range_add_value(
        scope: *mut wmem_allocator_t,
        range: *mut *mut range_t,
        val: guint32,
    ) -> gboolean;
}
extern "C" {
    #[doc = " This function returns TRUE if val has successfully been removed from\n a range.  This may remove an existing range.\n @param scope memory scope of range (in case of reallocation)\n @param range to remove value\n @param val value to remove within range\n @return TRUE if the value is successsfully removed to range"]
    pub fn range_remove_value(
        scope: *mut wmem_allocator_t,
        range: *mut *mut range_t,
        val: guint32,
    ) -> gboolean;
}
extern "C" {
    #[doc = " This function returns TRUE if the two given range_t's are equal.\n @param a first range\n @param b second range\n @return TRUE if the value is in range"]
    pub fn ranges_are_equal(a: *const range_t, b: *const range_t) -> gboolean;
}
extern "C" {
    #[doc = " This function calls the provided callback function for each value in\n in the range. Takes a pointer argument, which is passed to the\n callback, along with the value in the range.\n @param range the range\n @param callback the callback function\n @param ptr pointer passed to the callback"]
    pub fn range_foreach(
        range: *mut range_t,
        callback: ::std::option::Option<unsafe extern "C" fn(val: guint32, ptr: gpointer)>,
        ptr: gpointer,
    );
}
extern "C" {
    #[doc = " This function converts a range_t to a (wmem_alloc()-allocated) string."]
    pub fn range_convert_range(
        scope: *mut wmem_allocator_t,
        range: *const range_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Create a (wmem-alloc()ed) copy of a range\n @param scope memory scope for the copied range\n @param src the range to copy\n @return ep allocated copy of the range"]
    pub fn range_copy(scope: *mut wmem_allocator_t, src: *const range_t) -> *mut range_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct color_t {
    pub red: u16,
    pub green: u16,
    pub blue: u16,
}
#[test]
fn bindgen_test_layout_color_t() {
    const UNINIT: ::std::mem::MaybeUninit<color_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<color_t>(),
        6usize,
        concat!("Size of: ", stringify!(color_t))
    );
    assert_eq!(
        ::std::mem::align_of::<color_t>(),
        2usize,
        concat!("Alignment of ", stringify!(color_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).red) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(color_t),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).green) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(color_t),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blue) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(color_t),
            "::",
            stringify!(blue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epan_uat {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _e_addr_resolve {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Convert a string listing name resolution types to a bitmask of\n those types.\n\n Set \"*name_resolve\" to the bitmask, and return '\\0', on success;\n return the bad character in the string on error.\n\n @param string a list of name resolution types\n @param name_resolve the bitmap of names to resolve to set\n @return '\\0' on success, the bad character in the string on error"]
    pub fn string_to_name_resolve(
        string: *const ::std::os::raw::c_char,
        name_resolve: *mut _e_addr_resolve,
    ) -> ::std::os::raw::c_char;
}
pub const layout_type_e_layout_unused: layout_type_e = 0;
pub const layout_type_e_layout_type_5: layout_type_e = 1;
pub const layout_type_e_layout_type_2: layout_type_e = 2;
pub const layout_type_e_layout_type_1: layout_type_e = 3;
pub const layout_type_e_layout_type_4: layout_type_e = 4;
pub const layout_type_e_layout_type_3: layout_type_e = 5;
pub const layout_type_e_layout_type_6: layout_type_e = 6;
pub const layout_type_e_layout_type_max: layout_type_e = 7;
pub type layout_type_e = ::std::os::raw::c_int;
pub const layout_pane_content_e_layout_pane_content_none: layout_pane_content_e = 0;
pub const layout_pane_content_e_layout_pane_content_plist: layout_pane_content_e = 1;
pub const layout_pane_content_e_layout_pane_content_pdetails: layout_pane_content_e = 2;
pub const layout_pane_content_e_layout_pane_content_pbytes: layout_pane_content_e = 3;
pub const layout_pane_content_e_layout_pane_content_pdiagram: layout_pane_content_e = 4;
pub type layout_pane_content_e = ::std::os::raw::c_int;
pub const version_info_e_version_welcome_only: version_info_e = 0;
pub const version_info_e_version_title_only: version_info_e = 1;
pub const version_info_e_version_both: version_info_e = 2;
pub const version_info_e_version_neither: version_info_e = 3;
pub type version_info_e = ::std::os::raw::c_int;
pub const pref_source_t_pref_default: pref_source_t = 0;
pub const pref_source_t_pref_stashed: pref_source_t = 1;
pub const pref_source_t_pref_current: pref_source_t = 2;
pub type pref_source_t = ::std::os::raw::c_int;
pub const elide_mode_e_ELIDE_LEFT: elide_mode_e = 0;
pub const elide_mode_e_ELIDE_RIGHT: elide_mode_e = 1;
pub const elide_mode_e_ELIDE_MIDDLE: elide_mode_e = 2;
pub const elide_mode_e_ELIDE_NONE: elide_mode_e = 3;
pub type elide_mode_e = ::std::os::raw::c_int;
pub const software_update_channel_e_UPDATE_CHANNEL_DEVELOPMENT: software_update_channel_e = 0;
pub const software_update_channel_e_UPDATE_CHANNEL_STABLE: software_update_channel_e = 1;
pub type software_update_channel_e = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _e_prefs {
    pub col_list: *mut GList,
    pub num_cols: gint,
    pub st_client_fg: color_t,
    pub st_client_bg: color_t,
    pub st_server_fg: color_t,
    pub st_server_bg: color_t,
    pub gui_text_valid: color_t,
    pub gui_text_invalid: color_t,
    pub gui_text_deprecated: color_t,
    pub restore_filter_after_following_stream: gboolean,
    pub gui_toolbar_main_style: gint,
    pub gui_font_name: *mut gchar,
    pub gui_active_fg: color_t,
    pub gui_active_bg: color_t,
    pub gui_active_style: gint,
    pub gui_inactive_fg: color_t,
    pub gui_inactive_bg: color_t,
    pub gui_inactive_style: gint,
    pub gui_marked_fg: color_t,
    pub gui_marked_bg: color_t,
    pub gui_ignored_fg: color_t,
    pub gui_ignored_bg: color_t,
    pub gui_colorized_fg: *mut gchar,
    pub gui_colorized_bg: *mut gchar,
    pub gui_geometry_save_position: gboolean,
    pub gui_geometry_save_size: gboolean,
    pub gui_geometry_save_maximized: gboolean,
    pub gui_recent_df_entries_max: guint,
    pub gui_recent_files_count_max: guint,
    pub gui_fileopen_style: guint,
    pub gui_fileopen_dir: *mut gchar,
    pub gui_fileopen_preview: guint,
    pub gui_tlskeylog_command: *mut gchar,
    pub gui_ask_unsaved: gboolean,
    pub gui_autocomplete_filter: gboolean,
    pub gui_find_wrap: gboolean,
    pub gui_window_title: *mut gchar,
    pub gui_prepend_window_title: *mut gchar,
    pub gui_start_title: *mut gchar,
    pub gui_version_placement: version_info_e,
    pub gui_max_export_objects: guint,
    pub gui_max_tree_items: guint,
    pub gui_max_tree_depth: guint,
    pub gui_layout_type: layout_type_e,
    pub gui_layout_content_1: layout_pane_content_e,
    pub gui_layout_content_2: layout_pane_content_e,
    pub gui_layout_content_3: layout_pane_content_e,
    pub gui_interfaces_hide_types: *mut gchar,
    pub gui_interfaces_show_hidden: gboolean,
    pub gui_interfaces_remote_display: gboolean,
    pub gui_io_graph_automatic_update: gboolean,
    pub gui_io_graph_enable_legend: gboolean,
    pub gui_packet_details_show_byteview: gboolean,
    pub capture_device: *mut gchar,
    pub capture_devices_linktypes: *mut gchar,
    pub capture_devices_descr: *mut gchar,
    pub capture_devices_hide: *mut gchar,
    pub capture_devices_monitor_mode: *mut gchar,
    pub capture_devices_buffersize: *mut gchar,
    pub capture_devices_snaplen: *mut gchar,
    pub capture_devices_pmode: *mut gchar,
    pub capture_devices_filter: *mut gchar,
    pub capture_prom_mode: gboolean,
    pub capture_pcap_ng: gboolean,
    pub capture_real_time: gboolean,
    pub capture_update_interval: guint,
    pub capture_no_interface_load: gboolean,
    pub capture_no_extcap: gboolean,
    pub capture_show_info: gboolean,
    pub capture_columns: *mut GList,
    pub tap_update_interval: guint,
    pub display_hidden_proto_items: gboolean,
    pub display_byte_fields_with_spaces: gboolean,
    pub enable_incomplete_dissectors_check: gboolean,
    pub incomplete_dissectors_check_debug: gboolean,
    pub strict_conversation_tracking_heuristics: gboolean,
    pub ignore_dup_frames: gboolean,
    pub ignore_dup_frames_cache_entries: guint,
    pub filter_expressions_old: gboolean,
    pub gui_update_enabled: gboolean,
    pub gui_update_channel: software_update_channel_e,
    pub gui_update_interval: gint,
    pub gui_debounce_timer: gint,
    pub saved_at_version: *mut gchar,
    pub unknown_prefs: gboolean,
    pub gui_packet_list_separator: gboolean,
    pub gui_packet_header_column_definition: gboolean,
    pub gui_packet_list_hover_style: gboolean,
    pub gui_show_selected_packet: gboolean,
    pub gui_show_file_load_time: gboolean,
    pub gui_packet_list_elide_mode: elide_mode_e,
    pub gui_packet_list_show_related: gboolean,
    pub gui_packet_list_show_minimap: gboolean,
    pub gui_packet_list_sortable: gboolean,
    pub gui_packet_list_cached_rows_max: guint,
    pub gui_decimal_places1: gint,
    pub gui_decimal_places2: gint,
    pub gui_decimal_places3: gint,
    pub gui_rtp_player_use_disk1: gboolean,
    pub gui_rtp_player_use_disk2: gboolean,
    pub st_enable_burstinfo: gboolean,
    pub st_burst_showcount: gboolean,
    pub st_burst_resolution: gint,
    pub st_burst_windowlen: gint,
    pub st_sort_casesensitve: gboolean,
    pub st_sort_rng_fixorder: gboolean,
    pub st_sort_rng_nameonly: gboolean,
    pub st_sort_defcolflag: gint,
    pub st_sort_defdescending: gboolean,
    pub st_sort_showfullname: gboolean,
    pub extcap_save_on_start: gboolean,
}
#[test]
fn bindgen_test_layout__e_prefs() {
    const UNINIT: ::std::mem::MaybeUninit<_e_prefs> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_e_prefs>(),
        584usize,
        concat!("Size of: ", stringify!(_e_prefs))
    );
    assert_eq!(
        ::std::mem::align_of::<_e_prefs>(),
        8usize,
        concat!("Alignment of ", stringify!(_e_prefs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).col_list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(col_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_cols) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(num_cols)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_client_fg) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(st_client_fg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_client_bg) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(st_client_bg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_server_fg) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(st_server_fg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_server_bg) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(st_server_bg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_text_valid) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_text_valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_text_invalid) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_text_invalid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_text_deprecated) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_text_deprecated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).restore_filter_after_following_stream) as usize
                - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(restore_filter_after_following_stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_toolbar_main_style) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_toolbar_main_style)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_font_name) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_font_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_active_fg) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_active_fg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_active_bg) as usize - ptr as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_active_bg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_active_style) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_active_style)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_inactive_fg) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_inactive_fg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_inactive_bg) as usize - ptr as usize },
        94usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_inactive_bg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_inactive_style) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_inactive_style)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_marked_fg) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_marked_fg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_marked_bg) as usize - ptr as usize },
        110usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_marked_bg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_ignored_fg) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_ignored_fg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_ignored_bg) as usize - ptr as usize },
        122usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_ignored_bg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_colorized_fg) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_colorized_fg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_colorized_bg) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_colorized_bg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_geometry_save_position) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_geometry_save_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_geometry_save_size) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_geometry_save_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_geometry_save_maximized) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_geometry_save_maximized)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_recent_df_entries_max) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_recent_df_entries_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_recent_files_count_max) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_recent_files_count_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_fileopen_style) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_fileopen_style)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_fileopen_dir) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_fileopen_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_fileopen_preview) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_fileopen_preview)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_tlskeylog_command) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_tlskeylog_command)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_ask_unsaved) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_ask_unsaved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_autocomplete_filter) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_autocomplete_filter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_find_wrap) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_find_wrap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_window_title) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_window_title)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_prepend_window_title) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_prepend_window_title)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_start_title) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_start_title)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_version_placement) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_version_placement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_max_export_objects) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_max_export_objects)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_max_tree_items) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_max_tree_items)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_max_tree_depth) as usize - ptr as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_max_tree_depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_layout_type) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_layout_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_layout_content_1) as usize - ptr as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_layout_content_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_layout_content_2) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_layout_content_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_layout_content_3) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_layout_content_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_interfaces_hide_types) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_interfaces_hide_types)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_interfaces_show_hidden) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_interfaces_show_hidden)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).gui_interfaces_remote_display) as usize - ptr as usize
        },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_interfaces_remote_display)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).gui_io_graph_automatic_update) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_io_graph_automatic_update)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_io_graph_enable_legend) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_io_graph_enable_legend)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).gui_packet_details_show_byteview) as usize - ptr as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_packet_details_show_byteview)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capture_device) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(capture_device)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capture_devices_linktypes) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(capture_devices_linktypes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capture_devices_descr) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(capture_devices_descr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capture_devices_hide) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(capture_devices_hide)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).capture_devices_monitor_mode) as usize - ptr as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(capture_devices_monitor_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capture_devices_buffersize) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(capture_devices_buffersize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capture_devices_snaplen) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(capture_devices_snaplen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capture_devices_pmode) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(capture_devices_pmode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capture_devices_filter) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(capture_devices_filter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capture_prom_mode) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(capture_prom_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capture_pcap_ng) as usize - ptr as usize },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(capture_pcap_ng)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capture_real_time) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(capture_real_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capture_update_interval) as usize - ptr as usize },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(capture_update_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capture_no_interface_load) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(capture_no_interface_load)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capture_no_extcap) as usize - ptr as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(capture_no_extcap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capture_show_info) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(capture_show_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capture_columns) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(capture_columns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tap_update_interval) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(tap_update_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_hidden_proto_items) as usize - ptr as usize },
        412usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(display_hidden_proto_items)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).display_byte_fields_with_spaces) as usize - ptr as usize
        },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(display_byte_fields_with_spaces)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).enable_incomplete_dissectors_check) as usize - ptr as usize
        },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(enable_incomplete_dissectors_check)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).incomplete_dissectors_check_debug) as usize - ptr as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(incomplete_dissectors_check_debug)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).strict_conversation_tracking_heuristics) as usize
                - ptr as usize
        },
        428usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(strict_conversation_tracking_heuristics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ignore_dup_frames) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(ignore_dup_frames)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ignore_dup_frames_cache_entries) as usize - ptr as usize
        },
        436usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(ignore_dup_frames_cache_entries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter_expressions_old) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(filter_expressions_old)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_update_enabled) as usize - ptr as usize },
        444usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_update_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_update_channel) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_update_channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_update_interval) as usize - ptr as usize },
        452usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_update_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_debounce_timer) as usize - ptr as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_debounce_timer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).saved_at_version) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(saved_at_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unknown_prefs) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(unknown_prefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_packet_list_separator) as usize - ptr as usize },
        476usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_packet_list_separator)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).gui_packet_header_column_definition) as usize - ptr as usize
        },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_packet_header_column_definition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_packet_list_hover_style) as usize - ptr as usize },
        484usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_packet_list_hover_style)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_show_selected_packet) as usize - ptr as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_show_selected_packet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_show_file_load_time) as usize - ptr as usize },
        492usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_show_file_load_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_packet_list_elide_mode) as usize - ptr as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_packet_list_elide_mode)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).gui_packet_list_show_related) as usize - ptr as usize
        },
        500usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_packet_list_show_related)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).gui_packet_list_show_minimap) as usize - ptr as usize
        },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_packet_list_show_minimap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_packet_list_sortable) as usize - ptr as usize },
        508usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_packet_list_sortable)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).gui_packet_list_cached_rows_max) as usize - ptr as usize
        },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_packet_list_cached_rows_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_decimal_places1) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_decimal_places1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_decimal_places2) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_decimal_places2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_decimal_places3) as usize - ptr as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_decimal_places3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_rtp_player_use_disk1) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_rtp_player_use_disk1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui_rtp_player_use_disk2) as usize - ptr as usize },
        532usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(gui_rtp_player_use_disk2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_enable_burstinfo) as usize - ptr as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(st_enable_burstinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_burst_showcount) as usize - ptr as usize },
        540usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(st_burst_showcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_burst_resolution) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(st_burst_resolution)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_burst_windowlen) as usize - ptr as usize },
        548usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(st_burst_windowlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_sort_casesensitve) as usize - ptr as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(st_sort_casesensitve)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_sort_rng_fixorder) as usize - ptr as usize },
        556usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(st_sort_rng_fixorder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_sort_rng_nameonly) as usize - ptr as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(st_sort_rng_nameonly)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_sort_defcolflag) as usize - ptr as usize },
        564usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(st_sort_defcolflag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_sort_defdescending) as usize - ptr as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(st_sort_defdescending)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_sort_showfullname) as usize - ptr as usize },
        572usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(st_sort_showfullname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extcap_save_on_start) as usize - ptr as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_prefs),
            "::",
            stringify!(extcap_save_on_start)
        )
    );
}
pub type e_prefs = _e_prefs;
extern "C" {
    pub static mut prefs: e_prefs;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pref_module {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pref_custom_cbs {
    _unused: [u8; 0],
}
pub type module_t = pref_module;
extern "C" {
    #[doc = " Sets up memory used by proto routines. Called at program startup"]
    pub fn prefs_init();
}
extern "C" {
    #[doc = " Reset preferences to default values.  Called at profile change"]
    pub fn prefs_reset();
}
extern "C" {
    #[doc = " Frees memory used by proto routines. Called at program shutdown"]
    pub fn prefs_cleanup();
}
extern "C" {
    #[doc = " Store whether the current UI theme is dark so that we can adjust colors\n @param is_dark set to TRUE if the UI's theme is dark"]
    pub fn prefs_set_gui_theme_is_dark(is_dark: gboolean);
}
extern "C" {
    #[doc = " Register that a protocol has preferences.\n @param id the value returned by \"proto_register_protocol()\" when\n                the protocol was registered.\n @param apply_cb callback routine that is called when preferences are\n                      applied. It may be NULL, which inhibits the callback.\n @return a preferences module which can be used to register a user 'preference'"]
    pub fn prefs_register_protocol(
        id: ::std::os::raw::c_int,
        apply_cb: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> *mut module_t;
}
extern "C" {
    #[doc = " Register an alias for a preference module.\n @param name the preference module's alias. Only ASCII letters, numbers,\n                  underscores, hyphens, and dots may appear in the name\n @param module the module to create an alias for"]
    pub fn prefs_register_module_alias(name: *const ::std::os::raw::c_char, module: *mut module_t);
}
extern "C" {
    #[doc = " Deregister preferences from a protocol.\n @param id the value returned by \"proto_register_protocol()\" when\n                the protocol was registered."]
    pub fn prefs_deregister_protocol(id: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Register that a statistical tap has preferences.\n\n @param name the name for the tap to use on the command line with \"-o\"\n             and in preference files.\n @param title is a short human-readable name for the tap.\n @param description is a longer human-readable description of the tap.\n @param apply_cb routine to call back after we apply the preferences\n @return a preferences module which can be used to register a user 'preference'"]
    pub fn prefs_register_stat(
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        apply_cb: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> *mut module_t;
}
extern "C" {
    #[doc = " Register that a codec has preferences.\n\n @param name is a name for the codec to use on the command line with \"-o\"\n             and in preference files.\n @param title is a short human-readable name for the codec.\n @param description is a longer human-readable description of the codec.\n @param apply_cb routine to call back after we apply the preferences\n @return a preferences module which can be used to register a user 'preference'"]
    pub fn prefs_register_codec(
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        apply_cb: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> *mut module_t;
}
extern "C" {
    #[doc = " Register that a protocol has preferences and group it under a single\n subtree\n @param subtree the tree node name for grouping preferences\n                the protocol was registered.\n @param id the value returned by \"proto_register_protocol()\" when\n                the protocol was registered.\n @param apply_cb Callback routine that is called when preferences are\n                      applied. It may be NULL, which inhibits the callback.\n @return a preferences module which can be used to register a user 'preference'"]
    pub fn prefs_register_protocol_subtree(
        subtree: *const ::std::os::raw::c_char,
        id: ::std::os::raw::c_int,
        apply_cb: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> *mut module_t;
}
extern "C" {
    #[doc = " Register that a protocol used to have preferences but no longer does,\n by creating an \"obsolete\" module for it.\n @param id the value returned by \"proto_register_protocol()\" when\n                the protocol was registered.\n @return a preferences module which can be used to register a user 'preference'"]
    pub fn prefs_register_protocol_obsolete(id: ::std::os::raw::c_int) -> *mut module_t;
}
#[doc = " Callback function for module list scanners."]
pub type module_cb = ::std::option::Option<
    unsafe extern "C" fn(module: *mut module_t, user_data: gpointer) -> guint,
>;
extern "C" {
    #[doc = " Returns TRUE if a preferences module has any submodules\n @param module a preferences module which can be used to register a user 'preference'\n @return TRUE if a preferences module has any submodules, otherwise FALSE"]
    pub fn prefs_module_has_submodules(module: *mut module_t) -> gboolean;
}
extern "C" {
    #[doc = " Call a callback function, with a specified argument, for each module\n in the list of all modules.  (This list does not include subtrees.)\n\n Ignores \"obsolete\" modules; their sole purpose is to allow old\n preferences for dissectors that no longer have preferences to be\n silently ignored in preference files.\n\n @param callback the callback to call\n @param user_data additional data to pass to the callback"]
    pub fn prefs_modules_foreach(callback: module_cb, user_data: gpointer) -> guint;
}
extern "C" {
    #[doc = " Call a callback function, with a specified argument, for each submodule\n of a specified module. If the module is NULL, goes through the top-level\n list in the display tree of modules.\n\n Ignores \"obsolete\" modules; their sole purpose is to allow old\n preferences for dissectors that no longer have preferences to be\n silently ignored in preference files.  Does not ignore subtrees,\n as this can be used when walking the display tree of modules.\n\n @param module the top-level module to walk through the submodules,\n               or NULL for the top-level list in the display tree of modules\n @param callback the callback to call\n @param user_data additional data to pass to the callback"]
    pub fn prefs_modules_foreach_submodules(
        module: *mut module_t,
        callback: module_cb,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    #[doc = " Call the \"apply\" callback function for each module if any of its\n preferences have changed, and then clear the flag saying its\n preferences have changed, as the module has been notified of that\n fact."]
    pub fn prefs_apply_all();
}
extern "C" {
    #[doc = " Call the \"apply\" callback function for a specific module if any of\n its preferences have changed, and then clear the flag saying its\n preferences have changed, as the module has been notified of that\n fact.\n @param module the module to call the 'apply' callback function for"]
    pub fn prefs_apply(module: *mut module_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct preference {
    _unused: [u8; 0],
}
pub type pref_t = preference;
extern "C" {
    #[doc = " Returns TRUE if the provided protocol has registered preferences.\n @param name the name of the protocol to look up\n @return TRUE if the given protocol has registered preferences, otherwise FALSE"]
    pub fn prefs_is_registered_protocol(name: *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    #[doc = " Returns the module title of a registered protocol (or NULL if unknown).\n @param name the name of the protocol to look up\n @return the module title of a registered protocol, otherwise NULL"]
    pub fn prefs_get_title_by_name(
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Given a module name, return a pointer to its pref_module struct,\n or NULL if it's not found.\n\n @param name The preference module name.  Usually the same as the protocol\n name, e.g. \"tcp\".\n @return A pointer to the corresponding preference module, or NULL if it\n wasn't found."]
    pub fn prefs_find_module(name: *const ::std::os::raw::c_char) -> *mut module_t;
}
extern "C" {
    #[doc = " Given a module and a preference name, return a pointer to the given\n module's given preference or NULL if it's not found.\n\n @param module The preference module name.  Usually the same as the protocol\n name, e.g. \"tcp\".\n @param pref The preference name, e.g. \"desegment\".\n @return A pointer to the corresponding preference, or NULL if it\n wasn't found."]
    pub fn prefs_find_preference(
        module: *mut module_t,
        pref: *const ::std::os::raw::c_char,
    ) -> *mut pref_t;
}
extern "C" {
    #[doc = " Register a preference with an unsigned integral value.\n @param module the preferences module returned by prefs_register_protocol() or\n               prefs_register_protocol_subtree()\n @param name the preference's identifier. This is appended to the name of the\n             protocol, with a \".\" between them, to create a unique identifier.\n             The identifier should not include the protocol name, as\n             the preference file will already have it. Make sure that\n             only lower-case ASCII letters, numbers, underscores and\n             dots appear in the preference name.\n @param title the title in the preferences dialog\n @param description the description included in the preferences file\n                    and shown as tooltip in the GUI, or NULL\n @param base the base the unsigned integer is expected to be in. See strtoul(3)\n @param var pointer to the storage location that is updated when the\n                    field is changed in the preference dialog box"]
    pub fn prefs_register_uint_preference(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        base: guint,
        var: *mut guint,
    );
}
extern "C" {
    #[doc = " Register a preference with an Boolean value.\n @param module the preferences module returned by prefs_register_protocol() or\n               prefs_register_protocol_subtree()\n @param name the preference's identifier. This is appended to the name of the\n             protocol, with a \".\" between them, to create a unique identifier.\n             The identifier should not include the protocol name, as the name in\n             the preference file will already have it. Make sure that\n             only lower-case ASCII letters, numbers, underscores and\n             dots appear in the preference name.\n @param title Field's title in the preferences dialog\n @param description description to include in the preferences file\n                    and shown as tooltip in the GUI, or NULL\n @param var pointer to the storage location that is updated when the\n                    field is changed in the preference dialog box"]
    pub fn prefs_register_bool_preference(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        var: *mut gboolean,
    );
}
extern "C" {
    #[doc = " Register a preference with an enumerated value.\n @param module the preferences module returned by prefs_register_protocol() or\n               prefs_register_protocol_subtree()\n @param name the preference's identifier. This is appended to the name of the\n             protocol, with a \".\" between them, to create a unique identifier.\n             The identifier should not include the protocol name, as the name in\n             the preference file will already have it. Make sure that\n             only lower-case ASCII letters, numbers, underscores and\n             dots appear in the preference name.\n @param title Field's title in the preferences dialog\n @param description description to include in the preferences file\n                    and shown as tooltip in the GUI, or NULL\n @param var pointer to the storage location that is updated when the\n                    field is changed in the preference dialog box\n @param enumvals a null-terminated array of enum_val_t structures\n @param radio_buttons TRUE if the field is to be displayed in the\n                  preferences dialog as a set of radio buttons,\n                  FALSE if it is to be displayed as an option menu"]
    pub fn prefs_register_enum_preference(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        var: *mut gint,
        enumvals: *const enum_val_t,
        radio_buttons: gboolean,
    );
}
extern "C" {
    #[doc = " Register a preference with a character-string value.\n @param module the preferences module returned by prefs_register_protocol() or\n               prefs_register_protocol_subtree()\n @param name the preference's identifier. This is appended to the name of the\n             protocol, with a \".\" between them, to create a unique identifier.\n             The identifier should not include the protocol name, as the name in\n             the preference file will already have it. Make sure that\n             only lower-case ASCII letters, numbers, underscores and\n             dots appear in the preference name.\n @param title Field's title in the preferences dialog\n @param description description to include in the preferences file\n                    and shown as tooltip in the GUI, or NULL\n @param var pointer to the storage location that is updated when the\n                    field is changed in the preference dialog box. Note that\n          with string preferences the given pointer is overwritten\n          with a pointer to a new copy of the string during the\n          preference registration. The passed-in string may be\n          freed, but you must keep another pointer to the string\n          in order to free it"]
    pub fn prefs_register_string_preference(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        var: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Register a preference with a file name (string) value.\n\n File name preferences are basically like string preferences\n except that the GUI gives the user the ability to browse for the\n file.\n\n @param module the preferences module returned by prefs_register_protocol() or\n               prefs_register_protocol_subtree()\n @param name the preference's identifier. This is appended to the name of the\n             protocol, with a \".\" between them, to create a unique identifier.\n             The identifier should not include the protocol name, as the name in\n             the preference file will already have it. Make sure that\n             only lower-case ASCII letters, numbers, underscores and\n             dots appear in the preference name.\n @param title Field's title in the preferences dialog\n @param description description to include in the preferences file\n                    and shown as tooltip in the GUI, or NULL\n @param var pointer to the storage location that is updated when the\n                    field is changed in the preference dialog box. Note that\n          the given pointer is overwritten\n          with a pointer to a new copy of the string during the\n          preference registration. The passed-in string may be\n          freed, but you must keep another pointer to the string\n          in order to free it\n @param for_writing TRUE to display a Save dialog, FALSE to display an Open dialog."]
    pub fn prefs_register_filename_preference(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        var: *mut *const ::std::os::raw::c_char,
        for_writing: gboolean,
    );
}
extern "C" {
    #[doc = " Register a preference with a directory name (string) value.\n Directory name preferences are basically like string preferences\n except that the GUI gives the user the ability to browse for a\n directory.\n @param module the preferences module returned by prefs_register_protocol() or\n               prefs_register_protocol_subtree()\n @param name the preference's identifier. This is appended to the name of the\n             protocol, with a \".\" between them, to create a unique identifier.\n             The identifier should not include the protocol name, as the name in\n             the preference file will already have it. Make sure that\n             only lower-case ASCII letters, numbers, underscores and\n             dots appear in the preference name.\n @param title Field's title in the preferences dialog\n @param description description to include in the preferences file\n                    and shown as tooltip in the GUI, or NULL\n @param var pointer to the storage location that is updated when the\n                    field is changed in the preference dialog box. Note that\n          the given pointer is overwritten\n          with a pointer to a new copy of the string during the\n          preference registration. The passed-in string may be\n          freed, but you must keep another pointer to the string\n          in order to free it"]
    pub fn prefs_register_directory_preference(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        var: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Register a preference with a ranged value.\n @param module the preferences module returned by prefs_register_protocol() or\n               prefs_register_protocol_subtree()\n @param name the preference's identifier. This is appended to the name of the\n             protocol, with a \".\" between them, to create a unique identifier.\n             The identifier should not include the protocol name, as the name in\n             the preference file will already have it. Make sure that\n             only lower-case ASCII letters, numbers, underscores and\n             dots appear in the preference name.\n @param title Field's title in the preferences dialog\n @param description description to include in the preferences file\n                    and shown as tooltip in the GUI, or NULL\n @param var pointer to the storage location that is updated when the\n                    field is changed in the preference dialog box.\n @param max_value the maximum allowed value for a range (0 is the minimum)"]
    pub fn prefs_register_range_preference(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        var: *mut *mut range_t,
        max_value: guint32,
    );
}
extern "C" {
    #[doc = " Register a static text 'preference'. It can be used to add some info/explanation.\n @param module the preferences module returned by prefs_register_protocol() or\n               prefs_register_protocol_subtree()\n @param name the preference's identifier. This is appended to the name of the\n             protocol, with a \".\" between them, to create a unique identifier.\n             The identifier should not include the protocol name, as the name in\n             the preference file will already have it. Make sure that\n             only lower-case ASCII letters, numbers, underscores and\n             dots appear in the preference name.\n @param title Field's title in the preferences dialog\n @param description description to include in the preferences file\n                    and shown as tooltip in the GUI, or NULL"]
    pub fn prefs_register_static_text_preference(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Register a uat (User Accessible Table) 'preference'. It adds a button that opens the uat's window in the\n preferences tab of the module.\n @param module the preferences module returned by prefs_register_protocol() or\n               prefs_register_protocol_subtree()\n @param name the preference's identifier. This is appended to the name of the\n             protocol, with a \".\" between them, to create a unique identifier.\n             The identifier should not include the protocol name, as the name in\n             the preference file will already have it. Make sure that\n             only lower-case ASCII letters, numbers, underscores and\n             dots appear in the preference name.\n @param title Field's title in the preferences dialog\n @param description description to include in the preferences file\n                    and shown as tooltip in the GUI, or NULL\n @param uat the uat object that will be updated when the\n                    field is changed in the preference dialog box"]
    pub fn prefs_register_uat_preference(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        uat: *mut epan_uat,
    );
}
extern "C" {
    #[doc = " Register a uat 'preference' for QT only. It adds a button that opens the uat's window in the\n preferences tab of the module.\n @param module the preferences module returned by prefs_register_protocol() or\n               prefs_register_protocol_subtree()\n @param name the preference's identifier. This is appended to the name of the\n             protocol, with a \".\" between them, to create a unique identifier.\n             The identifier should not include the protocol name, as the name in\n             the preference file will already have it. Make sure that\n             only lower-case ASCII letters, numbers, underscores and\n             dots appear in the preference name.\n @param title Field's title in the preferences dialog\n @param description description to include in the preferences file\n                    and shown as tooltip in the GUI, or NULL\n @param uat the uat object that will be updated when the\n                    field is changed in the preference dialog box"]
    pub fn prefs_register_uat_preference_qt(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        uat: *mut epan_uat,
    );
}
extern "C" {
    #[doc = " Register a color preference.  Currently does not have any \"GUI Dialog\" support\n so the color data needs to be managed independently.  Currently used by the\n \"GUI preferences\" to aid in reading/writing the preferences file, but the\n \"data\" is still managed by the specific \"GUI preferences\" dialog.\n\n @param module the preferences module returned by prefs_register_protocol() or\n               prefs_register_protocol_subtree()\n @param name the preference's identifier. This is appended to the name of the\n             protocol, with a \".\" between them, to create a unique identifier.\n             The identifier should not include the protocol name, as the name in\n             the preference file will already have it. Make sure that\n             only lower-case ASCII letters, numbers, underscores and\n             dots appear in the preference name.\n @param title Field's title in the preferences dialog\n @param description description to include in the preferences file\n                    and shown as tooltip in the GUI, or NULL\n @param color the color object that will be updated when the\n                    field is changed in the preference dialog box"]
    pub fn prefs_register_color_preference(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        color: *mut color_t,
    );
}
extern "C" {
    #[doc = " Register a custom preference.  Currently does not have any \"GUI Dialog\" support\n so data needs to be managed independently.  Currently used by the\n \"GUI preferences\" to aid in reading/writing the preferences file, but the\n \"data\" is still managed by the specific \"GUI preferences\" dialog.\n\n @param module the preferences module returned by prefs_register_protocol() or\n               prefs_register_protocol_subtree()\n @param name the preference's identifier. This is appended to the name of the\n             protocol, with a \".\" between them, to create a unique identifier.\n             The identifier should not include the protocol name, as the name in\n             the preference file will already have it. Make sure that\n             only lower-case ASCII letters, numbers, underscores and\n             dots appear in the preference name.\n @param title Field's title in the preferences dialog\n @param description description to include in the preferences file\n                    and shown as tooltip in the GUI, or NULL\n @param custom_cbs a structure with the custom preference's callbacks\n @param custom_data currently unused"]
    pub fn prefs_register_custom_preference(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        custom_cbs: *mut pref_custom_cbs,
        custom_data: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Register a (internal) \"Decode As\" preference with a ranged value.\n @param module the preferences module returned by prefs_register_protocol() or\n               prefs_register_protocol_subtree()\n @param name the preference's identifier. This is appended to the name of the\n             protocol, with a \".\" between them, to create a unique identifier.\n             The identifier should not include the protocol name, as the name in\n             the preference file will already have it. Make sure that\n             only lower-case ASCII letters, numbers, underscores and\n             dots appear in the preference name.\n @param title Field's title in the preferences dialog\n @param description description to include in the preferences file\n                    and shown as tooltip in the GUI, or NULL\n @param var pointer to the storage location that is updated when the\n                    field is changed in the preference dialog box.\n @param max_value the maximum allowed value for a range (0 is the minimum)"]
    pub fn prefs_register_decode_as_range_preference(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        var: *mut *mut range_t,
        max_value: guint32,
    );
}
extern "C" {
    #[doc = " Register a preference with an password (password is never stored).\n @param module the preferences module returned by prefs_register_protocol() or\n               prefs_register_protocol_subtree()\n @param name the preference's identifier. This is appended to the name of the\n             protocol, with a \".\" between them, to create a unique identifier.\n             The identifier should not include the protocol name, as\n             the preference file will already have it. Make sure that\n             only lower-case ASCII letters, numbers, underscores and\n             dots appear in the preference name.\n @param title the title in the preferences dialog\n @param description the description included in the preferences file\n                    and shown as tooltip in the GUI, or NULL\n @param var pointer to the storage location that is updated when the\n                    field is changed in the preference dialog box"]
    pub fn prefs_register_password_preference(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        var: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Register a preference that used to be supported but no longer is.\n\n Note that a warning will pop up if you've saved such preference to the\n preference file and you subsequently take the code out. The way to make\n a preference obsolete is to register it with prefs_register_obsolete_preference()\n\n @param module the preferences module returned by prefs_register_protocol() or\n               prefs_register_protocol_subtree()\n @param name the preference's identifier. This is appended to the name of the\n             protocol, with a \".\" between them, to create a unique identifier.\n             The identifier should not include the protocol name, as the name in\n             the preference file will already have it. Make sure that\n             only lower-case ASCII letters, numbers, underscores and\n             dots appear in the preference name."]
    pub fn prefs_register_obsolete_preference(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Register a preference with an enumerated value.\n @param module the preferences module returned by prefs_register_protocol() or\n               prefs_register_protocol_subtree()\n @param name the preference's identifier. This is appended to the name of the\n             protocol, with a \".\" between them, to create a unique identifier.\n             The identifier should not include the protocol name, as the name in\n             the preference file will already have it. Make sure that\n             only lower-case ASCII letters, numbers, underscores and\n             dots appear in the preference name.\n @param title Field's title in the preferences dialog\n @param description description to include in the preferences file\n                    and shown as tooltip in the GUI, or NULL\n @param var pointer to the storage location that is updated when the\n                    field is changed in the preference dialog box\n @param enumvals a null-terminated array of enum_val_t structures\n @param radio_buttons TRUE if the field is to be displayed in the\n                  preferences dialog as a set of radio buttons,\n                  FALSE if it is to be displayed as an option menu"]
    pub fn prefs_register_custom_preference_TCP_Analysis(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        var: *mut gint,
        enumvals: *const enum_val_t,
        radio_buttons: gboolean,
    );
}
extern "C" {
    #[doc = " Mark a preference that affects fields change. This works for bool, enum,\n int, string (containing filename), range preferences. UAT is not included,\n because you can specified UAT_AFFECTS_FIELDS at uat_new().\n\n @param module the preferences module returned by prefs_register_protocol() or\n               prefs_register_protocol_subtree()\n @param name the preference's identifier. This is appended to the name of the\n             protocol, with a \".\" between them, to create a unique identifier.\n             The identifier should not include the protocol name, as the name in\n             the preference file will already have it. Make sure that\n             only lower-case ASCII letters, numbers, underscores and\n             dots appear in the preference name."]
    pub fn prefs_set_preference_effect_fields(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
    );
}
pub type pref_cb =
    ::std::option::Option<unsafe extern "C" fn(pref: *mut pref_t, user_data: gpointer) -> guint>;
extern "C" {
    #[doc = " Call a callback function, with a specified argument, for each preference\n in a given module.\n\n If any of the callbacks return a non-zero value, stop and return that\n value, otherwise return 0.\n\n @param module the preferences module returned by prefs_register_protocol() or\n               prefs_register_protocol_subtree()\n @param callback the callback to call\n @param user_data additional data to pass to the callback\n @return If any of the callbacks return a non-zero value, stop and return that\n         value, otherwise return 0."]
    pub fn prefs_pref_foreach(
        module: *mut module_t,
        callback: pref_cb,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    #[doc = " Parse through a list of comma-separated, possibly quoted strings.\n Return a list of the string data.\n\n Commas, whitespace, and the quotes surrounding entries are removed.\n Quotes and backslashes escaped with a backslash (\\\") will remain.\n\n @param str a list of comma-separated, possibly quoted strings\n @return a list of the string data, or NULL if there's an error"]
    pub fn prefs_get_string_list(str_: *const gchar) -> *mut GList;
}
extern "C" {
    #[doc = " Clear the given list of string data.\n @param sl the GList to clear"]
    pub fn prefs_clear_string_list(sl: *mut GList);
}
extern "C" {
    #[doc = " Fetch a short preference type name, e.g. \"Integer\".\n\n @param pref A preference.\n\n @return The preference type name. May be NULL."]
    pub fn prefs_pref_type_name(pref: *mut pref_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Fetch a long description of the preference type\n\n @param pref A preference.\n\n @return A description of the preference type including allowed\n values for enums. The description may include newlines. Must be\n g_free()d."]
    pub fn prefs_pref_type_description(pref: *mut pref_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Fetch a string representation of the preference.\n\n @param pref A preference.\n @param source Which value of the preference to return, see pref_source_t.\n\n @return A string representation of the preference. Must be g_free()d."]
    pub fn prefs_pref_to_str(
        pref: *mut pref_t,
        source: pref_source_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Read the preferences file, fill in \"prefs\", and return a pointer to it.\n If we got an error (other than \"it doesn't exist\") we report it through\n the UI.\n\n This is called by epan_load_settings(); programs should call that\n rather than individually calling the routines it calls.\n\n @return a pointer to the filled in prefs object"]
    pub fn read_prefs() -> *mut e_prefs;
}
extern "C" {
    #[doc = " Write out \"prefs\" to the user's preferences file, and return 0.\n\n If we got an error, stuff a pointer to the path of the preferences file\n into \"*pf_path_return\", and return the errno.\n\n @param pf_path_return The path to write preferences to or NULL for stdout\n @return 0 if success, otherwise errno"]
    pub fn write_prefs(pf_path_return: *mut *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
pub const prefs_set_pref_e_PREFS_SET_OK: prefs_set_pref_e = 0;
pub const prefs_set_pref_e_PREFS_SET_SYNTAX_ERR: prefs_set_pref_e = 1;
pub const prefs_set_pref_e_PREFS_SET_NO_SUCH_PREF: prefs_set_pref_e = 2;
pub const prefs_set_pref_e_PREFS_SET_OBSOLETE: prefs_set_pref_e = 3;
#[doc = " Result of setting a preference."]
pub type prefs_set_pref_e = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Given a string of the form \"<pref name>:<pref value>\", as might appear\n as an argument to a \"-o\" option, parse it and set the preference in\n question.  Return an indication of whether it succeeded or failed\n in some fashion.\n\n For syntax errors (return value PREFS_SET_SYNTAX_ERR), details (when\n available) are written into \"errmsg\" which must be freed with g_free.\n\n @param prefarg a string of the form \"<pref name>:<pref value>\"\n @param errmsg storage for syntax error details\n @return the result from attempting to set the preference"]
    pub fn prefs_set_pref(
        prefarg: *mut ::std::os::raw::c_char,
        errmsg: *mut *mut ::std::os::raw::c_char,
    ) -> prefs_set_pref_e;
}
extern "C" {
    #[doc = " Get or set a preference's obsolete status. These can be used to make a\n preference obsolete after startup so that we can fetch its value but\n keep it from showing up in the prefrences dialog.\n\n @param pref A preference.\n @return TRUE if the preference is obsolete, otherwise FALSE"]
    pub fn prefs_get_preference_obsolete(pref: *mut pref_t) -> gboolean;
}
extern "C" {
    #[doc = " Make a preference obsolete\n\n @param pref a preference.\n @return the result from attempting to set the preference"]
    pub fn prefs_set_preference_obsolete(pref: *mut pref_t) -> prefs_set_pref_e;
}
extern "C" {
    #[doc = " Get current preference uint value. This allows the preference structure\n to remain hidden from those that doesn't really need it\n\n @param module_name the preference module name. Usually the same as the protocol\n                    name, e.g. \"tcp\".\n @param pref_name the preference name, e.g. \"desegment\".\n @return the preference's value"]
    pub fn prefs_get_uint_value(
        module_name: *const ::std::os::raw::c_char,
        pref_name: *const ::std::os::raw::c_char,
    ) -> guint;
}
extern "C" {
    #[doc = " Get the current range preference value (maintained by pref, so it doesn't need to be freed). This allows the\n preference structure to remain hidden from those that doesn't really need it.\n\n @param module_name the preference module name. Usually the same as the protocol\n                    name, e.g. \"tcp\".\n @param pref_name the preference name, e.g. \"desegment\".\n @return the preference's value"]
    pub fn prefs_get_range_value(
        module_name: *const ::std::os::raw::c_char,
        pref_name: *const ::std::os::raw::c_char,
    ) -> *mut range_t;
}
extern "C" {
    #[doc = " Returns TRUE if the specified capture device is hidden\n @param name the name of the capture device\n @return TRUE if the specified capture device is hidden, otherwise FALSE"]
    pub fn prefs_is_capture_device_hidden(name: *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    #[doc = " Returns TRUE if the given device should capture in monitor mode by default\n @param name the name of the capture device\n @return TRUE if the specified capture device should capture in monitor mode by default, otherwise FALSE"]
    pub fn prefs_capture_device_monitor_mode(name: *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    #[doc = " Returns TRUE if the user has marked this column as visible\n\n @param column the name of the column\n @return TRUE if this column as visible, otherwise FALSE"]
    pub fn prefs_capture_options_dialog_column_is_visible(column: *const gchar) -> gboolean;
}
extern "C" {
    #[doc = " Returns TRUE if the layout pane content is enabled\n\n @param layout_pane_content the layout pane content to check\n @return TRUE if the layout pane content is enabled, otherwise FALSE"]
    pub fn prefs_has_layout_pane_content(layout_pane_content: layout_pane_content_e) -> gboolean;
}
extern "C" {
    #[doc = " Global variable holding the content of the corresponding environment variable\n to save fetching it repeatedly."]
    pub static mut wireshark_abort_on_dissector_bug: gboolean;
}
extern "C" {
    pub static mut wireshark_abort_on_too_many_items: gboolean;
}
pub type epan_dissect_t = epan_dissect;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epan_dfilter {
    _unused: [u8; 0],
}
#[doc = "  Helper routines for column utility structures and routines."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epan_column_info {
    _unused: [u8; 0],
}
#[doc = " Opaque structure provided when an epan_t is created; it contains\n information needed to allow the user of libwireshark to provide\n time stamps, comments, and other information outside the packet\n data itself."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct packet_provider_data {
    _unused: [u8; 0],
}
#[doc = " Structure containing pointers to functions supplied by the user\n of libwireshark."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct packet_provider_funcs {
    pub get_frame_ts: ::std::option::Option<
        unsafe extern "C" fn(
            prov: *mut packet_provider_data,
            frame_num: guint32,
        ) -> *const nstime_t,
    >,
    pub get_interface_name: ::std::option::Option<
        unsafe extern "C" fn(
            prov: *mut packet_provider_data,
            interface_id: guint32,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub get_interface_description: ::std::option::Option<
        unsafe extern "C" fn(
            prov: *mut packet_provider_data,
            interface_id: guint32,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub get_modified_block: ::std::option::Option<
        unsafe extern "C" fn(
            prov: *mut packet_provider_data,
            fd: *const frame_data,
        ) -> wtap_block_t,
    >,
}
#[test]
fn bindgen_test_layout_packet_provider_funcs() {
    const UNINIT: ::std::mem::MaybeUninit<packet_provider_funcs> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<packet_provider_funcs>(),
        32usize,
        concat!("Size of: ", stringify!(packet_provider_funcs))
    );
    assert_eq!(
        ::std::mem::align_of::<packet_provider_funcs>(),
        8usize,
        concat!("Alignment of ", stringify!(packet_provider_funcs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_frame_ts) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(packet_provider_funcs),
            "::",
            stringify!(get_frame_ts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_interface_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(packet_provider_funcs),
            "::",
            stringify!(get_interface_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_interface_description) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(packet_provider_funcs),
            "::",
            stringify!(get_interface_description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_modified_block) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(packet_provider_funcs),
            "::",
            stringify!(get_modified_block)
        )
    );
}
extern "C" {
    #[doc = " Init the whole epan module.\n\n Must be called only once in a program.\n\n Returns TRUE on success, FALSE on failure."]
    pub fn epan_init(
        cb: register_cb,
        client_data: *mut ::std::os::raw::c_void,
        load_plugins: gboolean,
    ) -> gboolean;
}
extern "C" {
    #[doc = " Load all settings, from the current profile, that affect epan."]
    pub fn epan_load_settings() -> *mut e_prefs;
}
extern "C" {
    #[doc = " cleanup the whole epan module, this is used to be called only once in a program"]
    pub fn epan_cleanup();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epan_plugin {
    pub init: ::std::option::Option<unsafe extern "C" fn()>,
    pub post_init: ::std::option::Option<unsafe extern "C" fn()>,
    pub dissect_init: ::std::option::Option<unsafe extern "C" fn(arg1: *mut epan_dissect_t)>,
    pub dissect_cleanup: ::std::option::Option<unsafe extern "C" fn(arg1: *mut epan_dissect_t)>,
    pub cleanup: ::std::option::Option<unsafe extern "C" fn()>,
    pub register_all_protocols:
        ::std::option::Option<unsafe extern "C" fn(arg1: register_cb, arg2: gpointer)>,
    pub register_all_handoffs:
        ::std::option::Option<unsafe extern "C" fn(arg1: register_cb, arg2: gpointer)>,
    pub register_all_tap_listeners: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_epan_plugin() {
    const UNINIT: ::std::mem::MaybeUninit<epan_plugin> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<epan_plugin>(),
        64usize,
        concat!("Size of: ", stringify!(epan_plugin))
    );
    assert_eq!(
        ::std::mem::align_of::<epan_plugin>(),
        8usize,
        concat!("Alignment of ", stringify!(epan_plugin))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(epan_plugin),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).post_init) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(epan_plugin),
            "::",
            stringify!(post_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dissect_init) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(epan_plugin),
            "::",
            stringify!(dissect_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dissect_cleanup) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(epan_plugin),
            "::",
            stringify!(dissect_cleanup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cleanup) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(epan_plugin),
            "::",
            stringify!(cleanup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_all_protocols) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(epan_plugin),
            "::",
            stringify!(register_all_protocols)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_all_handoffs) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(epan_plugin),
            "::",
            stringify!(register_all_handoffs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_all_tap_listeners) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(epan_plugin),
            "::",
            stringify!(register_all_tap_listeners)
        )
    );
}
extern "C" {
    pub fn epan_register_plugin(plugin: *const epan_plugin);
}
extern "C" {
    #[doc = " Returns_\n     0 if plugins can be loaded for all of libwireshark (tap, dissector, epan).\n     1 if plugins are not supported by the platform.\n    -1 if plugins were disabled in the build configuration."]
    pub fn epan_plugins_supported() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize the table of conversations.  Conversations are identified by\n their endpoints; they are used for protocols such as IP, TCP, and UDP,\n where packets contain endpoint information but don't contain a single\n value indicating to which flow the packet belongs."]
    pub fn epan_conversation_init();
}
#[doc = " A client will create one epan_t for an entire dissection session.\n A single epan_t will be used to analyze the entire sequence of packets,\n sequentially, in a single session. A session corresponds to a single\n packet trace file. The reasons epan_t exists is that some packets in\n some protocols cannot be decoded without knowledge of previous packets.\n This inter-packet \"state\" is stored in the epan_t."]
pub type epan_t = epan_session;
extern "C" {
    pub fn epan_new(
        prov: *mut packet_provider_data,
        funcs: *const packet_provider_funcs,
    ) -> *mut epan_t;
}
extern "C" {
    pub fn epan_get_modified_block(session: *const epan_t, fd: *const frame_data) -> wtap_block_t;
}
extern "C" {
    pub fn epan_get_interface_name(
        session: *const epan_t,
        interface_id: guint32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn epan_get_interface_description(
        session: *const epan_t,
        interface_id: guint32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn epan_get_frame_ts(session: *const epan_t, frame_num: guint32) -> *const nstime_t;
}
extern "C" {
    pub fn epan_free(session: *mut epan_t);
}
extern "C" {
    pub fn epan_get_version() -> *const gchar;
}
extern "C" {
    pub fn epan_get_version_number(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
        micro: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Set/unset the tree to always be visible when epan_dissect_init() is called.\n This state change sticks until cleared, rather than being done per function call.\n This is currently used when Lua scripts request all fields be generated.\n By default it only becomes visible if epan_dissect_init() makes it so, usually\n only when a packet is selected.\n Setting this overrides that so it's always visible, although it will still not be\n created if create_proto_tree is false in the call to epan_dissect_init().\n Clearing this reverts the decision to epan_dissect_init() and proto_tree_visible."]
    pub fn epan_set_always_visible(force: gboolean);
}
extern "C" {
    #[doc = " initialize an existing single packet dissection"]
    pub fn epan_dissect_init(
        edt: *mut epan_dissect_t,
        session: *mut epan_t,
        create_proto_tree: gboolean,
        proto_tree_visible: gboolean,
    );
}
extern "C" {
    #[doc = " get a new single packet dissection\n should be freed using epan_dissect_free() after packet dissection completed"]
    pub fn epan_dissect_new(
        session: *mut epan_t,
        create_proto_tree: gboolean,
        proto_tree_visible: gboolean,
    ) -> *mut epan_dissect_t;
}
extern "C" {
    pub fn epan_dissect_reset(edt: *mut epan_dissect_t);
}
extern "C" {
    #[doc = " Indicate whether we should fake protocols or not"]
    pub fn epan_dissect_fake_protocols(edt: *mut epan_dissect_t, fake_protocols: gboolean);
}
extern "C" {
    #[doc = " run a single packet dissection"]
    pub fn epan_dissect_run(
        edt: *mut epan_dissect_t,
        file_type_subtype: ::std::os::raw::c_int,
        rec: *mut wtap_rec,
        tvb: *mut tvbuff_t,
        fd: *mut frame_data,
        cinfo: *mut epan_column_info,
    );
}
extern "C" {
    pub fn epan_dissect_run_with_taps(
        edt: *mut epan_dissect_t,
        file_type_subtype: ::std::os::raw::c_int,
        rec: *mut wtap_rec,
        tvb: *mut tvbuff_t,
        fd: *mut frame_data,
        cinfo: *mut epan_column_info,
    );
}
extern "C" {
    #[doc = " run a single file packet dissection"]
    pub fn epan_dissect_file_run(
        edt: *mut epan_dissect_t,
        rec: *mut wtap_rec,
        tvb: *mut tvbuff_t,
        fd: *mut frame_data,
        cinfo: *mut epan_column_info,
    );
}
extern "C" {
    pub fn epan_dissect_file_run_with_taps(
        edt: *mut epan_dissect_t,
        rec: *mut wtap_rec,
        tvb: *mut tvbuff_t,
        fd: *mut frame_data,
        cinfo: *mut epan_column_info,
    );
}
extern "C" {
    #[doc = " Prime an epan_dissect_t's proto_tree using the fields/protocols used in a dfilter."]
    pub fn epan_dissect_prime_with_dfilter(edt: *mut epan_dissect_t, dfcode: *const epan_dfilter);
}
extern "C" {
    #[doc = " Prime an epan_dissect_t's proto_tree with a field/protocol specified by its hfid"]
    pub fn epan_dissect_prime_with_hfid(edt: *mut epan_dissect_t, hfid: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Prime an epan_dissect_t's proto_tree with a set of fields/protocols specified by their hfids in a GArray"]
    pub fn epan_dissect_prime_with_hfid_array(edt: *mut epan_dissect_t, hfids: *mut GArray);
}
extern "C" {
    #[doc = " fill the dissect run output into the packet list columns"]
    pub fn epan_dissect_fill_in_columns(
        edt: *mut epan_dissect_t,
        fill_col_exprs: gboolean,
        fill_fd_colums: gboolean,
    );
}
extern "C" {
    #[doc = " Check whether a dissected packet contains a given named field"]
    pub fn epan_dissect_packet_contains_field(
        edt: *mut epan_dissect_t,
        field_name: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    #[doc = " releases resources attached to the packet dissection. DOES NOT free the actual pointer"]
    pub fn epan_dissect_cleanup(edt: *mut epan_dissect_t);
}
extern "C" {
    #[doc = " free a single packet dissection"]
    pub fn epan_dissect_free(edt: *mut epan_dissect_t);
}
extern "C" {
    #[doc = " Sets custom column"]
    pub fn epan_custom_set(
        edt: *mut epan_dissect_t,
        ids: *mut GSList,
        occurrence: gint,
        result: *mut gchar,
        expr: *mut gchar,
        size: ::std::os::raw::c_int,
    ) -> *const gchar;
}
extern "C" {
    #[doc = " Get compile-time information for libraries used by libwireshark."]
    pub fn epan_gather_compile_info(l: feature_list);
}
extern "C" {
    #[doc = " Get runtime information for libraries used by libwireshark."]
    pub fn epan_gather_runtime_info(l: feature_list);
}
pub type column_info = epan_column_info;
#[doc = "< 0) Absolute date, as YYYY-MM-DD, and time"]
pub const COL_ABS_YMD_TIME: _bindgen_ty_1 = 0;
#[doc = "< 1) Absolute date, as YYYY/DOY, and time"]
pub const COL_ABS_YDOY_TIME: _bindgen_ty_1 = 1;
#[doc = "< 2) Absolute time"]
pub const COL_ABS_TIME: _bindgen_ty_1 = 2;
#[doc = "< 3) Cumulative number of bytes"]
pub const COL_CUMULATIVE_BYTES: _bindgen_ty_1 = 3;
#[doc = "< 4) Custom column (any filter name's contents)"]
pub const COL_CUSTOM: _bindgen_ty_1 = 4;
#[doc = "< 5) Delta time"]
pub const COL_DELTA_TIME: _bindgen_ty_1 = 5;
#[doc = "< 6) Delta time displayed"]
pub const COL_DELTA_TIME_DIS: _bindgen_ty_1 = 6;
#[doc = "< 7) Resolved dest"]
pub const COL_RES_DST: _bindgen_ty_1 = 7;
#[doc = "< 8) Unresolved dest"]
pub const COL_UNRES_DST: _bindgen_ty_1 = 8;
#[doc = "< 9) Resolved dest port"]
pub const COL_RES_DST_PORT: _bindgen_ty_1 = 9;
#[doc = "< 10) Unresolved dest port"]
pub const COL_UNRES_DST_PORT: _bindgen_ty_1 = 10;
#[doc = "< 11) Destination address"]
pub const COL_DEF_DST: _bindgen_ty_1 = 11;
#[doc = "< 12) Destination port"]
pub const COL_DEF_DST_PORT: _bindgen_ty_1 = 12;
#[doc = "< 13) Expert Info"]
pub const COL_EXPERT: _bindgen_ty_1 = 13;
#[doc = "< 14) FW-1 monitor interface/direction"]
pub const COL_IF_DIR: _bindgen_ty_1 = 14;
#[doc = "< 15) IEEE 802.11 (and WiMax?) - Channel"]
pub const COL_FREQ_CHAN: _bindgen_ty_1 = 15;
#[doc = "< 16) Data link layer dest address"]
pub const COL_DEF_DL_DST: _bindgen_ty_1 = 16;
#[doc = "< 17) Data link layer source address"]
pub const COL_DEF_DL_SRC: _bindgen_ty_1 = 17;
#[doc = "< 18) Resolved DL dest"]
pub const COL_RES_DL_DST: _bindgen_ty_1 = 18;
#[doc = "< 19) Unresolved DL dest"]
pub const COL_UNRES_DL_DST: _bindgen_ty_1 = 19;
#[doc = "< 20) Resolved DL source"]
pub const COL_RES_DL_SRC: _bindgen_ty_1 = 20;
#[doc = "< 21) Unresolved DL source"]
pub const COL_UNRES_DL_SRC: _bindgen_ty_1 = 21;
#[doc = "< 22) IEEE 802.11 - received signal strength"]
pub const COL_RSSI: _bindgen_ty_1 = 22;
#[doc = "< 23) IEEE 802.11 - TX rate in Mbps"]
pub const COL_TX_RATE: _bindgen_ty_1 = 23;
#[doc = "< 24) IP DSCP Value"]
pub const COL_DSCP_VALUE: _bindgen_ty_1 = 24;
#[doc = "< 25) Description"]
pub const COL_INFO: _bindgen_ty_1 = 25;
#[doc = "< 26) Resolved net dest"]
pub const COL_RES_NET_DST: _bindgen_ty_1 = 26;
#[doc = "< 27) Unresolved net dest"]
pub const COL_UNRES_NET_DST: _bindgen_ty_1 = 27;
#[doc = "< 28) Resolved net source"]
pub const COL_RES_NET_SRC: _bindgen_ty_1 = 28;
#[doc = "< 29) Unresolved net source"]
pub const COL_UNRES_NET_SRC: _bindgen_ty_1 = 29;
#[doc = "< 30) Network layer dest address"]
pub const COL_DEF_NET_DST: _bindgen_ty_1 = 30;
#[doc = "< 31) Network layer source address"]
pub const COL_DEF_NET_SRC: _bindgen_ty_1 = 31;
#[doc = "< 32) Packet list item number"]
pub const COL_NUMBER: _bindgen_ty_1 = 32;
#[doc = "< 33) Packet length in bytes"]
pub const COL_PACKET_LENGTH: _bindgen_ty_1 = 33;
#[doc = "< 34) Protocol"]
pub const COL_PROTOCOL: _bindgen_ty_1 = 34;
#[doc = "< 35) Relative time"]
pub const COL_REL_TIME: _bindgen_ty_1 = 35;
#[doc = "< 36) Source address"]
pub const COL_DEF_SRC: _bindgen_ty_1 = 36;
#[doc = "< 37) Source port"]
pub const COL_DEF_SRC_PORT: _bindgen_ty_1 = 37;
#[doc = "< 38) Resolved source"]
pub const COL_RES_SRC: _bindgen_ty_1 = 38;
#[doc = "< 39) Unresolved source"]
pub const COL_UNRES_SRC: _bindgen_ty_1 = 39;
#[doc = "< 40) Resolved source port"]
pub const COL_RES_SRC_PORT: _bindgen_ty_1 = 40;
#[doc = "< 41) Unresolved source port"]
pub const COL_UNRES_SRC_PORT: _bindgen_ty_1 = 41;
#[doc = "< 42) UTC date, as YYYY-MM-DD, and time"]
pub const COL_UTC_YMD_TIME: _bindgen_ty_1 = 42;
#[doc = "< 43) UTC date, as YYYY/DOY, and time"]
pub const COL_UTC_YDOY_TIME: _bindgen_ty_1 = 43;
#[doc = "< 44) UTC time"]
pub const COL_UTC_TIME: _bindgen_ty_1 = 44;
#[doc = "< 45) Command line-specified time (default relative)"]
pub const COL_CLS_TIME: _bindgen_ty_1 = 45;
#[doc = "< 46) Should always be last"]
pub const NUM_COL_FMTS: _bindgen_ty_1 = 46;
#[doc = " All of the possible columns in summary listing.\n\n NOTE1: The entries MUST remain in this order, or else you need to reorder\n        the slist[] and dlist[] arrays in column.c to match!\n\n NOTE2: Please add the COL_XYZ entry in the appropriate spot, such that the\n        dlist[] array remains in alphabetical order!"]
pub type _bindgen_ty_1 = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Are the columns writable?\n\n @param cinfo the current packet row\n @param col the writable column, -1 for checking the state of all columns\n @return TRUE if it's writable, FALSE if not"]
    pub fn col_get_writable(cinfo: *mut column_info, col: gint) -> gboolean;
}
extern "C" {
    #[doc = " Set the columns writable.\n\n @param cinfo the current packet row\n @param col the column to set, -1 for all\n @param writable TRUE if it's writable, FALSE if not"]
    pub fn col_set_writable(cinfo: *mut column_info, col: gint, writable: gboolean);
}
extern "C" {
    #[doc = " Sets a fence for the current column content,\n so this content won't be affected by further col_... function calls.\n\n This can be useful if a protocol is more than once in a single packet,\n e.g. multiple HTTP calls in a single TCP packet.\n\n @param cinfo the current packet row\n @param col the column to use, e.g. COL_INFO"]
    pub fn col_set_fence(cinfo: *mut column_info, col: gint);
}
extern "C" {
    #[doc = " Clears a fence for the current column content\n\n This can be useful if a protocol wants to remove whatever\n a previous protocol has added to the column.\n\n @param cinfo the current packet row\n @param col the column to use, e.g. COL_INFO"]
    pub fn col_clear_fence(cinfo: *mut column_info, col: gint);
}
extern "C" {
    #[doc = " Gets the text of a column element.\n\n @param cinfo the current packet row\n @param col the column to use, e.g. COL_INFO\n\n @return the text string"]
    pub fn col_get_text(cinfo: *mut column_info, col: gint) -> *const gchar;
}
extern "C" {
    #[doc = " Clears the text of a column element.\n\n @param cinfo the current packet row\n @param col the column to use, e.g. COL_INFO"]
    pub fn col_clear(cinfo: *mut column_info, col: gint);
}
extern "C" {
    #[doc = " Set (replace) the text of a column element, the text won't be formatted or copied.\n\n Use this for simple static strings like protocol names. Don't use for untrusted strings\n or strings that may contain unprintable characters.\n\n Usually used to set const strings!\n\n @param cinfo the current packet row\n @param col the column to use, e.g. COL_INFO\n @param str the string to set"]
    pub fn col_set_str(cinfo: *mut column_info, col: gint, str_: *const gchar);
}
extern "C" {
    #[doc = " Add (replace) the text of a column element, the text will be formatted and copied.\n\n Unprintable characters according to isprint() are escaped.\n\n @param cinfo the current packet row\n @param col the column to use, e.g. COL_INFO\n @param str the string to add"]
    pub fn col_add_str(cinfo: *mut column_info, col: gint, str_: *const gchar);
}
extern "C" {
    pub fn col_add_lstr(cinfo: *mut column_info, el: gint, str_: *const gchar, ...);
}
extern "C" {
    #[doc = " Add (replace) the text of a column element, the text will be formatted and copied.\n\n Unprintable characters according to isprint() are escaped.\n\n Same function as col_add_str() but using a printf-like format string.\n\n @param cinfo the current packet row\n @param col the column to use, e.g. COL_INFO\n @param format the format string\n @param ... the variable number of parameters"]
    pub fn col_add_fstr(cinfo: *mut column_info, col: gint, format: *const gchar, ...);
}
extern "C" {
    #[doc = " Append the given text to a column element, the text will be formatted and copied.\n\n Unprintable characters according to isprint() are escaped.\n\n @param cinfo the current packet row\n @param col the column to use, e.g. COL_INFO\n @param str the string to append"]
    pub fn col_append_str(cinfo: *mut column_info, col: gint, str_: *const gchar);
}
extern "C" {
    #[doc = " Append <abbrev>=<val> to a column element, the text will be copied.\n\n @param cinfo the current packet row\n @param col the column to use, e.g. COL_INFO\n @param abbrev the string to append\n @param val the value to append\n @param sep an optional separator to _prepend_ to abbrev"]
    pub fn col_append_str_uint(
        cinfo: *mut column_info,
        col: gint,
        abbrev: *const gchar,
        val: guint32,
        sep: *const gchar,
    );
}
extern "C" {
    #[doc = " Append a transport port pair to a column element, the text will be copied.\n\n @param cinfo the current packet row\n @param col the column to use, e.g. COL_INFO\n @param typ the port type to resolve, e.g. PT_UDP\n @param src the source port value to append\n @param dst the destination port value to append"]
    pub fn col_append_ports(
        cinfo: *mut column_info,
        col: gint,
        typ: port_type,
        src: guint16,
        dst: guint16,
    );
}
extern "C" {
    #[doc = " Append a frame number and signal that we have updated\n column information.\n\n @param pinfo the current packet info\n @param col the column to use, e.g. COL_INFO\n @param fmt_str format string, e.g. \"reassembled in %u\".\n @param frame_num frame number"]
    pub fn col_append_frame_number(
        pinfo: *mut packet_info,
        col: gint,
        fmt_str: *const gchar,
        frame_num: guint,
    );
}
extern "C" {
    pub fn col_append_lstr(cinfo: *mut column_info, el: gint, str_: *const gchar, ...);
}
extern "C" {
    #[doc = " Append the given text to a column element, the text will be formatted and copied.\n\n Unprintable characters according to isprint() are escaped.\n\n Same function as col_append_str() but using a printf-like format string.\n\n @param cinfo the current packet row\n @param col the column to use, e.g. COL_INFO\n @param format the format string\n @param ... the variable number of parameters"]
    pub fn col_append_fstr(cinfo: *mut column_info, col: gint, format: *const gchar, ...);
}
extern "C" {
    #[doc = " Prepend the given text to a column element, the text will be formatted and copied.\n\n Unprintable characters according to isprint() are escaped.\n\n @param cinfo the current packet row\n @param col the column to use, e.g. COL_INFO\n @param format the format string\n @param ... the variable number of parameters"]
    pub fn col_prepend_fstr(cinfo: *mut column_info, col: gint, format: *const gchar, ...);
}
extern "C" {
    #[doc = " Prepend the given text to a column element, the text will be formatted and copied.\n\n Unprintable characters according to isprint() are escaped.\n\n This function is similar to col_prepend_fstr() but this function will\n unconditionally set a fence to the end of the prepended data even if there\n were no fence before.\n The col_prepend_fstr() will only prepend the data before the fence IF\n there is already a fence created. This function will create a fence in case\n it does not yet exist."]
    pub fn col_prepend_fence_fstr(cinfo: *mut column_info, col: gint, format: *const gchar, ...);
}
extern "C" {
    #[doc = " Append the given text (prepended by a separator) to a column element.\n\n Unprintable characters according to isprint() are escaped.\n\n Much like col_append_str() but will prepend the given separator if the column isn't empty.\n\n @param cinfo the current packet row\n @param col the column to use, e.g. COL_INFO\n @param sep the separator string or NULL for default: \", \"\n @param str the string to append"]
    pub fn col_append_sep_str(
        cinfo: *mut column_info,
        col: gint,
        sep: *const gchar,
        str_: *const gchar,
    );
}
extern "C" {
    #[doc = " Append the given text (prepended by a separator) to a column element.\n\n Unprintable characters according to isprint() are escaped.\n\n Much like col_append_fstr() but will prepend the given separator if the column isn't empty.\n\n @param cinfo the current packet row\n @param col the column to use, e.g. COL_INFO\n @param sep the separator string or NULL for default: \", \"\n @param format the format string\n @param ... the variable number of parameters"]
    pub fn col_append_sep_fstr(
        cinfo: *mut column_info,
        col: gint,
        sep: *const gchar,
        format: *const gchar,
        ...
    );
}
extern "C" {
    #[doc = " Set the given (relative) time to a column element.\n\n Used by dissectors to set the time in a column\n\n @param cinfo\t\tthe current packet row\n @param col\t\tthe column to use, e.g. COL_INFO\n @param ts\t\tthe time to set in the column\n @param fieldname\tthe fieldname to use for creating a filter (when\n\t\t\t  applying/preparing/copying as filter)"]
    pub fn col_set_time(
        cinfo: *mut column_info,
        col: ::std::os::raw::c_int,
        ts: *const nstime_t,
        fieldname: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn set_fd_time(epan: *const epan_session, fd: *mut frame_data, buf: *mut gchar);
}
#[doc = " For BASE_UNIT_STRING, the display format for adding units"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unit_name_string {
    #[doc = "< name to use for 1 unit"]
    pub singular: *mut ::std::os::raw::c_char,
    #[doc = "< name to use for < 1 or > 1 units"]
    pub plural: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_unit_name_string() {
    const UNINIT: ::std::mem::MaybeUninit<unit_name_string> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<unit_name_string>(),
        16usize,
        concat!("Size of: ", stringify!(unit_name_string))
    );
    assert_eq!(
        ::std::mem::align_of::<unit_name_string>(),
        8usize,
        concat!("Alignment of ", stringify!(unit_name_string))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).singular) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_name_string),
            "::",
            stringify!(singular)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).plural) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_name_string),
            "::",
            stringify!(plural)
        )
    );
}
extern "C" {
    #[doc = " Returns the unit string appropriate for the 32 bit value.\n\n From the given unit_name_string return the appropriate string pointer\n @param[in] value The value for which to get the appropriate string\n @param[in] units The unit_name_string containing the relevant strings\n @return          Pointer to the appropriate string"]
    pub fn unit_name_string_get_value(
        value: guint32,
        units: *const unit_name_string,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the unit string appropriate for the 64 bit value.\n\n From the given unit_name_string return the appropriate string pointer\n @param[in] value The value for which to get the appropriate string\n @param[in] units The unit_name_string containing the relevant strings\n @return          Pointer to the appropriate string"]
    pub fn unit_name_string_get_value64(
        value: guint64,
        units: *const unit_name_string,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the unit string appropriate for the double value.\n\n From the given unit_name_string return the appropriate string pointer\n @param[in] value The value for which to get the appropriate string\n @param[in] units The unit_name_string containing the relevant strings\n @return          Pointer to the appropriate string"]
    pub fn unit_name_string_get_double(
        value: f64,
        units: *const unit_name_string,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub static units_foot_feet: unit_name_string;
}
extern "C" {
    pub static units_bit_bits: unit_name_string;
}
extern "C" {
    pub static units_byte_bytes: unit_name_string;
}
extern "C" {
    pub static units_byte_bytespsecond: unit_name_string;
}
extern "C" {
    pub static units_octet_octets: unit_name_string;
}
extern "C" {
    pub static units_word_words: unit_name_string;
}
extern "C" {
    pub static units_tick_ticks: unit_name_string;
}
extern "C" {
    pub static units_meters: unit_name_string;
}
extern "C" {
    pub static units_meter_meters: unit_name_string;
}
extern "C" {
    pub static units_centimeters: unit_name_string;
}
extern "C" {
    pub static units_centimeter_centimeters: unit_name_string;
}
extern "C" {
    pub static units_millimeters: unit_name_string;
}
extern "C" {
    pub static units_millimeter_millimeters: unit_name_string;
}
extern "C" {
    pub static units_week_weeks: unit_name_string;
}
extern "C" {
    pub static units_day_days: unit_name_string;
}
extern "C" {
    pub static units_hour_hours: unit_name_string;
}
extern "C" {
    pub static units_hours: unit_name_string;
}
extern "C" {
    pub static units_minute_minutes: unit_name_string;
}
extern "C" {
    pub static units_minutes: unit_name_string;
}
extern "C" {
    pub static units_second_seconds: unit_name_string;
}
extern "C" {
    pub static units_seconds: unit_name_string;
}
extern "C" {
    pub static units_millisecond_milliseconds: unit_name_string;
}
extern "C" {
    pub static units_milliseconds: unit_name_string;
}
extern "C" {
    pub static units_microsecond_microseconds: unit_name_string;
}
extern "C" {
    pub static units_microseconds: unit_name_string;
}
extern "C" {
    pub static units_nanosecond_nanoseconds: unit_name_string;
}
extern "C" {
    pub static units_nanoseconds: unit_name_string;
}
extern "C" {
    pub static units_nanometers: unit_name_string;
}
extern "C" {
    pub static units_degree_degrees: unit_name_string;
}
extern "C" {
    pub static units_degree_celsius: unit_name_string;
}
extern "C" {
    pub static units_degree_bearing: unit_name_string;
}
extern "C" {
    pub static units_centibels: unit_name_string;
}
extern "C" {
    pub static units_decibels: unit_name_string;
}
extern "C" {
    pub static units_dbm: unit_name_string;
}
extern "C" {
    pub static units_dbi: unit_name_string;
}
extern "C" {
    pub static units_dbhz: unit_name_string;
}
extern "C" {
    pub static units_mbm: unit_name_string;
}
extern "C" {
    pub static units_percent: unit_name_string;
}
extern "C" {
    pub static units_khz: unit_name_string;
}
extern "C" {
    pub static units_ghz: unit_name_string;
}
extern "C" {
    pub static units_mhz: unit_name_string;
}
extern "C" {
    pub static units_hz: unit_name_string;
}
extern "C" {
    pub static units_hz_s: unit_name_string;
}
extern "C" {
    pub static units_kbit: unit_name_string;
}
extern "C" {
    pub static units_kbps: unit_name_string;
}
extern "C" {
    pub static units_kibps: unit_name_string;
}
extern "C" {
    pub static units_pkts: unit_name_string;
}
extern "C" {
    pub static units_pkts_per_sec: unit_name_string;
}
extern "C" {
    pub static units_km: unit_name_string;
}
extern "C" {
    pub static units_kmh: unit_name_string;
}
extern "C" {
    pub static units_m_s: unit_name_string;
}
extern "C" {
    pub static units_cm_s: unit_name_string;
}
extern "C" {
    pub static units_mm_s: unit_name_string;
}
extern "C" {
    pub static units_milliamps: unit_name_string;
}
extern "C" {
    pub static units_microwatts: unit_name_string;
}
extern "C" {
    pub static units_volt: unit_name_string;
}
extern "C" {
    pub static units_grams_per_second: unit_name_string;
}
extern "C" {
    pub static units_meter_sec: unit_name_string;
}
extern "C" {
    pub static units_meter_sec_squared: unit_name_string;
}
extern "C" {
    pub static units_bit_sec: unit_name_string;
}
extern "C" {
    pub static units_segment_remaining: unit_name_string;
}
extern "C" {
    pub static units_frame_frames: unit_name_string;
}
extern "C" {
    pub static units_revolutions_per_minute: unit_name_string;
}
extern "C" {
    pub static units_kilopascal: unit_name_string;
}
extern "C" {
    pub static units_newton_metre: unit_name_string;
}
extern "C" {
    pub static units_liter_per_hour: unit_name_string;
}
extern "C" {
    pub static units_amp: unit_name_string;
}
extern "C" {
    pub static units_watthour: unit_name_string;
}
extern "C" {
    pub static units_watt: unit_name_string;
}
extern "C" {
    pub static units_bpm: unit_name_string;
}
extern "C" {
    pub static units_calorie: unit_name_string;
}
extern "C" {
    pub fn packet_init();
}
extern "C" {
    pub fn packet_cache_proto_handles();
}
extern "C" {
    pub fn packet_cleanup();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dissector_handle {
    _unused: [u8; 0],
}
pub type dissector_handle_t = *mut dissector_handle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dissector_table {
    _unused: [u8; 0],
}
pub type dissector_table_t = *mut dissector_table;
pub type dissector_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut tvbuff_t,
        arg2: *mut packet_info,
        arg3: *mut proto_tree,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type dissector_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut tvbuff_t,
        arg2: *mut packet_info,
        arg3: *mut proto_tree,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Type of a heuristic dissector, used in heur_dissector_add().\n\n @param tvb the tvbuff with the (remaining) packet data\n @param pinfo the packet info of this packet (additional info)\n @param tree the protocol tree to be build or NULL\n @return TRUE if the packet was recognized by the sub-dissector (stop dissection here)"]
pub type heur_dissector_t = ::std::option::Option<
    unsafe extern "C" fn(
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
        arg1: *mut ::std::os::raw::c_void,
    ) -> gboolean,
>;
pub const heuristic_enable_e_HEURISTIC_DISABLE: heuristic_enable_e = 0;
pub const heuristic_enable_e_HEURISTIC_ENABLE: heuristic_enable_e = 1;
pub type heuristic_enable_e = ::std::os::raw::c_int;
pub type DATFunc = ::std::option::Option<
    unsafe extern "C" fn(
        table_name: *const gchar,
        selector_type: ftenum_t,
        key: gpointer,
        value: gpointer,
        user_data: gpointer,
    ),
>;
pub type DATFunc_handle = ::std::option::Option<
    unsafe extern "C" fn(table_name: *const gchar, value: gpointer, user_data: gpointer),
>;
pub type DATFunc_table = ::std::option::Option<
    unsafe extern "C" fn(table_name: *const gchar, ui_name: *const gchar, user_data: gpointer),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dtbl_entry {
    _unused: [u8; 0],
}
pub type dtbl_entry_t = dtbl_entry;
extern "C" {
    pub fn dtbl_entry_get_handle(dtbl_entry: *mut dtbl_entry_t) -> dissector_handle_t;
}
extern "C" {
    pub fn dtbl_entry_get_initial_handle(entry: *mut dtbl_entry_t) -> dissector_handle_t;
}
extern "C" {
    #[doc = " Iterate over dissectors in a table with non-default \"decode as\" settings.\n\n Walk one dissector table calling a user supplied function only on\n any entry that has been changed from its original state.\n\n @param[in] table_name The name of the dissector table, e.g. \"ip.proto\".\n @param[in] func The function to call for each dissector.\n @param[in] user_data User data to pass to the function."]
    pub fn dissector_table_foreach_changed(
        table_name: *const ::std::os::raw::c_char,
        func: DATFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " Iterate over dissectors in a table.\n\n Walk one dissector table's hash table calling a user supplied function\n on each entry.\n\n @param[in] table_name The name of the dissector table, e.g. \"ip.proto\".\n @param[in] func The function to call for each dissector.\n @param[in] user_data User data to pass to the function."]
    pub fn dissector_table_foreach(
        table_name: *const ::std::os::raw::c_char,
        func: DATFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " Iterate over dissectors with non-default \"decode as\" settings.\n\n Walk all dissector tables calling a user supplied function only on\n any \"decode as\" entry that has been changed from its original state.\n\n @param[in] func The function to call for each dissector.\n @param[in] user_data User data to pass to the function."]
    pub fn dissector_all_tables_foreach_changed(func: DATFunc, user_data: gpointer);
}
extern "C" {
    #[doc = " Iterate over dissectors in a table by handle.\n\n Walk one dissector table's list of handles calling a user supplied\n function on each entry.\n\n @param[in] table_name The name of the dissector table, e.g. \"ip.proto\".\n @param[in] func The function to call for each dissector.\n @param[in] user_data User data to pass to the function."]
    pub fn dissector_table_foreach_handle(
        table_name: *const ::std::os::raw::c_char,
        func: DATFunc_handle,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " Iterate over all dissector tables.\n\n Walk the set of dissector tables calling a user supplied function on each\n table.\n @param[in] func The function to call for each table.\n @param[in] user_data User data to pass to the function.\n @param[in] compare_key_func Function used to sort the set of tables before\n calling the function.  No sorting is done if NULL."]
    pub fn dissector_all_tables_foreach_table(
        func: DATFunc_table,
        user_data: gpointer,
        compare_key_func: GCompareFunc,
    );
}
extern "C" {
    pub fn register_dissector_table(
        name: *const ::std::os::raw::c_char,
        ui_name: *const ::std::os::raw::c_char,
        proto: ::std::os::raw::c_int,
        type_: ftenum_t,
        param: ::std::os::raw::c_int,
    ) -> dissector_table_t;
}
extern "C" {
    pub fn register_custom_dissector_table(
        name: *const ::std::os::raw::c_char,
        ui_name: *const ::std::os::raw::c_char,
        proto: ::std::os::raw::c_int,
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
        key_destroy_func: GDestroyNotify,
    ) -> dissector_table_t;
}
extern "C" {
    #[doc = " Register a dissector table alias.\n This is for dissectors whose original name has changed, e.g. SSL to TLS.\n @param dissector_table dissector table returned by register_dissector_table.\n @param alias_name alias for the dissector table name."]
    pub fn register_dissector_table_alias(
        dissector_table: dissector_table_t,
        alias_name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Deregister the dissector table by table name."]
    pub fn deregister_dissector_table(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn find_dissector_table(name: *const ::std::os::raw::c_char) -> dissector_table_t;
}
extern "C" {
    pub fn get_dissector_table_ui_name(
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_dissector_table_selector_type(name: *const ::std::os::raw::c_char) -> ftenum_t;
}
extern "C" {
    pub fn get_dissector_table_param(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dissector_dump_dissector_tables();
}
extern "C" {
    pub fn dissector_add_uint(
        name: *const ::std::os::raw::c_char,
        pattern: guint32,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_add_uint_with_preference(
        name: *const ::std::os::raw::c_char,
        pattern: guint32,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_add_uint_range(
        abbrev: *const ::std::os::raw::c_char,
        range: *mut epan_range,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_add_uint_range_with_preference(
        abbrev: *const ::std::os::raw::c_char,
        range_str: *const ::std::os::raw::c_char,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_delete_uint(
        name: *const ::std::os::raw::c_char,
        pattern: guint32,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_delete_uint_range(
        abbrev: *const ::std::os::raw::c_char,
        range: *mut epan_range,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_delete_all(name: *const ::std::os::raw::c_char, handle: dissector_handle_t);
}
extern "C" {
    pub fn dissector_change_uint(
        abbrev: *const ::std::os::raw::c_char,
        pattern: guint32,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_reset_uint(name: *const ::std::os::raw::c_char, pattern: guint32);
}
extern "C" {
    pub fn dissector_is_uint_changed(
        sub_dissectors: dissector_table_t,
        uint_val: guint32,
    ) -> gboolean;
}
extern "C" {
    pub fn dissector_try_uint(
        sub_dissectors: dissector_table_t,
        uint_val: guint32,
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dissector_try_uint_new(
        sub_dissectors: dissector_table_t,
        uint_val: guint32,
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
        add_proto_name: gboolean,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Look for a given value in a given uint dissector table and, if found,\n return the current dissector handle for that value.\n\n @param[in] sub_dissectors Dissector table to search.\n @param[in] uint_val Value to match, e.g. the port number for the TCP dissector.\n @return The matching dissector handle on success, NULL if no match is found."]
    pub fn dissector_get_uint_handle(
        sub_dissectors: dissector_table_t,
        uint_val: guint32,
    ) -> dissector_handle_t;
}
extern "C" {
    #[doc = " Look for a given value in a given uint dissector table and, if found,\n return the default dissector handle for that value.\n\n @param[in] name Dissector table name.\n @param[in] uint_val Value to match, e.g. the port number for the TCP dissector.\n @return The matching dissector handle on success, NULL if no match is found."]
    pub fn dissector_get_default_uint_handle(
        name: *const ::std::os::raw::c_char,
        uint_val: guint32,
    ) -> dissector_handle_t;
}
extern "C" {
    pub fn dissector_add_string(
        name: *const ::std::os::raw::c_char,
        pattern: *const gchar,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_delete_string(
        name: *const ::std::os::raw::c_char,
        pattern: *const gchar,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_change_string(
        name: *const ::std::os::raw::c_char,
        pattern: *const gchar,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_reset_string(name: *const ::std::os::raw::c_char, pattern: *const gchar);
}
extern "C" {
    pub fn dissector_is_string_changed(
        subdissectors: dissector_table_t,
        string: *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn dissector_try_string(
        sub_dissectors: dissector_table_t,
        string: *const gchar,
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dissector_try_string_new(
        sub_dissectors: dissector_table_t,
        string: *const gchar,
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
        add_proto_name: gboolean,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Look for a given value in a given string dissector table and, if found,\n return the current dissector handle for that value.\n\n @param[in] sub_dissectors Dissector table to search.\n @param[in] string Value to match, e.g. the OID for the BER dissector.\n @return The matching dissector handle on success, NULL if no match is found."]
    pub fn dissector_get_string_handle(
        sub_dissectors: dissector_table_t,
        string: *const gchar,
    ) -> dissector_handle_t;
}
extern "C" {
    #[doc = " Look for a given value in a given string dissector table and, if found,\n return the default dissector handle for that value.\n\n @param[in] name Dissector table name.\n @param[in] string Value to match, e.g. the OID for the BER dissector.\n @return The matching dissector handle on success, NULL if no match is found."]
    pub fn dissector_get_default_string_handle(
        name: *const ::std::os::raw::c_char,
        string: *const gchar,
    ) -> dissector_handle_t;
}
extern "C" {
    pub fn dissector_add_custom_table_handle(
        name: *const ::std::os::raw::c_char,
        pattern: *mut ::std::os::raw::c_void,
        handle: dissector_handle_t,
    );
}
extern "C" {
    #[doc = " Look for a given key in a given \"custom\" dissector table and, if found,\n return the current dissector handle for that key.\n\n @param[in] sub_dissectors Dissector table to search.\n @param[in] key Value to match, e.g. RPC key for its subdissectors\n @return The matching dissector handle on success, NULL if no match is found."]
    pub fn dissector_get_custom_table_handle(
        sub_dissectors: dissector_table_t,
        key: *mut ::std::os::raw::c_void,
    ) -> dissector_handle_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _guid_key {
    pub guid: e_guid_t,
    pub ver: guint16,
}
#[test]
fn bindgen_test_layout__guid_key() {
    const UNINIT: ::std::mem::MaybeUninit<_guid_key> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_guid_key>(),
        20usize,
        concat!("Size of: ", stringify!(_guid_key))
    );
    assert_eq!(
        ::std::mem::align_of::<_guid_key>(),
        4usize,
        concat!("Alignment of ", stringify!(_guid_key))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).guid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_guid_key),
            "::",
            stringify!(guid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ver) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_guid_key),
            "::",
            stringify!(ver)
        )
    );
}
pub type guid_key = _guid_key;
extern "C" {
    pub fn dissector_add_guid(
        name: *const ::std::os::raw::c_char,
        guid_val: *mut guid_key,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_try_guid(
        sub_dissectors: dissector_table_t,
        guid_val: *mut guid_key,
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dissector_try_guid_new(
        sub_dissectors: dissector_table_t,
        guid_val: *mut guid_key,
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
        add_proto_name: gboolean,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Look for a given value in a given guid dissector table and, if found,\n return the current dissector handle for that value.\n\n @param[in] sub_dissectors Dissector table to search.\n @param[in] guid_val Value to match, e.g. the GUID number for the GUID dissector.\n @return The matching dissector handle on success, NULL if no match is found."]
    pub fn dissector_get_guid_handle(
        sub_dissectors: dissector_table_t,
        guid_val: *mut guid_key,
    ) -> dissector_handle_t;
}
extern "C" {
    pub fn dissector_try_payload(
        sub_dissectors: dissector_table_t,
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dissector_try_payload_new(
        sub_dissectors: dissector_table_t,
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
        add_proto_name: gboolean,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dissector_change_payload(
        abbrev: *const ::std::os::raw::c_char,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_reset_payload(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn dissector_get_payload_handle(dissector_table: dissector_table_t) -> dissector_handle_t;
}
extern "C" {
    pub fn dissector_add_for_decode_as(
        name: *const ::std::os::raw::c_char,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_add_for_decode_as_with_preference(
        name: *const ::std::os::raw::c_char,
        handle: dissector_handle_t,
    );
}
extern "C" {
    #[doc = " Get the list of handles for a dissector table"]
    pub fn dissector_table_get_dissector_handles(dissector_table: dissector_table_t)
        -> *mut GSList;
}
extern "C" {
    #[doc = " Get a handle to dissector out of a dissector table given the description\n of what the dissector dissects."]
    pub fn dissector_table_get_dissector_handle(
        dissector_table: dissector_table_t,
        description: *const gchar,
    ) -> dissector_handle_t;
}
extern "C" {
    #[doc = " Get a dissector table's type"]
    pub fn dissector_table_get_type(dissector_table: dissector_table_t) -> ftenum_t;
}
extern "C" {
    #[doc = " Mark a dissector table as allowing \"Decode As\""]
    pub fn dissector_table_allow_decode_as(dissector_table: dissector_table_t);
}
extern "C" {
    #[doc = " Returns TRUE if dissector table allows \"Decode As\""]
    pub fn dissector_table_supports_decode_as(dissector_table: dissector_table_t) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heur_dissector_list {
    _unused: [u8; 0],
}
pub type heur_dissector_list_t = *mut heur_dissector_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heur_dtbl_entry {
    pub dissector: heur_dissector_t,
    pub protocol: *mut protocol_t,
    pub list_name: *mut gchar,
    pub display_name: *const gchar,
    pub short_name: *mut gchar,
    pub enabled: gboolean,
    pub enabled_by_default: bool,
}
#[test]
fn bindgen_test_layout_heur_dtbl_entry() {
    const UNINIT: ::std::mem::MaybeUninit<heur_dtbl_entry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<heur_dtbl_entry>(),
        48usize,
        concat!("Size of: ", stringify!(heur_dtbl_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<heur_dtbl_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(heur_dtbl_entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dissector) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(heur_dtbl_entry),
            "::",
            stringify!(dissector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protocol) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(heur_dtbl_entry),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).list_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(heur_dtbl_entry),
            "::",
            stringify!(list_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(heur_dtbl_entry),
            "::",
            stringify!(display_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).short_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(heur_dtbl_entry),
            "::",
            stringify!(short_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(heur_dtbl_entry),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enabled_by_default) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(heur_dtbl_entry),
            "::",
            stringify!(enabled_by_default)
        )
    );
}
pub type heur_dtbl_entry_t = heur_dtbl_entry;
extern "C" {
    #[doc = " A protocol uses this function to register a heuristic sub-dissector list.\n  Call this in the parent dissectors proto_register function.\n\n @param name the name of this protocol\n @param proto the value obtained when registering the protocol"]
    pub fn register_heur_dissector_list(
        name: *const ::std::os::raw::c_char,
        proto: ::std::os::raw::c_int,
    ) -> heur_dissector_list_t;
}
pub type DATFunc_heur = ::std::option::Option<
    unsafe extern "C" fn(
        table_name: *const gchar,
        entry: *mut heur_dtbl_entry,
        user_data: gpointer,
    ),
>;
pub type DATFunc_heur_table = ::std::option::Option<
    unsafe extern "C" fn(
        table_name: *const ::std::os::raw::c_char,
        table: *mut heur_dissector_list,
        user_data: gpointer,
    ),
>;
extern "C" {
    #[doc = " Iterate over heuristic dissectors in a table.\n\n Walk one heuristic dissector table's list calling a user supplied function\n on each entry.\n\n @param[in] table_name The name of the dissector table, e.g. \"tcp\".\n @param[in] func The function to call for each dissector.\n @param[in] user_data User data to pass to the function."]
    pub fn heur_dissector_table_foreach(
        table_name: *const ::std::os::raw::c_char,
        func: DATFunc_heur,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " Iterate over all heuristic dissector tables.\n\n Walk the set of heuristic dissector tables calling a user supplied function\n on each table.\n @param[in] func The function to call for each table.\n @param[in] user_data User data to pass to the function.\n @param[in] compare_key_func Function used to sort the set of tables before\n calling the function.  No sorting is done if NULL."]
    pub fn dissector_all_heur_tables_foreach_table(
        func: DATFunc_heur_table,
        user_data: gpointer,
        compare_key_func: GCompareFunc,
    );
}
extern "C" {
    pub fn has_heur_dissector_list(name: *const gchar) -> gboolean;
}
extern "C" {
    #[doc = " Try all the dissectors in a given heuristic dissector list. This is done,\n  until we find one that recognizes the protocol.\n  Call this while the parent dissector running.\n\n @param sub_dissectors the sub-dissector list\n @param tvb the tvbuff with the (remaining) packet data\n @param pinfo the packet info of this packet (additional info)\n @param tree the protocol tree to be build or NULL\n @param hdtbl_entry returns the last tried dissectors hdtbl_entry.\n @param data parameter to pass to subdissector\n @return TRUE if the packet was recognized by the sub-dissector (stop dissection here)"]
    pub fn dissector_try_heuristic(
        sub_dissectors: heur_dissector_list_t,
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
        hdtbl_entry: *mut *mut heur_dtbl_entry_t,
        data: *mut ::std::os::raw::c_void,
    ) -> gboolean;
}
extern "C" {
    #[doc = " Find a heuristic dissector table by table name.\n\n @param name name of the dissector table\n @return pointer to the table on success, NULL if no such table exists"]
    pub fn find_heur_dissector_list(name: *const ::std::os::raw::c_char) -> heur_dissector_list_t;
}
extern "C" {
    #[doc = " Find a heuristic dissector by the unique short protocol name provided during registration.\n\n @param short_name short name of the protocol to look at\n @return pointer to the heuristic dissector entry, NULL if not such dissector exists"]
    pub fn find_heur_dissector_by_unique_short_name(
        short_name: *const ::std::os::raw::c_char,
    ) -> *mut heur_dtbl_entry_t;
}
extern "C" {
    #[doc = " Add a sub-dissector to a heuristic dissector list.\n  Call this in the proto_handoff function of the sub-dissector.\n\n @param name the name of the heuristic dissector table into which to register the dissector, e.g. \"tcp\"\n @param dissector the sub-dissector to be registered\n @param display_name the string used to present heuristic to user, e.g. \"HTTP over TCP\"\n @param internal_name the string used for \"internal\" use to identify heuristic, e.g. \"http_tcp\"\n @param proto the protocol id of the sub-dissector\n @param enable initially enabled or not"]
    pub fn heur_dissector_add(
        name: *const ::std::os::raw::c_char,
        dissector: heur_dissector_t,
        display_name: *const ::std::os::raw::c_char,
        internal_name: *const ::std::os::raw::c_char,
        proto: ::std::os::raw::c_int,
        enable: heuristic_enable_e,
    );
}
extern "C" {
    #[doc = " Remove a sub-dissector from a heuristic dissector list.\n  Call this in the prefs_reinit function of the sub-dissector.\n\n @param name the name of the \"parent\" protocol, e.g. \"tcp\"\n @param dissector the sub-dissector to be unregistered\n @param proto the protocol id of the sub-dissector"]
    pub fn heur_dissector_delete(
        name: *const ::std::os::raw::c_char,
        dissector: heur_dissector_t,
        proto: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Register a new dissector."]
    pub fn register_dissector(
        name: *const ::std::os::raw::c_char,
        dissector: dissector_t,
        proto: ::std::os::raw::c_int,
    ) -> dissector_handle_t;
}
extern "C" {
    #[doc = " Register a new dissector with a description."]
    pub fn register_dissector_with_description(
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        dissector: dissector_t,
        proto: ::std::os::raw::c_int,
    ) -> dissector_handle_t;
}
extern "C" {
    #[doc = " Register a new dissector with a callback pointer."]
    pub fn register_dissector_with_data(
        name: *const ::std::os::raw::c_char,
        dissector: dissector_cb_t,
        proto: ::std::os::raw::c_int,
        cb_data: *mut ::std::os::raw::c_void,
    ) -> dissector_handle_t;
}
extern "C" {
    #[doc = " Deregister a dissector."]
    pub fn deregister_dissector(name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Get the long name of the protocol for a dissector handle."]
    pub fn dissector_handle_get_protocol_long_name(
        handle: dissector_handle_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the short name of the protocol for a dissector handle."]
    pub fn dissector_handle_get_protocol_short_name(
        handle: dissector_handle_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn dissector_handle_get_short_name(
        handle: dissector_handle_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the description for what the dissector for a dissector handle dissects."]
    pub fn dissector_handle_get_description(
        handle: dissector_handle_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the index of the protocol for a dissector handle."]
    pub fn dissector_handle_get_protocol_index(handle: dissector_handle_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a GList of all registered dissector names."]
    pub fn get_dissector_names() -> *mut GList;
}
extern "C" {
    #[doc = " Find a dissector by name."]
    pub fn find_dissector(name: *const ::std::os::raw::c_char) -> dissector_handle_t;
}
extern "C" {
    #[doc = " Find a dissector by name and add parent protocol as a dependency."]
    pub fn find_dissector_add_dependency(
        name: *const ::std::os::raw::c_char,
        parent_proto: ::std::os::raw::c_int,
    ) -> dissector_handle_t;
}
extern "C" {
    #[doc = " Get a dissector name from handle."]
    pub fn dissector_handle_get_dissector_name(
        handle: dissector_handle_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Create an anonymous handle for a dissector."]
    pub fn create_dissector_handle(
        dissector: dissector_t,
        proto: ::std::os::raw::c_int,
    ) -> dissector_handle_t;
}
extern "C" {
    pub fn create_dissector_handle_with_name(
        dissector: dissector_t,
        proto: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
    ) -> dissector_handle_t;
}
extern "C" {
    pub fn create_dissector_handle_with_name_and_description(
        dissector: dissector_t,
        proto: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    ) -> dissector_handle_t;
}
extern "C" {
    pub fn create_dissector_handle_with_data(
        dissector: dissector_cb_t,
        proto: ::std::os::raw::c_int,
        cb_data: *mut ::std::os::raw::c_void,
    ) -> dissector_handle_t;
}
extern "C" {
    pub fn dissector_dump_dissectors();
}
extern "C" {
    #[doc = " Call a dissector through a handle and if no dissector was found\n pass it over to the \"data\" dissector instead.\n\n   @param handle The dissector to call.\n   @param  tvb The buffer to dissect.\n   @param  pinfo Packet Info.\n   @param  tree The protocol tree.\n   @param  data parameter to pass to dissector\n   @return  If the protocol for that handle isn't enabled call the data\n   dissector. Otherwise, if the handle refers to a new-style\n   dissector, call the dissector and return its return value, otherwise call\n   it and return the length of the tvbuff pointed to by the argument."]
    pub fn call_dissector_with_data(
        handle: dissector_handle_t,
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn call_dissector(
        handle: dissector_handle_t,
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn call_data_dissector(
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Call a dissector through a handle but if no dissector was found\n just return 0 and do not call the \"data\" dissector instead.\n\n   @param handle The dissector to call.\n   @param  tvb The buffer to dissect.\n   @param  pinfo Packet Info.\n   @param  tree The protocol tree.\n   @param  data parameter to pass to dissector\n   @return  If the protocol for that handle isn't enabled, return 0 without\n   calling the dissector. Otherwise, if the handle refers to a new-style\n   dissector, call the dissector and return its return value, otherwise call\n   it and return the length of the tvbuff pointed to by the argument."]
    pub fn call_dissector_only(
        handle: dissector_handle_t,
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "   @param heur_dtbl_entry The heur_dtbl_entry of the dissector to call.\n   @param  tvb The buffer to dissect.\n   @param  pinfo Packet Info.\n   @param  tree The protocol tree.\n   @param  data parameter to pass to dissector"]
    pub fn call_heur_dissector_direct(
        heur_dtbl_entry: *mut heur_dtbl_entry_t,
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
        data: *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct depend_dissector_list {
    _unused: [u8; 0],
}
pub type depend_dissector_list_t = *mut depend_dissector_list;
extern "C" {
    #[doc = " Register a protocol dependency\n This is done automatically when registering with a dissector or\n heuristic table.  This is for \"manual\" registration when a dissector\n ends up calling another through call_dissector (or similar) so\n dependencies can be determined\n\n   @param parent \"Parent\" protocol short name\n   @param dependent \"Dependent\" protocol short name\n   @return  return TRUE if dependency was successfully registered"]
    pub fn register_depend_dissector(
        parent: *const ::std::os::raw::c_char,
        dependent: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    #[doc = " Unregister a protocol dependency\n This is done automatically when removing from a dissector or\n heuristic table.  This is for \"manual\" deregistration for things\n like Lua.\n\n   @param parent \"Parent\" protocol short name\n   @param dependent \"Dependent\" protocol short name\n   @return  return TRUE if dependency was successfully unregistered"]
    pub fn deregister_depend_dissector(
        parent: *const ::std::os::raw::c_char,
        dependent: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    #[doc = " Find the list of protocol dependencies\n\n   @param name Protocol short name to search for\n   @return  return list of dependent was successfully registered"]
    pub fn find_depend_dissector_list(
        name: *const ::std::os::raw::c_char,
    ) -> depend_dissector_list_t;
}
extern "C" {
    pub fn dissect_init();
}
extern "C" {
    pub fn dissect_cleanup();
}
extern "C" {
    pub fn set_actual_length(tvb: *mut tvbuff_t, specified_len: guint);
}
extern "C" {
    #[doc = " Allow protocols to register \"init\" routines, which are called before\n we make a pass through a capture file and dissect all its packets\n (e.g., when we read in a new capture file, or run a \"filter packets\"\n or \"colorize packets\" pass over the current capture file or when the\n preferences are changed)."]
    pub fn register_init_routine(func: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    #[doc = " Allows protocols to register \"cleanup\" routines, which are called\n after closing a capture file (or when preferences are changed, in\n that case these routines are called before the init routines are\n executed). It can be used to release resources that are allocated in\n an \"init\" routine."]
    pub fn register_cleanup_routine(func: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn register_shutdown_routine(func: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn init_dissection();
}
extern "C" {
    pub fn cleanup_dissection();
}
extern "C" {
    pub fn register_postseq_cleanup_routine(func: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn postseq_cleanup_all_protocols();
}
extern "C" {
    pub fn register_final_registration_routine(func: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn final_registration_all_protocols();
}
extern "C" {
    pub fn add_new_data_source(
        pinfo: *mut packet_info,
        tvb: *mut tvbuff_t,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn remove_last_data_source(pinfo: *mut packet_info);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct data_source {
    _unused: [u8; 0],
}
extern "C" {
    pub fn get_data_source_name(src: *const data_source) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_data_source_tvb(src: *const data_source) -> *mut tvbuff_t;
}
extern "C" {
    pub fn get_data_source_tvb_by_name(
        pinfo: *mut packet_info,
        name: *const ::std::os::raw::c_char,
    ) -> *mut tvbuff_t;
}
extern "C" {
    pub fn free_data_sources(pinfo: *mut packet_info);
}
extern "C" {
    pub fn mark_frame_as_depended_upon(fd: *mut frame_data, frame_num: guint32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frame_data_s {
    pub file_type_subtype: ::std::os::raw::c_int,
    #[doc = "< NULL if not available"]
    pub pkt_block: wtap_block_t,
    pub color_edt: *mut epan_dissect,
}
#[test]
fn bindgen_test_layout_frame_data_s() {
    const UNINIT: ::std::mem::MaybeUninit<frame_data_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frame_data_s>(),
        24usize,
        concat!("Size of: ", stringify!(frame_data_s))
    );
    assert_eq!(
        ::std::mem::align_of::<frame_data_s>(),
        8usize,
        concat!("Alignment of ", stringify!(frame_data_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_type_subtype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frame_data_s),
            "::",
            stringify!(file_type_subtype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pkt_block) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frame_data_s),
            "::",
            stringify!(pkt_block)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_edt) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frame_data_s),
            "::",
            stringify!(color_edt)
        )
    );
}
pub type frame_data_t = frame_data_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_data_s {
    #[doc = "< NULL if not available"]
    pub pkt_block: wtap_block_t,
    pub color_edt: *mut epan_dissect,
}
#[test]
fn bindgen_test_layout_file_data_s() {
    const UNINIT: ::std::mem::MaybeUninit<file_data_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<file_data_s>(),
        16usize,
        concat!("Size of: ", stringify!(file_data_s))
    );
    assert_eq!(
        ::std::mem::align_of::<file_data_s>(),
        8usize,
        concat!("Alignment of ", stringify!(file_data_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pkt_block) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_data_s),
            "::",
            stringify!(pkt_block)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_edt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_data_s),
            "::",
            stringify!(color_edt)
        )
    );
}
pub type file_data_t = file_data_s;
extern "C" {
    pub fn dissect_record(
        edt: *mut epan_dissect,
        file_type_subtype: ::std::os::raw::c_int,
        rec: *mut wtap_rec,
        tvb: *mut tvbuff_t,
        fd: *mut frame_data,
        cinfo: *mut column_info,
    );
}
extern "C" {
    pub fn dissect_file(
        edt: *mut epan_dissect,
        rec: *mut wtap_rec,
        tvb: *mut tvbuff_t,
        fd: *mut frame_data,
        cinfo: *mut column_info,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethertype_data_s {
    pub etype: guint16,
    pub payload_offset: ::std::os::raw::c_int,
    pub fh_tree: *mut proto_tree,
    pub trailer_id: ::std::os::raw::c_int,
    pub fcs_len: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ethertype_data_s() {
    const UNINIT: ::std::mem::MaybeUninit<ethertype_data_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethertype_data_s>(),
        24usize,
        concat!("Size of: ", stringify!(ethertype_data_s))
    );
    assert_eq!(
        ::std::mem::align_of::<ethertype_data_s>(),
        8usize,
        concat!("Alignment of ", stringify!(ethertype_data_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).etype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethertype_data_s),
            "::",
            stringify!(etype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).payload_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethertype_data_s),
            "::",
            stringify!(payload_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fh_tree) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethertype_data_s),
            "::",
            stringify!(fh_tree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trailer_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethertype_data_s),
            "::",
            stringify!(trailer_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fcs_len) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ethertype_data_s),
            "::",
            stringify!(fcs_len)
        )
    );
}
pub type ethertype_data_t = ethertype_data_s;
extern "C" {
    pub fn dissector_dump_decodes();
}
extern "C" {
    pub fn dissector_dump_heur_decodes();
}
extern "C" {
    pub fn register_postdissector(handle: dissector_handle_t);
}
extern "C" {
    pub fn set_postdissector_wanted_hfids(handle: dissector_handle_t, wanted_hfids: *mut GArray);
}
extern "C" {
    pub fn deregister_postdissector(handle: dissector_handle_t);
}
extern "C" {
    pub fn have_postdissector() -> gboolean;
}
extern "C" {
    pub fn call_all_postdissectors(
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
    );
}
extern "C" {
    pub fn postdissectors_want_hfids() -> gboolean;
}
extern "C" {
    pub fn prime_epan_dissect_with_postdissector_wanted_hfids(edt: *mut epan_dissect_t);
}
#[doc = " callback function definition: return formatted label string"]
pub type build_label_func =
    ::std::option::Option<unsafe extern "C" fn(pinfo: *mut packet_info, result: *mut gchar)>;
#[doc = " callback function definition: return value used to pass to dissector table"]
pub type build_valid_func =
    ::std::option::Option<unsafe extern "C" fn(pinfo: *mut packet_info) -> gpointer>;
pub type decode_as_add_to_list_func = ::std::option::Option<
    unsafe extern "C" fn(
        table_name: *const gchar,
        proto_name: *const gchar,
        value: gpointer,
        user_data: gpointer,
    ),
>;
pub type decode_as_populate_list_func = ::std::option::Option<
    unsafe extern "C" fn(
        table_name: *const gchar,
        add_to_list: decode_as_add_to_list_func,
        ui_element: gpointer,
    ),
>;
pub type decode_as_free_func = ::std::option::Option<unsafe extern "C" fn(value: gpointer)>;
#[doc = " callback function definition: Clear value from dissector table"]
pub type decode_as_reset_func = ::std::option::Option<
    unsafe extern "C" fn(name: *const gchar, pattern: gconstpointer) -> gboolean,
>;
#[doc = " callback function definition: Apply value to dissector table"]
pub type decode_as_change_func = ::std::option::Option<
    unsafe extern "C" fn(
        name: *const gchar,
        pattern: gconstpointer,
        handle: gconstpointer,
        list_name: *const gchar,
    ) -> gboolean,
>;
#[doc = "Contains all of the function pointers (typically just 1) that\nprovide the text explaining the name and use of the value field that will\nbe passed to the dissector table to change the dissection output."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct decode_as_value_s {
    #[doc = "< function pointer to the function used to create the label"]
    pub label_func: build_label_func,
    #[doc = "< Number of values"]
    pub num_values: guint,
    #[doc = "< Function used to build the value to go into the table. Retreive from current frame"]
    pub build_values: *mut build_valid_func,
}
#[test]
fn bindgen_test_layout_decode_as_value_s() {
    const UNINIT: ::std::mem::MaybeUninit<decode_as_value_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<decode_as_value_s>(),
        24usize,
        concat!("Size of: ", stringify!(decode_as_value_s))
    );
    assert_eq!(
        ::std::mem::align_of::<decode_as_value_s>(),
        8usize,
        concat!("Alignment of ", stringify!(decode_as_value_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).label_func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(decode_as_value_s),
            "::",
            stringify!(label_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_values) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(decode_as_value_s),
            "::",
            stringify!(num_values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).build_values) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(decode_as_value_s),
            "::",
            stringify!(build_values)
        )
    );
}
#[doc = "Contains all of the function pointers (typically just 1) that\nprovide the text explaining the name and use of the value field that will\nbe passed to the dissector table to change the dissection output."]
pub type decode_as_value_t = decode_as_value_s;
#[doc = "Pulls everything together including the dissector (protocol) name, the\n\"layer type\" of the dissector, the dissector table name, the function pointer\nvalues as well as handlers for populating, applying and reseting the changes\nto the dissector table through Decode As GUI functionality. For dissector\ntables that are an integer or string type, the provided \"default\" handling\nfunctions should suffice."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct decode_as_s {
    #[doc = "< Protocol name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Disector table name"]
    pub table_name: *const gchar,
    #[doc = "< Number of index in the decode_as_value_t struct"]
    pub num_items: guint,
    #[doc = "< Which display function to use first, set to zero if only one function"]
    pub default_index_value: guint,
    #[doc = "< The array of function pointers, see decode_as_value_t"]
    pub values: *mut decode_as_value_t,
    #[doc = "< String to prepend the value, NULL if none"]
    pub pre_value_str: *const ::std::os::raw::c_char,
    #[doc = "< String to append the value, NULL if none"]
    pub post_value_str: *const ::std::os::raw::c_char,
    #[doc = "< function pointer to the function used to populate the list, NULL if none"]
    pub populate_list: decode_as_populate_list_func,
    #[doc = "< function pointer to the function used resetting the value, NULL if none"]
    pub reset_value: decode_as_reset_func,
    #[doc = "< function pointer to the function used resetting the value, NULL if none"]
    pub change_value: decode_as_change_func,
    #[doc = "< function pointer to the function used freeing the entry, NULL if none"]
    pub free_func: decode_as_free_func,
}
#[test]
fn bindgen_test_layout_decode_as_s() {
    const UNINIT: ::std::mem::MaybeUninit<decode_as_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<decode_as_s>(),
        80usize,
        concat!("Size of: ", stringify!(decode_as_s))
    );
    assert_eq!(
        ::std::mem::align_of::<decode_as_s>(),
        8usize,
        concat!("Alignment of ", stringify!(decode_as_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(decode_as_s),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).table_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(decode_as_s),
            "::",
            stringify!(table_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_items) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(decode_as_s),
            "::",
            stringify!(num_items)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_index_value) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(decode_as_s),
            "::",
            stringify!(default_index_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(decode_as_s),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pre_value_str) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(decode_as_s),
            "::",
            stringify!(pre_value_str)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).post_value_str) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(decode_as_s),
            "::",
            stringify!(post_value_str)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).populate_list) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(decode_as_s),
            "::",
            stringify!(populate_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reset_value) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(decode_as_s),
            "::",
            stringify!(reset_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).change_value) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(decode_as_s),
            "::",
            stringify!(change_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_func) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(decode_as_s),
            "::",
            stringify!(free_func)
        )
    );
}
#[doc = "Pulls everything together including the dissector (protocol) name, the\n\"layer type\" of the dissector, the dissector table name, the function pointer\nvalues as well as handlers for populating, applying and reseting the changes\nto the dissector table through Decode As GUI functionality. For dissector\ntables that are an integer or string type, the provided \"default\" handling\nfunctions should suffice."]
pub type decode_as_t = decode_as_s;
extern "C" {
    #[doc = " register a \"Decode As\".  A copy of the decode_as_t will be maintained by the decode_as module"]
    pub fn register_decode_as(reg: *mut decode_as_t);
}
extern "C" {
    #[doc = " Register a \"Decode As\" entry for the special case where there is no\n  indication for the next protocol (such as port number etc.).\n  For now, this will use a uint32 dissector table internally and\n  assign all registered protocols to 0. The framework to do this can\n  be kept internal to epan.\n\n @param proto The protocol ID to create the dissector table.\n @param table_name The table name in which this dissector is found.\n @param ui_name UI name for created dissector table.\n @param label_func Pointer to optional function to generate prompt text\n  for dissector.  If NULL, \"Next level protocol as\" is used.\n\n @return Created dissector table with Decode As support"]
    pub fn register_decode_as_next_proto(
        proto: ::std::os::raw::c_int,
        table_name: *const gchar,
        ui_name: *const gchar,
        label_func: build_label_func,
    ) -> *mut dissector_table;
}
extern "C" {
    pub fn decode_as_default_populate_list(
        table_name: *const gchar,
        add_to_list: decode_as_add_to_list_func,
        ui_element: gpointer,
    );
}
extern "C" {
    pub fn decode_as_default_reset(name: *const gchar, pattern: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn decode_as_default_change(
        name: *const gchar,
        pattern: gconstpointer,
        handle: gconstpointer,
        list_name: *const gchar,
    ) -> gboolean;
}
extern "C" {
    #[doc = " List of registered decode_as_t structs.\n For UI code only. Should not be directly accessed by dissectors."]
    pub static mut decode_as_list: *mut GList;
}
extern "C" {
    #[doc = " Reset the \"decode as\" entries and reload ones of the current profile.\n This is called by epan_load_settings(); programs should call that\n rather than individually calling the routines it calls."]
    pub fn load_decode_as_entries();
}
extern "C" {
    #[doc = " Write out the \"decode as\" entries of the current profile."]
    pub fn save_decode_as_entries(err: *mut *mut gchar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Clear all \"decode as\" settings."]
    pub fn decode_clear_all();
}
extern "C" {
    #[doc = " Frees memory used by \"decode as\" routines. Called at program shutdown."]
    pub fn decode_cleanup();
}
extern "C" {
    #[doc = " This routine creates one entry in the list of protocol dissector\n that need to be reset. It is called by the g_hash_table_foreach\n routine once for each changed entry in a dissector table.\n Unfortunately it cannot delete the entry immediately as this screws\n up the foreach function, so it builds a list of dissectors to be\n reset once the foreach routine finishes.\n\n @param table_name The table name in which this dissector is found.\n\n @param selector_type The type of the selector in that dissector table\n\n @param key A pointer to the key for this entry in the dissector\n hash table.  This is generally the numeric selector of the\n protocol, i.e. the ethernet type code, IP port number, TCP port\n number, etc.\n\n @param value A pointer to the value for this entry in the dissector\n hash table.  This is an opaque pointer that can only be handed back\n to routine in the file packet.c - but it's unused.\n\n @param user_data Unused."]
    pub fn decode_build_reset_list(
        table_name: *const gchar,
        selector_type: ftenum_t,
        key: gpointer,
        value: gpointer,
        user_data: gpointer,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
#[doc = "< Data that can be used for address+port conversations, including wildcarding"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conversation_addr_port_endpoints {
    pub _address: u8,
}
